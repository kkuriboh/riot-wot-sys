/* automatically generated by rust-bindgen 0.62.0 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
	#[inline]
	pub const fn new() -> Self {
		__IncompleteArrayField(::core::marker::PhantomData, [])
	}
	#[inline]
	pub fn as_ptr(&self) -> *const T {
		self as *const _ as *const T
	}
	#[inline]
	pub fn as_mut_ptr(&mut self) -> *mut T {
		self as *mut _ as *mut T
	}
	#[inline]
	pub unsafe fn as_slice(&self, len: usize) -> &[T] {
		unsafe { ::core::slice::from_raw_parts(self.as_ptr(), len) }
	}
	#[inline]
	pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
		unsafe { ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len) }
	}
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
	fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
		fmt.write_str("__IncompleteArrayField")
	}
}
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const THREAD_STACKSIZE_DEFAULT: u32 = 8192;
pub const THREAD_STACKSIZE_IDLE: u32 = 8192;
pub const THREAD_EXTRA_STACKSIZE_PRINTF: u32 = 4096;
pub const THREAD_EXTRA_STACKSIZE_PRINTF_FLOAT: u32 = 4096;
pub const THREAD_STACKSIZE_MINIMUM: u32 = 8192;
pub const ISR_STACKSIZE: u32 = 8192;
pub const NATIVE_ETH_PROTO: u32 = 4660;
pub const FLASHPAGE_SIZE: u32 = 512;
pub const FLASHPAGE_NUMOF: u32 = 32;
pub const FLASHPAGE_WRITE_BLOCK_ALIGNMENT: u32 = 8;
pub const FLASHPAGE_WRITE_BLOCK_SIZE: u32 = 16;
pub const FLASHPAGE_ERASE_STATE: u32 = 0;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2usize] = b"l\0";
pub const PRId8: &[u8; 2usize] = b"d\0";
pub const PRId16: &[u8; 2usize] = b"d\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &[u8; 2usize] = b"d\0";
pub const PRIdFAST16: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &[u8; 3usize] = b"ld\0";
pub const PRIi8: &[u8; 2usize] = b"i\0";
pub const PRIi16: &[u8; 2usize] = b"i\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 3usize] = b"li\0";
pub const PRIiFAST8: &[u8; 2usize] = b"i\0";
pub const PRIiFAST16: &[u8; 3usize] = b"li\0";
pub const PRIiFAST32: &[u8; 3usize] = b"li\0";
pub const PRIiFAST64: &[u8; 3usize] = b"li\0";
pub const PRIo8: &[u8; 2usize] = b"o\0";
pub const PRIo16: &[u8; 2usize] = b"o\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &[u8; 2usize] = b"o\0";
pub const PRIoFAST16: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &[u8; 3usize] = b"lo\0";
pub const PRIu8: &[u8; 2usize] = b"u\0";
pub const PRIu16: &[u8; 2usize] = b"u\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &[u8; 2usize] = b"u\0";
pub const PRIuFAST16: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &[u8; 3usize] = b"lu\0";
pub const PRIx8: &[u8; 2usize] = b"x\0";
pub const PRIx16: &[u8; 2usize] = b"x\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &[u8; 2usize] = b"x\0";
pub const PRIxFAST16: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &[u8; 3usize] = b"lx\0";
pub const PRIX8: &[u8; 2usize] = b"X\0";
pub const PRIX16: &[u8; 2usize] = b"X\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &[u8; 2usize] = b"X\0";
pub const PRIXFAST16: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"ld\0";
pub const PRIiMAX: &[u8; 3usize] = b"li\0";
pub const PRIoMAX: &[u8; 3usize] = b"lo\0";
pub const PRIuMAX: &[u8; 3usize] = b"lu\0";
pub const PRIxMAX: &[u8; 3usize] = b"lx\0";
pub const PRIXMAX: &[u8; 3usize] = b"lX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &[u8; 3usize] = b"ld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 3usize] = b"li\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3usize] = b"li\0";
pub const SCNiFAST32: &[u8; 3usize] = b"li\0";
pub const SCNiFAST64: &[u8; 3usize] = b"li\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &[u8; 3usize] = b"lu\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &[u8; 3usize] = b"lo\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"ld\0";
pub const SCNiMAX: &[u8; 3usize] = b"li\0";
pub const SCNoMAX: &[u8; 3usize] = b"lo\0";
pub const SCNuMAX: &[u8; 3usize] = b"lu\0";
pub const SCNxMAX: &[u8; 3usize] = b"lx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const MAXTHREADS: u32 = 32;
pub const KERNEL_PID_UNDEF: u32 = 0;
pub const KERNEL_PID_FIRST: u32 = 1;
pub const KERNEL_PID_LAST: u32 = 32;
pub const PRIkernel_pid: &[u8; 2usize] = b"i\0";
pub const SCHED_PRIO_LEVELS: u32 = 16;
pub const KERNEL_PID_ISR: u32 = 33;
pub const THREAD_STACKSIZE_MAIN: u32 = 12288;
pub const THREAD_STACKSIZE_MEDIUM: u32 = 8192;
pub const THREAD_STACKSIZE_SMALL: u32 = 4096;
pub const THREAD_STACKSIZE_TINY: u32 = 2048;
pub const THREAD_PRIORITY_MIN: u32 = 15;
pub const THREAD_PRIORITY_IDLE: u32 = 15;
pub const THREAD_PRIORITY_MAIN: u32 = 7;
pub const THREAD_CREATE_SLEEPING: u32 = 1;
pub const THREAD_AUTO_FREE: u32 = 2;
pub const THREAD_CREATE_WOUT_YIELD: u32 = 4;
pub const THREAD_CREATE_STACKTEST: u32 = 8;
pub const THREAD_FLAG_MSG_WAITING: u32 = 32768;
pub const THREAD_FLAG_TIMEOUT: u32 = 16384;
pub const THREAD_FLAG_PREDEFINED_MASK: u32 = 49152;
pub const THREAD_FLAG_EVENT: u32 = 1;
pub const ZTIMER_CLOCK_NO_REQUIRED_PM_MODE: u32 = 255;
pub const MSG_ZTIMER: u32 = 51262;
pub const IPV6_ADDR_BIT_LEN: u32 = 128;
pub const IPV6_ADDR_SITE_LOCAL_PREFIX: u32 = 65216;
pub const IPV6_ADDR_MCAST_FLAG_TRANSIENT: u32 = 1;
pub const IPV6_ADDR_MCAST_FLAG_PREFIX_BASED: u32 = 2;
pub const IPV6_ADDR_MCAST_FLAG_EMBED_ON_RP: u32 = 4;
pub const IPV6_ADDR_MCAST_SCP_IF_LOCAL: u32 = 1;
pub const IPV6_ADDR_MCAST_SCP_LINK_LOCAL: u32 = 2;
pub const IPV6_ADDR_MCAST_SCP_REALM_LOCAL: u32 = 3;
pub const IPV6_ADDR_MCAST_SCP_ADMIN_LOCAL: u32 = 4;
pub const IPV6_ADDR_MCAST_SCP_SITE_LOCAL: u32 = 5;
pub const IPV6_ADDR_MCAST_SCP_ORG_LOCAL: u32 = 8;
pub const IPV6_ADDR_MCAST_SCP_GLOBAL: u32 = 14;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_TIME_H: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const CONFIG_POSIX_FD_SET_SIZE: u32 = 16;
pub const POSIX_SELECT_THREAD_FLAG: u32 = 8;
pub const FD_SETSIZE: u32 = 16;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48usize] =
	b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5usize] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5usize] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const SOCK_FLAGS_REUSE_EP: u32 = 1;
pub const SOCK_ADDR_ANY_NETIF: u32 = 0;
pub const SOCK_NO_TIMEOUT: u32 = 4294967295;
pub const ETHERTYPE_RESERVED: u32 = 0;
pub const ETHERTYPE_IPV4: u32 = 2048;
pub const ETHERTYPE_ARP: u32 = 2054;
pub const ETHERTYPE_CCNX: u32 = 2049;
pub const ETHERTYPE_NDN: u32 = 34340;
pub const ETHERTYPE_IPV6: u32 = 34525;
pub const ETHERTYPE_6LOENC: u32 = 41197;
pub const ETHERTYPE_CUSTOM: u32 = 257;
pub const ETHERTYPE_UNKNOWN: u32 = 65535;
pub const PROTNUM_IPV6_EXT_HOPOPT: u32 = 0;
pub const PROTNUM_ICMP: u32 = 1;
pub const PROTNUM_IGMP: u32 = 2;
pub const PROTNUM_GGP: u32 = 3;
pub const PROTNUM_IPV4: u32 = 4;
pub const PROTNUM_ST: u32 = 5;
pub const PROTNUM_TCP: u32 = 6;
pub const PROTNUM_CBT: u32 = 7;
pub const PROTNUM_EGP: u32 = 8;
pub const PROTNUM_IGP: u32 = 9;
pub const PROTNUM_BBN_RCC_MON: u32 = 10;
pub const PROTNUM_NVP_II: u32 = 11;
pub const PROTNUM_PUP: u32 = 12;
pub const PROTNUM_ARGUS: u32 = 13;
pub const PROTNUM_EMCON: u32 = 14;
pub const PROTNUM_XNET: u32 = 15;
pub const PROTNUM_CHAOS: u32 = 16;
pub const PROTNUM_UDP: u32 = 17;
pub const PROTNUM_MUX: u32 = 18;
pub const PROTNUM_DCN_MEAS: u32 = 19;
pub const PROTNUM_HMP: u32 = 20;
pub const PROTNUM_PRM: u32 = 21;
pub const PROTNUM_XNS_IDP: u32 = 22;
pub const PROTNUM_TRUNK_1: u32 = 23;
pub const PROTNUM_TRUNK_2: u32 = 24;
pub const PROTNUM_LEAF_1: u32 = 25;
pub const PROTNUM_LEAF_2: u32 = 26;
pub const PROTNUM_RDP: u32 = 27;
pub const PROTNUM_IRTP: u32 = 28;
pub const PROTNUM_ISO_TP4: u32 = 29;
pub const PROTNUM_NETBLT: u32 = 30;
pub const PROTNUM_MFE_NSP: u32 = 31;
pub const PROTNUM_MERIT_INP: u32 = 32;
pub const PROTNUM_DCCP: u32 = 33;
pub const PROTNUM_3PC: u32 = 34;
pub const PROTNUM_IDPR: u32 = 35;
pub const PROTNUM_XTP: u32 = 36;
pub const PROTNUM_DDP: u32 = 37;
pub const PROTNUM_IDPR_CMTP: u32 = 38;
pub const PROTNUM_TPPLUSPLUS: u32 = 39;
pub const PROTNUM_IL: u32 = 40;
pub const PROTNUM_IPV6: u32 = 41;
pub const PROTNUM_SDRP: u32 = 42;
pub const PROTNUM_IPV6_EXT_RH: u32 = 43;
pub const PROTNUM_IPV6_EXT_FRAG: u32 = 44;
pub const PROTNUM_IDRP: u32 = 45;
pub const PROTNUM_RSVP: u32 = 46;
pub const PROTNUM_GRE: u32 = 47;
pub const PROTNUM_DSR: u32 = 48;
pub const PROTNUM_BNA: u32 = 49;
pub const PROTNUM_IPV6_EXT_ESP: u32 = 50;
pub const PROTNUM_IPV6_EXT_AH: u32 = 51;
pub const PROTNUM_I_NLSP: u32 = 52;
pub const PROTNUM_SWIPE: u32 = 53;
pub const PROTNUM_NARP: u32 = 54;
pub const PROTNUM_MOBILE: u32 = 55;
pub const PROTNUM_TLSP: u32 = 56;
pub const PROTNUM_SKIP: u32 = 57;
pub const PROTNUM_ICMPV6: u32 = 58;
pub const PROTNUM_IPV6_NONXT: u32 = 59;
pub const PROTNUM_IPV6_EXT_DST: u32 = 60;
pub const PROTNUM_CFTP: u32 = 62;
pub const PROTNUM_SAT_EXPAK: u32 = 64;
pub const PROTNUM_KRYPTOLAN: u32 = 65;
pub const PROTNUM_RVD: u32 = 66;
pub const PROTNUM_IPPC: u32 = 67;
pub const PROTNUM_SAT_MON: u32 = 69;
pub const PROTNUM_VISA: u32 = 70;
pub const PROTNUM_IPCV: u32 = 71;
pub const PROTNUM_CPNX: u32 = 72;
pub const PROTNUM_CPHB: u32 = 73;
pub const PROTNUM_WSN: u32 = 74;
pub const PROTNUM_PVP: u32 = 75;
pub const PROTNUM_BR_SAT_MON: u32 = 76;
pub const PROTNUM_SUN_ND: u32 = 77;
pub const PROTNUM_WB_MON: u32 = 78;
pub const PROTNUM_WB_EXPAK: u32 = 79;
pub const PROTNUM_ISO_IP: u32 = 80;
pub const PROTNUM_VMTP: u32 = 81;
pub const PROTNUM_SECURE_VMTP: u32 = 82;
pub const PROTNUM_VINES: u32 = 83;
pub const PROTNUM_TTP: u32 = 84;
pub const PROTNUM_IPTM: u32 = 84;
pub const PROTNUM_NSFNET_IGP: u32 = 85;
pub const PROTNUM_DGP: u32 = 86;
pub const PROTNUM_TCF: u32 = 87;
pub const PROTNUM_EIGRP: u32 = 88;
pub const PROTNUM_OSPFIGP: u32 = 89;
pub const PROTNUM_SPRITE_RPC: u32 = 90;
pub const PROTNUM_LARP: u32 = 91;
pub const PROTNUM_MTP: u32 = 92;
pub const PROTNUM_AX_25: u32 = 93;
pub const PROTNUM_IPIP: u32 = 94;
pub const PROTNUM_MICP: u32 = 95;
pub const PROTNUM_SCC_SP: u32 = 96;
pub const PROTNUM_ETHERIP: u32 = 97;
pub const PROTNUM_ENCAP: u32 = 98;
pub const PROTNUM_GMTP: u32 = 100;
pub const PROTNUM_IFMP: u32 = 101;
pub const PROTNUM_PNNI: u32 = 102;
pub const PROTNUM_PIM: u32 = 103;
pub const PROTNUM_ARIS: u32 = 104;
pub const PROTNUM_SCPS: u32 = 105;
pub const PROTNUM_QNX: u32 = 106;
pub const PROTNUM_A_N: u32 = 107;
pub const PROTNUM_IPCOMP: u32 = 108;
pub const PROTNUM_SNP: u32 = 109;
pub const PROTNUM_COMPAQ_PEER: u32 = 110;
pub const PROTNUM_IPX_IN_IP: u32 = 111;
pub const PROTNUM_VRRP: u32 = 112;
pub const PROTNUM_PGM: u32 = 113;
pub const PROTNUM_L2TP: u32 = 115;
pub const PROTNUM_DDX: u32 = 116;
pub const PROTNUM_IATP: u32 = 117;
pub const PROTNUM_STP: u32 = 118;
pub const PROTNUM_SRP: u32 = 119;
pub const PROTNUM_UTI: u32 = 120;
pub const PROTNUM_SMP: u32 = 121;
pub const PROTNUM_SM: u32 = 122;
pub const PROTNUM_PTP: u32 = 123;
pub const PROTNUM_ISIS_OVER_IPV4: u32 = 124;
pub const PROTNUM_FIRE: u32 = 125;
pub const PROTNUM_CRTP: u32 = 126;
pub const PROTNUM_CRUDP: u32 = 127;
pub const PROTNUM_SSCOPMCE: u32 = 128;
pub const PROTNUM_IPLT: u32 = 129;
pub const PROTNUM_SPS: u32 = 130;
pub const PROTNUM_PIPE: u32 = 131;
pub const PROTNUM_SCTP: u32 = 132;
pub const PROTNUM_FC: u32 = 133;
pub const PROTNUM_RSVP_E2E_IGNORE: u32 = 134;
pub const PROTNUM_IPV6_EXT_MOB: u32 = 135;
pub const PROTNUM_UDPLITE: u32 = 136;
pub const PROTNUM_MPLS_IN_IP: u32 = 137;
pub const PROTNUM_MANET: u32 = 138;
pub const PROTNUM_HIP: u32 = 139;
pub const PROTNUM_SHIM6: u32 = 140;
pub const PROTNUM_WESP: u32 = 141;
pub const PROTNUM_ROHC: u32 = 142;
pub const PROTNUM_RESERVED: u32 = 255;
pub const GNRC_NETAPI_MSG_TYPE_RCV: u32 = 513;
pub const GNRC_NETAPI_MSG_TYPE_SND: u32 = 514;
pub const GNRC_NETAPI_MSG_TYPE_SET: u32 = 515;
pub const GNRC_NETAPI_MSG_TYPE_GET: u32 = 516;
pub const GNRC_NETAPI_MSG_TYPE_ACK: u32 = 517;
pub const GNRC_NETREG_DEMUX_CTX_ALL: u32 = 4294901760;
pub const DHCPV6_CLIENT_STACK_SIZE: u32 = 8192;
pub const DHCPV6_CLIENT_PRIORITY: u32 = 5;
pub const DHCPV6_CLIENT_BUFLEN: u32 = 256;
pub const CONFIG_DHCPV6_CLIENT_PFX_LEASE_MAX: u32 = 1;
pub const CONFIG_DHCPV6_CLIENT_ADDR_LEASE_MAX: u32 = 1;
pub const DHCPV6_CLIENT_ADDRS_NUMOF: u32 = 0;
pub const CONFIG_DHCPV6_CLIENT_MUD_URL: &[u8; 20usize] = b"https://example.org\0";
pub const DHCPV6_CLIENT_SEND_BUFLEN: u32 = 256;
pub const EUI64_LOCAL_FLAG: u32 = 2;
pub const EUI64_GROUP_FLAG: u32 = 1;
pub const IEEE802154_SFD: u32 = 167;
pub const IEEE802154_SHORT_ADDRESS_LEN: u32 = 2;
pub const IEEE802154_LONG_ADDRESS_LEN: u32 = 8;
pub const IEEE802154_MAX_HDR_LEN: u32 = 23;
pub const IEEE802154_FCF_LEN: u32 = 2;
pub const IEEE802154_FCS_LEN: u32 = 2;
pub const IEEE802154_FCF_TYPE_MASK: u32 = 7;
pub const IEEE802154_FCF_TYPE_BEACON: u32 = 0;
pub const IEEE802154_FCF_TYPE_DATA: u32 = 1;
pub const IEEE802154_FCF_TYPE_ACK: u32 = 2;
pub const IEEE802154_FCF_TYPE_MACCMD: u32 = 3;
pub const IEEE802154_FCF_SECURITY_EN: u32 = 8;
pub const IEEE802154_FCF_FRAME_PEND: u32 = 16;
pub const IEEE802154_FCF_ACK_REQ: u32 = 32;
pub const IEEE802154_FCF_PAN_COMP: u32 = 64;
pub const IEEE802154_FCF_DST_ADDR_MASK: u32 = 12;
pub const IEEE802154_FCF_DST_ADDR_VOID: u32 = 0;
pub const IEEE802154_FCF_DST_ADDR_RESV: u32 = 4;
pub const IEEE802154_FCF_DST_ADDR_SHORT: u32 = 8;
pub const IEEE802154_FCF_DST_ADDR_LONG: u32 = 12;
pub const IEEE802154_FCF_VERS_MASK: u32 = 48;
pub const IEEE802154_FCF_VERS_V0: u32 = 0;
pub const IEEE802154_FCF_VERS_V1: u32 = 16;
pub const IEEE802154_FCF_SRC_ADDR_MASK: u32 = 192;
pub const IEEE802154_FCF_SRC_ADDR_VOID: u32 = 0;
pub const IEEE802154_FCF_SRC_ADDR_RESV: u32 = 64;
pub const IEEE802154_FCF_SRC_ADDR_SHORT: u32 = 128;
pub const IEEE802154_FCF_SRC_ADDR_LONG: u32 = 192;
pub const IEEE802154_CHANNEL_MIN_SUBGHZ: u32 = 0;
pub const IEEE802154_CHANNEL_MAX_SUBGHZ: u32 = 10;
pub const IEEE802154_CHANNEL_MIN: u32 = 11;
pub const IEEE802154_CHANNEL_MAX: u32 = 26;
pub const IEEE802154_FRAME_LEN_MAX: u32 = 127;
pub const IEEE802154G_FRAME_LEN_MAX: u32 = 2047;
pub const IEEE802154_ACK_FRAME_LEN: u32 = 5;
pub const IEEE802154_LIFS_SYMS: u32 = 40;
pub const IEEE802154_SIFS_SYMS: u32 = 12;
pub const IEEE802154_SIFS_MAX_FRAME_SIZE: u32 = 18;
pub const IEEE802154_RADIO_RSSI_OFFSET: i32 = -174;
pub const IEEE802154_PHY_MR_FSK_PHR_LEN: u32 = 2;
pub const IEEE802154_PHY_MR_FSK_2FSK_SFD_LEN: u32 = 2;
pub const IEEE802154_PHY_MR_FSK_2FSK_CODED_SFD_0: u32 = 28494;
pub const IEEE802154_PHY_MR_FSK_2FSK_CODED_SFD_1: u32 = 25389;
pub const IEEE802154_PHY_MR_FSK_2FSK_UNCODED_SFD_0: u32 = 37092;
pub const IEEE802154_PHY_MR_FSK_2FSK_UNCODED_SFD_1: u32 = 31246;
pub const IEEE802154_ATURNAROUNDTIME_IN_SYMBOLS: u32 = 12;
pub const IEEE802154_CCA_DURATION_IN_SYMBOLS: u32 = 8;
pub const IEEE802154_ADDR_BCAST_LEN: u32 = 2;
pub const CONFIG_IEEE802154_DEFAULT_SUBGHZ_CHANNEL: u32 = 5;
pub const CONFIG_IEEE802154_DEFAULT_CHANNEL: u32 = 26;
pub const CONFIG_IEEE802154_DEFAULT_SUBGHZ_PAGE: u32 = 2;
pub const CONFIG_IEEE802154_DEFAULT_PANID: u32 = 35;
pub const CONFIG_IEEE802154_DEFAULT_TXPOWER: u32 = 0;
pub const CONFIG_IEEE802154_DEFAULT_CSMA_CA_MIN_BE: u32 = 3;
pub const CONFIG_IEEE802154_DEFAULT_CSMA_CA_RETRIES: u32 = 4;
pub const CONFIG_IEEE802154_DEFAULT_CSMA_CA_MAX_BE: u32 = 5;
pub const CONFIG_IEEE802154_CCA_THRESH_DEFAULT: i32 = -70;
pub const ETHERNET_ADDR_LEN: u32 = 6;
pub const ETH_ALEN: u32 = 6;
pub const CONFIG_GNRC_IPV6_NIB_6LBR: u32 = 0;
pub const CONFIG_GNRC_IPV6_NIB_6LR: u32 = 0;
pub const CONFIG_GNRC_IPV6_NIB_6LN: u32 = 0;
pub const CONFIG_GNRC_IPV6_NIB_ROUTER: u32 = 0;
pub const CONFIG_GNRC_IPV6_NIB_ADV_ROUTER: u32 = 0;
pub const CONFIG_GNRC_IPV6_NIB_ADD_RIO_IN_LAST_RA: u32 = 0;
pub const CONFIG_GNRC_IPV6_NIB_ARSM: u32 = 1;
pub const CONFIG_GNRC_IPV6_NIB_QUEUE_PKT: u32 = 1;
pub const CONFIG_GNRC_IPV6_NIB_SLAAC: u32 = 1;
pub const CONFIG_GNRC_IPV6_NIB_REDIRECT: u32 = 0;
pub const CONFIG_GNRC_IPV6_NIB_DC: u32 = 0;
pub const CONFIG_GNRC_IPV6_NIB_DNS: u32 = 0;
pub const CONFIG_GNRC_IPV6_NIB_MULTIHOP_P6C: u32 = 0;
pub const CONFIG_GNRC_IPV6_NIB_MULTIHOP_DAD: u32 = 0;
pub const CONFIG_GNRC_IPV6_NIB_REACH_TIME_RESET: u32 = 7200000;
pub const CONFIG_GNRC_IPV6_NIB_NO_RTR_SOL: u32 = 0;
pub const CONFIG_GNRC_IPV6_NIB_L2ADDR_MAX_LEN: u32 = 8;
pub const CONFIG_GNRC_IPV6_NIB_DEFAULT_ROUTER_NUMOF: u32 = 1;
pub const CONFIG_GNRC_IPV6_NIB_NUMOF: u32 = 4;
pub const CONFIG_GNRC_IPV6_NIB_OFFL_NUMOF: u32 = 8;
pub const GNRC_NETIF_PRIO: u32 = 2;
pub const CONFIG_GNRC_NETIF_MSG_QUEUE_SIZE_EXP: u32 = 4;
pub const CONFIG_GNRC_NETIF_PKTQ_POOL_SIZE: u32 = 16;
pub const CONFIG_GNRC_NETIF_PKTQ_TIMER_US: u32 = 5000;
pub const GNRC_NETIF_RPL_ADDR: u32 = 0;
pub const GNRC_NETIF_IPV6_RTR_ADDR: u32 = 0;
pub const CONFIG_GNRC_NETIF_IPV6_ADDRS_NUMOF: u32 = 2;
pub const GNRC_NETIF_IPV6_GROUPS_NUMOF: u32 = 3;
pub const GNRC_NETIF_L2ADDR_MAXLEN: u32 = 8;
pub const CONFIG_GNRC_NETIF_DEFAULT_HL: u32 = 64;
pub const CONFIG_GNRC_NETIF_MIN_WAIT_AFTER_SEND_US: u32 = 0;
pub const GNRC_NETIF_MSG_QUEUE_SIZE: u32 = 16;
pub const CONFIG_GNRC_NETIF_NONSTANDARD_6LO_MTU: u32 = 0;
pub const GNRC_NETIF_FLAGS_HAS_L2ADDR: u32 = 1;
pub const GNRC_NETIF_FLAGS_IPV6_FORWARDING: u32 = 2;
pub const GNRC_NETIF_FLAGS_IPV6_RTR_ADV: u32 = 4;
pub const GNRC_NETIF_FLAGS_IPV6_ADV_MTU: u32 = 8;
pub const GNRC_NETIF_FLAGS_IPV6_ADV_CUR_HL: u32 = 16;
pub const GNRC_NETIF_FLAGS_IPV6_ADV_REACH_TIME: u32 = 32;
pub const GNRC_NETIF_FLAGS_IPV6_ADV_RETRANS_TIMER: u32 = 64;
pub const GNRC_NETIF_FLAGS_IPV6_ADV_O_FLAG: u32 = 128;
pub const GNRC_NETIF_FLAGS_6LO_HC: u32 = 256;
pub const GNRC_NETIF_FLAGS_6LO_ABR: u32 = 512;
pub const GNRC_NETIF_FLAGS_6LO_MESH: u32 = 1024;
pub const GNRC_NETIF_FLAGS_6LO_BACKBONE: u32 = 2048;
pub const GNRC_NETIF_FLAGS_6LN: u32 = 4096;
pub const GNRC_NETIF_FLAGS_6LO: u32 = 8192;
pub const GNRC_NETIF_FLAGS_RAWMODE: u32 = 65536;
pub const NDP_RTR_ADV_FLAGS_MASK: u32 = 192;
pub const NDP_RTR_ADV_FLAGS_M: u32 = 128;
pub const NDP_RTR_ADV_FLAGS_O: u32 = 64;
pub const NDP_RTR_ADV_CUR_HL_UNSPEC: u32 = 0;
pub const NDP_RTR_ADV_LTIME_SEC_MAX: u32 = 9000;
pub const NDP_NBR_ADV_LTIME_NOT_DR: u32 = 0;
pub const NDP_NBR_ADV_REACH_TIME: u32 = 0;
pub const NDP_NBR_ADV_RETRANS_TIMER: u32 = 0;
pub const NDP_NBR_ADV_FLAGS_MASK: u32 = 224;
pub const NDP_NBR_ADV_FLAGS_R: u32 = 128;
pub const NDP_NBR_ADV_FLAGS_S: u32 = 64;
pub const NDP_NBR_ADV_FLAGS_O: u32 = 32;
pub const NDP_OPT_SL2A: u32 = 1;
pub const NDP_OPT_TL2A: u32 = 2;
pub const NDP_OPT_PI: u32 = 3;
pub const NDP_OPT_RH: u32 = 4;
pub const NDP_OPT_MTU: u32 = 5;
pub const NDP_OPT_RI: u32 = 24;
pub const NDP_OPT_RDNSS: u32 = 25;
pub const NDP_OPT_AR: u32 = 33;
pub const NDP_OPT_6CTX: u32 = 34;
pub const NDP_OPT_ABR: u32 = 35;
pub const NDP_OPT_PI_FLAGS_MASK: u32 = 192;
pub const NDP_OPT_PI_FLAGS_L: u32 = 128;
pub const NDP_OPT_PI_FLAGS_A: u32 = 64;
pub const NDP_OPT_RI_FLAGS_MASK: u32 = 24;
pub const NDP_OPT_RI_FLAGS_PRF_NONE: u32 = 16;
pub const NDP_OPT_RI_FLAGS_PRF_NEG: u32 = 24;
pub const NDP_OPT_RI_FLAGS_PRF_ZERO: u32 = 0;
pub const NDP_OPT_RI_FLAGS_PRF_POS: u32 = 8;
pub const NDP_OPT_PI_VALID_LTIME_INF: u32 = 4294967295;
pub const NDP_OPT_PI_PREF_LTIME_INF: u32 = 4294967295;
pub const NDP_OPT_PI_LEN: u32 = 4;
pub const NDP_OPT_MTU_LEN: u32 = 1;
pub const NDP_OPT_RDNSS_MIN_LEN: u32 = 3;
pub const NDP_MAX_INIT_RA_INTERVAL: u32 = 16000;
pub const NDP_MAX_INIT_RA_NUMOF: u32 = 3;
pub const NDP_MAX_FIN_RA_NUMOF: u32 = 3;
pub const NDP_MIN_MS_DELAY_BETWEEN_RAS: u32 = 3000;
pub const NDP_MAX_RA_DELAY: u32 = 500;
pub const NDP_MAX_RA_INTERVAL_MS: u32 = 600000;
pub const NDP_MIN_RA_INTERVAL_MS: u32 = 198000;
pub const NDP_RTR_LTIME_SEC: u32 = 1800;
pub const NDP_MAX_RS_MS_DELAY: u32 = 1000;
pub const NDP_RS_MS_INTERVAL: u32 = 4000;
pub const NDP_MAX_RS_NUMOF: u32 = 3;
pub const NDP_MAX_MC_SOL_NUMOF: u32 = 3;
pub const NDP_MAX_UC_SOL_NUMOF: u32 = 3;
pub const NDP_DAD_TRANSMIT_NUMOF: u32 = 1;
pub const NDP_MAX_ANYCAST_MS_DELAY: u32 = 1000;
pub const NDP_MAX_NA_NUMOF: u32 = 3;
pub const NDP_REACH_MS: u32 = 30000;
pub const NDP_RETRANS_TIMER_MS: u32 = 1000;
pub const NDP_MAX_RETRANS_TIMER_MS: u32 = 60000;
pub const NDP_MAX_NS_NUMOF: u32 = 17;
pub const NDP_DELAY_FIRST_PROBE_MS: u32 = 5000;
pub const NDP_MIN_RANDOM_FACTOR: u32 = 500;
pub const NDP_MAX_RANDOM_FACTOR: u32 = 1500;
pub const NDP_HOP_LIMIT: u32 = 255;
pub const L2UTIL_ADDR_MAX_LEN: u32 = 8;
pub const NETDEV_INDEX_ANY: u32 = 255;
pub const CONFIG_NETIF_NAMELENMAX: u32 = 8;
pub const GNRC_NETIF_PKTQ_DEQUEUE_MSG: u32 = 4659;
pub const NETDEV_MSG_TYPE_EVENT: u32 = 4660;
pub const GNRC_NETERR_MSG_TYPE: u32 = 518;
pub const GNRC_NETERR_SUCCESS: u32 = 0;
pub const CONFIG_GNRC_PKTBUF_SIZE: u32 = 6144;
pub const GNRC_NETIF_HDR_L2ADDR_MAX_LEN: u32 = 8;
pub const GNRC_NETIF_HDR_L2ADDR_PRINT_LEN: u32 = 24;
pub const GNRC_NETIF_HDR_NO_RSSI: i32 = -32768;
pub const GNRC_NETIF_HDR_NO_LQI: u32 = 0;
pub const GNRC_NETIF_HDR_FLAGS_BROADCAST: u32 = 128;
pub const GNRC_NETIF_HDR_FLAGS_MULTICAST: u32 = 64;
pub const GNRC_NETIF_HDR_FLAGS_MORE_DATA: u32 = 16;
pub const GNRC_NETIF_HDR_FLAGS_TIMESTAMP: u32 = 8;
pub const CONFIG_GNRC_SOCK_MBOX_SIZE_EXP: u32 = 3;
pub const GNRC_SOCK_MBOX_SIZE: u32 = 8;
pub const COAP_PORT: u32 = 5683;
pub const COAP_OPT_URI_HOST: u32 = 3;
pub const COAP_OPT_OBSERVE: u32 = 6;
pub const COAP_OPT_LOCATION_PATH: u32 = 8;
pub const COAP_OPT_URI_PATH: u32 = 11;
pub const COAP_OPT_CONTENT_FORMAT: u32 = 12;
pub const COAP_OPT_URI_QUERY: u32 = 15;
pub const COAP_OPT_ACCEPT: u32 = 17;
pub const COAP_OPT_LOCATION_QUERY: u32 = 20;
pub const COAP_OPT_BLOCK2: u32 = 23;
pub const COAP_OPT_BLOCK1: u32 = 27;
pub const COAP_OPT_PROXY_URI: u32 = 35;
pub const COAP_OPT_PROXY_SCHEME: u32 = 39;
pub const COAP_TYPE_CON: u32 = 0;
pub const COAP_TYPE_NON: u32 = 1;
pub const COAP_TYPE_ACK: u32 = 2;
pub const COAP_TYPE_RST: u32 = 3;
pub const COAP_CLASS_REQ: u32 = 0;
pub const COAP_METHOD_GET: u32 = 1;
pub const COAP_METHOD_POST: u32 = 2;
pub const COAP_METHOD_PUT: u32 = 3;
pub const COAP_METHOD_DELETE: u32 = 4;
pub const COAP_METHOD_FETCH: u32 = 5;
pub const COAP_METHOD_PATCH: u32 = 6;
pub const COAP_METHOD_IPATCH: u32 = 7;
pub const COAP_CODE_EMPTY: u32 = 0;
pub const COAP_CLASS_SUCCESS: u32 = 2;
pub const COAP_CODE_CREATED: u32 = 65;
pub const COAP_CODE_DELETED: u32 = 66;
pub const COAP_CODE_VALID: u32 = 67;
pub const COAP_CODE_CHANGED: u32 = 68;
pub const COAP_CODE_204: u32 = 68;
pub const COAP_CODE_CONTENT: u32 = 69;
pub const COAP_CODE_205: u32 = 69;
pub const COAP_CODE_CONTINUE: u32 = 95;
pub const COAP_CODE_231: u32 = 95;
pub const COAP_CLASS_CLIENT_FAILURE: u32 = 4;
pub const COAP_CODE_BAD_REQUEST: u32 = 128;
pub const COAP_CODE_UNAUTHORIZED: u32 = 129;
pub const COAP_CODE_BAD_OPTION: u32 = 130;
pub const COAP_CODE_FORBIDDEN: u32 = 131;
pub const COAP_CODE_PATH_NOT_FOUND: u32 = 132;
pub const COAP_CODE_404: u32 = 132;
pub const COAP_CODE_METHOD_NOT_ALLOWED: u32 = 133;
pub const COAP_CODE_NOT_ACCEPTABLE: u32 = 134;
pub const COAP_CODE_REQUEST_ENTITY_INCOMPLETE: u32 = 136;
pub const COAP_CODE_CONFLICT: u32 = 137;
pub const COAP_CODE_PRECONDITION_FAILED: u32 = 140;
pub const COAP_CODE_REQUEST_ENTITY_TOO_LARGE: u32 = 141;
pub const COAP_CODE_UNSUPPORTED_CONTENT_FORMAT: u32 = 143;
pub const COAP_CODE_UNPROCESSABLE_ENTITY: u32 = 150;
pub const COAP_CLASS_SERVER_FAILURE: u32 = 5;
pub const COAP_CODE_INTERNAL_SERVER_ERROR: u32 = 160;
pub const COAP_CODE_NOT_IMPLEMENTED: u32 = 161;
pub const COAP_CODE_BAD_GATEWAY: u32 = 162;
pub const COAP_CODE_SERVICE_UNAVAILABLE: u32 = 163;
pub const COAP_CODE_GATEWAY_TIMEOUT: u32 = 164;
pub const COAP_CODE_PROXYING_NOT_SUPPORTED: u32 = 165;
pub const COAP_FORMAT_TEXT: u32 = 0;
pub const COAP_FORMAT_LINK: u32 = 40;
pub const COAP_FORMAT_XML: u32 = 41;
pub const COAP_FORMAT_OCTET: u32 = 42;
pub const COAP_FORMAT_EXI: u32 = 47;
pub const COAP_FORMAT_JSON: u32 = 50;
pub const COAP_FORMAT_JSON_PATCH_JSON: u32 = 51;
pub const COAP_FORMAT_MERGE_PATCH_JSON: u32 = 52;
pub const COAP_FORMAT_CBOR: u32 = 60;
pub const COAP_FORMAT_SENML_JSON: u32 = 110;
pub const COAP_FORMAT_SENSML_JSON: u32 = 111;
pub const COAP_FORMAT_SENML_CBOR: u32 = 112;
pub const COAP_FORMAT_SENSML_CBOR: u32 = 113;
pub const COAP_FORMAT_SENML_EXI: u32 = 114;
pub const COAP_FORMAT_SENSML_EXI: u32 = 115;
pub const COAP_FORMAT_SENML_XML: u32 = 310;
pub const COAP_FORMAT_SENSML_XML: u32 = 311;
pub const COAP_FORMAT_WOT_TD: u32 = 432;
pub const COAP_OBS_REGISTER: u32 = 0;
pub const COAP_OBS_DEREGISTER: u32 = 1;
pub const COAP_TOKEN_LENGTH_MAX: u32 = 8;
pub const CONFIG_COAP_ACK_TIMEOUT_MS: u32 = 2000;
pub const CONFIG_COAP_RANDOM_FACTOR_1000: u32 = 1500;
pub const CONFIG_COAP_MAX_RETRANSMIT: u32 = 4;
pub const COAP_NSTART: u32 = 1;
pub const COAP_DEFAULT_LEISURE: u32 = 5;
pub const COAP_BLOCKWISE_NUM_OFF: u32 = 4;
pub const COAP_BLOCKWISE_MORE_OFF: u32 = 3;
pub const COAP_BLOCKWISE_SZX_MASK: u32 = 7;
pub const COAP_BLOCKWISE_SZX_MAX: u32 = 7;
pub const __alignas_is_defined: u32 = 1;
pub const __alignof_is_defined: u32 = 1;
pub const ARCHITECTURE_WORD_BITS: u32 = 32;
pub const ARCHITECTURE_WORD_BYTES: u32 = 4;
pub const UWORD_MIN: u32 = 0;
pub const UWORD_MAX: u32 = 4294967295;
pub const SWORD_MIN: i32 = -2147483648;
pub const SWORD_MAX: u32 = 2147483647;
pub const SOCKET_POOL_SIZE: u32 = 4;
pub const SOCKET_TCP_QUEUE_SIZE: u32 = 0;
pub const SOCKADDR_MAX_DATA_LEN: u32 = 26;
pub const SOCK_DGRAM: u32 = 1;
pub const SOCK_RAW: u32 = 2;
pub const SOCK_SEQPACKET: u32 = 3;
pub const SOCK_STREAM: u32 = 4;
pub const SOL_SOCKET: i32 = -1;
pub const SO_ACCEPTCONN: u32 = 0;
pub const SO_BROADCAST: u32 = 1;
pub const SO_DEBUG: u32 = 2;
pub const SO_DONTROUTE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 5;
pub const SO_LINGER: u32 = 6;
pub const SO_OOBINLINE: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_RCVLOWAT: u32 = 9;
pub const SO_RCVTIMEO: u32 = 10;
pub const SO_REUSEADDR: u32 = 11;
pub const SO_SNDBUF: u32 = 12;
pub const SO_SNDLOWAT: u32 = 13;
pub const SO_SNDTIMEO: u32 = 14;
pub const SO_TYPE: u32 = 15;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const IPPROTO_IP: u32 = 4;
pub const IPPROTO_IPV6: u32 = 41;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_RAW: u32 = 255;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_UDP: u32 = 17;
pub const INADDRSZ: u32 = 4;
pub const IN6ADDRSZ: u32 = 16;
pub const COAP_GET: u32 = 1;
pub const COAP_POST: u32 = 2;
pub const COAP_PUT: u32 = 4;
pub const COAP_DELETE: u32 = 8;
pub const COAP_FETCH: u32 = 16;
pub const COAP_PATCH: u32 = 32;
pub const COAP_IPATCH: u32 = 64;
pub const COAP_IGNORE: u32 = 255;
pub const COAP_MATCH_SUBTREE: u32 = 32768;
pub const COAP_FORMAT_NONE: u32 = 65535;
pub const CONFIG_NANOCOAP_NOPTS_MAX: u32 = 16;
pub const CONFIG_NANOCOAP_URI_MAX: u32 = 64;
pub const CONFIG_NANOCOAP_BLOCK_SIZE_EXP_MAX: u32 = 6;
pub const CONFIG_NANOCOAP_QS_MAX: u32 = 64;
pub const CONFIG_NANOCOAP_BLOCK_HEADER_MAX: u32 = 64;
pub const COAP_OPT_FINISH_NONE: u32 = 0;
pub const COAP_OPT_FINISH_PAYLOAD: u32 = 1;
pub const US_PER_SEC: u32 = 1000000;
pub const SEC_PER_MIN: u32 = 60;
pub const CS_PER_SEC: u32 = 100;
pub const MS_PER_SEC: u32 = 1000;
pub const US_PER_MS: u32 = 1000;
pub const US_PER_CS: u32 = 10000;
pub const MS_PER_CS: u32 = 10;
pub const NS_PER_US: u32 = 1000;
pub const NS_PER_SEC: u32 = 1000000000;
pub const TIMEX_MAX_STR_LEN: u32 = 20;
pub const CONFIG_GCOAP_PORT: u32 = 5683;
pub const CONFIG_GCOAPS_PORT: u32 = 5684;
pub const CONFIG_GCOAP_DTLS_HANDSHAKE_TIMEOUT_MSEC: u32 = 3000;
pub const CONFIG_GCOAP_DTLS_MINIMUM_AVAILABLE_SESSIONS: u32 = 1;
pub const CONFIG_GCOAP_DTLS_MINIMUM_AVAILABLE_SESSIONS_TIMEOUT_MSEC: u32 = 15000;
pub const CONFIG_GCOAP_PDU_BUF_SIZE: u32 = 128;
pub const CONFIG_GCOAP_REQ_WAITING_MAX: u32 = 2;
pub const GCOAP_TOKENLEN_MAX: u32 = 8;
pub const CONFIG_GCOAP_TOKENLEN: u32 = 2;
pub const GCOAP_PAYLOAD_MARKER: u32 = 255;
pub const CONFIG_GCOAP_NO_AUTO_INIT: u32 = 0;
pub const GCOAP_MEMO_UNUSED: u32 = 0;
pub const GCOAP_MEMO_RETRANSMIT: u32 = 1;
pub const GCOAP_MEMO_WAIT: u32 = 2;
pub const GCOAP_MEMO_RESP: u32 = 3;
pub const GCOAP_MEMO_TIMEOUT: u32 = 4;
pub const GCOAP_MEMO_ERR: u32 = 5;
pub const GCOAP_MEMO_RESP_TRUNC: u32 = 6;
pub const GCOAP_SEND_LIMIT_NON: i32 = -1;
pub const CONFIG_GCOAP_NON_TIMEOUT_MSEC: u32 = 5000;
pub const CONFIG_GCOAP_OBS_CLIENTS_MAX: u32 = 2;
pub const CONFIG_GCOAP_OBS_REGISTRATIONS_MAX: u32 = 2;
pub const GCOAP_OBS_MEMO_UNUSED: u32 = 0;
pub const GCOAP_OBS_MEMO_IDLE: u32 = 1;
pub const GCOAP_OBS_MEMO_PENDING: u32 = 2;
pub const CONFIG_GCOAP_OBS_VALUE_WIDTH: u32 = 3;
pub const GCOAP_OBS_TICK_EXPONENT: u32 = 5;
pub const GCOAP_OBS_INIT_OK: u32 = 0;
pub const GCOAP_OBS_INIT_ERR: i32 = -1;
pub const GCOAP_OBS_INIT_UNUSED: i32 = -2;
pub const GCOAP_DTLS_EXTRA_STACKSIZE: u32 = 0;
pub const CONFIG_GCOAP_RESEND_BUFS_MAX: u32 = 1;
pub const COAP_LINK_FLAG_INIT_RESLIST: u32 = 1;
pub const GCOAP_RESOURCE_FOUND: u32 = 0;
pub const GCOAP_RESOURCE_WRONG_METHOD: u32 = 1;
pub const GCOAP_RESOURCE_NO_PATH: u32 = 2;
pub const GCOAP_RESOURCE_ERROR: u32 = 3;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
	pub __val: [::core::ffi::c_int; 2usize],
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_ulong;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " @brief   The elements of the JSON-LD `@context`, represented as a linked"]
#[doc = " list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct json_ld_context {
	#[doc = "< The next item in the linked list"]
	pub next: *mut json_ld_context,
	#[doc = "< The key of the `@context` item"]
	pub key: *const ::core::ffi::c_char,
	#[doc = "< The value of the `@context` item"]
	pub value: *const ::core::ffi::c_char,
}
#[doc = " @brief   The elements of the JSON-LD `@context`, represented as a linked"]
#[doc = " list."]
pub type json_ld_context_t = json_ld_context;
#[doc = " @brief   The elements a JSON-LD `@type` array, represented as a linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_type {
	#[doc = "< The next item in the linked list"]
	pub next: *mut wot_td_type,
	#[doc = "< The value of the `@type` item"]
	pub value: *const ::core::ffi::c_char,
}
#[doc = " @brief   The elements a JSON-LD `@type` array, represented as a linked list."]
pub type wot_td_type_t = wot_td_type;
#[doc = "< Represents the security scheme `nosec`."]
pub const wot_td_sec_scheme_type_t_SECURITY_SCHEME_NONE: wot_td_sec_scheme_type_t = 0;
#[doc = "< Represents the security scheme `basic`."]
pub const wot_td_sec_scheme_type_t_SECURITY_SCHEME_BASIC: wot_td_sec_scheme_type_t = 1;
#[doc = "< Represents the security scheme `digest`."]
pub const wot_td_sec_scheme_type_t_SECURITY_SCHEME_DIGEST: wot_td_sec_scheme_type_t = 2;
#[doc = "< Represents the security scheme `apikey`."]
pub const wot_td_sec_scheme_type_t_SECURITY_SCHEME_API_KEY: wot_td_sec_scheme_type_t = 3;
#[doc = "< Represents the security scheme `bearer`."]
pub const wot_td_sec_scheme_type_t_SECURITY_SCHEME_BEARER: wot_td_sec_scheme_type_t = 4;
#[doc = "< Represents the security scheme `psk`."]
pub const wot_td_sec_scheme_type_t_SECURITY_SCHEME_PSK: wot_td_sec_scheme_type_t = 5;
#[doc = "< Represents the security scheme `oauth2`."]
pub const wot_td_sec_scheme_type_t_SECURITY_SCHEME_OAUTH2: wot_td_sec_scheme_type_t = 6;
#[doc = " @brief   The available security schemes for a Thing Description."]
#[doc = " @see"]
#[doc = " https://www.w3.org/TR/wot-thing-description/#td-vocab-scheme--SecurityScheme"]
pub type wot_td_sec_scheme_type_t = ::core::ffi::c_uint;
#[doc = "< The default value. TODO: Is this value"]
#[doc = "needed?"]
pub const wot_td_sec_scheme_in_t_SECURITY_SCHEME_IN_DEFAULT: wot_td_sec_scheme_in_t = 0;
#[doc = "< Represents the value `header`."]
pub const wot_td_sec_scheme_in_t_SECURITY_SCHEME_IN_HEADER: wot_td_sec_scheme_in_t = 1;
#[doc = "< Represents the value `query`."]
pub const wot_td_sec_scheme_in_t_SECURITY_SCHEME_IN_QUERY: wot_td_sec_scheme_in_t = 2;
#[doc = "< Represents the value `body`."]
pub const wot_td_sec_scheme_in_t_SECURITY_SCHEME_IN_BODY: wot_td_sec_scheme_in_t = 3;
#[doc = "< Represents the value `cookie`."]
pub const wot_td_sec_scheme_in_t_SECURITY_SCHEME_IN_COOKIE: wot_td_sec_scheme_in_t = 4;
#[doc = " @brief   Possible values for the security scheme field \"in\"."]
pub type wot_td_sec_scheme_in_t = ::core::ffi::c_uint;
#[doc = " @brief   Specifies Basic Authentication, using an unencrypted username and"]
#[doc = " password."]
#[doc = ""]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#basicsecurityscheme"]
#[doc = " @see     [RFC 7617](https://datatracker.ietf.org/doc/html/rfc7617)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_basic_sec_scheme_t {
	#[doc = "< Specifies the location of security"]
	#[doc = "authentication information."]
	pub in_: wot_td_sec_scheme_in_t,
	#[doc = "< Name for query, header, or cookie parameters."]
	pub name: *const ::core::ffi::c_char,
}
#[doc = "< Represents the value `auth`."]
pub const wot_td_digest_qop_t_SECURITY_DIGEST_QOP_AUTH: wot_td_digest_qop_t = 0;
#[doc = "< Represents the value `auth-int`."]
pub const wot_td_digest_qop_t_SECURITY_DIGEST_QOP_AUTH_INT: wot_td_digest_qop_t = 1;
#[doc = " @brief   Possible values for the Quality of Protection (QoP) parameter."]
#[doc = " @see"]
#[doc = " https://www.w3.org/TR/wot-thing-description/#td-vocab-qop--DigestSecurityScheme"]
pub type wot_td_digest_qop_t = ::core::ffi::c_uint;
#[doc = " @brief   Specifies the use of a Digest Access Authentication security scheme."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#digestsecurityscheme"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_digest_sec_scheme_t {
	#[doc = "< Quality of protection."]
	pub qop: wot_td_digest_qop_t,
	#[doc = "< Specifies the location of security"]
	#[doc = "authentication information."]
	pub in_: wot_td_sec_scheme_in_t,
	#[doc = "< Name for query, header, or cookie parameters."]
	pub name: *const ::core::ffi::c_char,
}
#[doc = " @brief   Specifies the use of an API key authentication security"]
#[doc = " configuration."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#apikeysecurityscheme"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_api_key_sec_scheme_t {
	#[doc = "< Specifies the location of security"]
	#[doc = "authentication information."]
	pub in_: wot_td_sec_scheme_in_t,
	#[doc = "< Name for query, header, or cookie parameters."]
	pub name: *const ::core::ffi::c_char,
}
#[doc = " @brief   Represents a URI. TODO: Should be reworked."]
#[doc = " @see     https://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#anyURI"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_uri_t {
	#[doc = "< The URI schema."]
	pub schema: *const ::core::ffi::c_char,
	#[doc = "< The rest of the URI."]
	pub value: *const ::core::ffi::c_char,
}
#[doc = " @brief   Specifies a Bearer Token security configuration."]
#[doc = ""]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#bearersecurityscheme"]
#[doc = " @see     [RFC6750](https://datatracker.ietf.org/doc/html/rfc6750)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_bearer_sec_scheme_t {
	#[doc = "< URI of the authorization server."]
	pub authorization: *mut wot_td_uri_t,
	#[doc = "< Encoding, encryption, or digest algorithm."]
	pub alg: *const ::core::ffi::c_char,
	#[doc = "< Specifies format of security authentication information."]
	pub format: *const ::core::ffi::c_char,
	#[doc = "< Specifies the location of security"]
	#[doc = "authentication information."]
	pub in_: wot_td_sec_scheme_in_t,
	#[doc = "< Name for query, header, or cookie parameters."]
	pub name: *const ::core::ffi::c_char,
}
#[doc = " @brief   Specifies a pre-shared key authentication security configuration."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#psksecurityscheme"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_psk_sec_scheme_t {
	#[doc = "< Identifier providing information which can be used"]
	#[doc = "for selection or confirmation."]
	pub identity: *const ::core::ffi::c_char,
}
#[doc = " @brief   Authorization scope identifiers, modelled as a linked list."]
#[doc = " @see"]
#[doc = " https://www.w3.org/TR/wot-thing-description/#td-vocab-scopes--OAuth2SecurityScheme"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_auth_scope {
	#[doc = "< The next element in the linked list."]
	pub next: *mut wot_td_auth_scope,
	#[doc = "< The authorization scope identifier"]
	pub value: *const ::core::ffi::c_char,
}
#[doc = " @brief   Authorization scope identifiers, modelled as a linked list."]
#[doc = " @see"]
#[doc = " https://www.w3.org/TR/wot-thing-description/#td-vocab-scopes--OAuth2SecurityScheme"]
pub type wot_td_auth_scopes_t = wot_td_auth_scope;
#[doc = " @brief   Specifies an OAuth2 authentication security configuration."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#oauth2securityscheme"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_oauth2_sec_scheme_t {
	#[doc = "< URI of the authorization server."]
	pub authorization: *mut wot_td_uri_t,
	#[doc = "< URI of the token server."]
	pub token: *mut wot_td_uri_t,
	#[doc = "< URI of the refresh server."]
	pub refresh: *mut wot_td_uri_t,
	#[doc = "< Set of authorization scope identifiers."]
	pub scopes: *mut wot_td_auth_scopes_t,
	#[doc = "< Authorization flow."]
	pub flow: *const ::core::ffi::c_char,
}
#[doc = " @brief   Multi-language definitions, modelled as a linked list."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#multilanguage"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_multi_language {
	#[doc = "< The next element in the linked list."]
	pub next: *mut wot_td_multi_language,
	#[doc = "< The language tag (e. g. `en`) identifying the"]
	#[doc = "language."]
	pub tag: *const ::core::ffi::c_char,
	#[doc = "< The actual content for the respective language."]
	pub value: *const ::core::ffi::c_char,
}
#[doc = " @brief   Multi-language definitions, modelled as a linked list."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#multilanguage"]
pub type wot_td_multi_lang_t = wot_td_multi_language;
#[doc = " @brief   Common `SecurityScheme` definitions."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#securityscheme"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_sec_scheme_t {
	#[doc = "< JSON-LD `@type` for labelling the object with"]
	#[doc = "semantic tags (or types)."]
	pub type_: *mut wot_td_type_t,
	#[doc = "< Can be used to support (human-readable) information"]
	#[doc = "in different languages."]
	pub descriptions: *mut wot_td_multi_lang_t,
	#[doc = "< URI of the proxy server this security configuration"]
	#[doc = "provides access to. If not given, the corresponding"]
	#[doc = "security configuration is for the endpoint."]
	pub proxy: *mut wot_td_uri_t,
	#[doc = "< Identification of the security"]
	#[doc = "mechanism being configured."]
	pub scheme_type: wot_td_sec_scheme_type_t,
	#[doc = "< Scheme specific definitions."]
	pub scheme: *mut ::core::ffi::c_void,
}
#[doc = " @brief   Map of security definitions, modelled as a linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_sec_def {
	#[doc = "< The next element in the linked list."]
	pub next: *mut wot_td_sec_def,
	#[doc = "< Key for identifying the security scheme."]
	pub key: *const ::core::ffi::c_char,
	#[doc = "< The actual security definition object."]
	pub value: *mut wot_td_sec_scheme_t,
}
#[doc = " @brief   Map of security definitions, modelled as a linked list."]
pub type wot_td_security_definition_t = wot_td_sec_def;
#[doc = " @brief   Array of references to security definitions, modelled as a linked"]
#[doc = " list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_sec {
	#[doc = "< The next element in the linked list."]
	pub next: *mut wot_td_sec,
	#[doc = "< The corresponding security definition."]
	pub definition: *mut wot_td_security_definition_t,
}
#[doc = " @brief   Array of references to security definitions, modelled as a linked"]
#[doc = " list."]
pub type wot_td_security_t = wot_td_sec;
#[doc = "< Represents the `readproperty` operation."]
pub const wot_td_form_op_type_t_FORM_OP_READ_PROPERTY: wot_td_form_op_type_t = 0;
#[doc = "< Represents the `writeproperty` operation."]
pub const wot_td_form_op_type_t_FORM_OP_WRITE_PROPERTY: wot_td_form_op_type_t = 1;
#[doc = "< Represents the `observeproperty` operation."]
pub const wot_td_form_op_type_t_FORM_OP_OBSERVE_PROPERTY: wot_td_form_op_type_t = 2;
#[doc = "< Represents the `unobserveproperty` operation."]
pub const wot_td_form_op_type_t_FORM_OP_UNOBSERVE_PROPERTY: wot_td_form_op_type_t = 3;
#[doc = "< Represents the `invokeaction` operation."]
pub const wot_td_form_op_type_t_FORM_OP_INVOKE_ACTION: wot_td_form_op_type_t = 4;
#[doc = "< Represents the `subscribeevent` operation."]
pub const wot_td_form_op_type_t_FORM_OP_SUBSCRIBE_EVENT: wot_td_form_op_type_t = 5;
#[doc = "< Represents the `unsubscribeevent` operation."]
pub const wot_td_form_op_type_t_FORM_OP_UNSUBSCRIBE_EVENT: wot_td_form_op_type_t = 6;
#[doc = "< Represents the `readallproperties`"]
#[doc = "operation."]
pub const wot_td_form_op_type_t_FORM_OP_READ_ALL_PROPERTIES: wot_td_form_op_type_t = 7;
#[doc = "< Represents the `writeallproperties`"]
#[doc = "operation."]
pub const wot_td_form_op_type_t_FORM_OP_WRITE_ALL_PROPERTIES: wot_td_form_op_type_t = 8;
#[doc = "< Represents the `readmultipleproperties`"]
#[doc = "operation."]
pub const wot_td_form_op_type_t_FORM_OP_READ_MULTIPLE_PROPERTIES: wot_td_form_op_type_t = 9;
#[doc = "< Represents the"]
#[doc = "`writemultipleproperties` operation."]
pub const wot_td_form_op_type_t_FORM_OP_WRITE_MULTIPLE_PROPERTIES: wot_td_form_op_type_t = 10;
#[doc = " @brief   Enum representing the different operation types that can be used in"]
#[doc = " forms."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#td-vocab-op--Form"]
pub type wot_td_form_op_type_t = ::core::ffi::c_uint;
#[doc = " @brief   Array of operation type definitions, modelled as a linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_form_op {
	#[doc = "< The next element in the linked list."]
	pub next: *mut wot_td_form_op,
	#[doc = "< The operation type of the current element."]
	pub value: wot_td_form_op_type_t,
}
#[doc = " @brief   Array of operation type definitions, modelled as a linked list."]
pub type wot_td_form_op_t = wot_td_form_op;
#[doc = "< No media type given."]
pub const wot_td_media_type_t_MEDIA_TYPE_NONE: wot_td_media_type_t = 0;
#[doc = "< Represents the media-type `application/json`."]
pub const wot_td_media_type_t_MEDIA_TYPE_JSON: wot_td_media_type_t = 1;
#[doc = "< Represents the media-type `text/plain`."]
pub const wot_td_media_type_t_MEDIA_TYPE_TEXT_PLAIN: wot_td_media_type_t = 2;
#[doc = "< Represents the media-type `application/ld+json`."]
pub const wot_td_media_type_t_MEDIA_TYPE_JSON_LD: wot_td_media_type_t = 3;
#[doc = "< Represents the media-type `text/csv`."]
pub const wot_td_media_type_t_MEDIA_TYPE_CSV: wot_td_media_type_t = 4;
#[doc = " @brief   Enum encoding a number of different media types."]
#[doc = " @see     [RFC 2046](https://datatracker.ietf.org/doc/html/rfc2046)"]
pub type wot_td_media_type_t = ::core::ffi::c_uint;
#[doc = " @brief   Media type parameters, modelled as a linked list of key-value-pairs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_media_type_parameter {
	#[doc = "< The next element in the linked list."]
	pub next: *mut wot_td_media_type_parameter,
	#[doc = "< The key used for the media type parameter."]
	pub key: *const ::core::ffi::c_char,
	#[doc = "< The actual value of the media type"]
	#[doc = "parameter."]
	pub value: *const ::core::ffi::c_char,
}
#[doc = " @brief   Media type parameters, modelled as a linked list of key-value-pairs."]
pub type wot_td_media_type_parameter_t = wot_td_media_type_parameter;
#[doc = " @brief   Content type, based on a media type (e. g. `text/plain`) and"]
#[doc = " potential parameters (e. g. `charset=utf-8`) for the media type."]
#[doc = " @see     [RFC 2046](https://datatracker.ietf.org/doc/html/rfc2046)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_content_type_t {
	#[doc = "< The content type's media type."]
	pub media_type: wot_td_media_type_t,
	#[doc = "< Parameters for the media type."]
	pub media_type_parameter: *mut wot_td_media_type_parameter_t,
}
#[doc = "< No content encoding given."]
pub const wot_td_content_encoding_type_t_CONTENT_ENCODING_NONE: wot_td_content_encoding_type_t = 0;
#[doc = "< Represents the content encoding `gzip`."]
pub const wot_td_content_encoding_type_t_CONTENT_ENCODING_GZIP: wot_td_content_encoding_type_t = 1;
#[doc = "< Represents the content encoding `compress`."]
pub const wot_td_content_encoding_type_t_CONTENT_ENCODING_COMPRESS: wot_td_content_encoding_type_t =
	2;
#[doc = "< Represents the content encoding `deflate`."]
pub const wot_td_content_encoding_type_t_CONTENT_ENCODING_DEFLATE: wot_td_content_encoding_type_t =
	3;
#[doc = "< Represents the content encoding `identity`."]
pub const wot_td_content_encoding_type_t_CONTENT_ENCODING_IDENTITY: wot_td_content_encoding_type_t =
	4;
#[doc = "< Represents the content encoding `br`."]
pub const wot_td_content_encoding_type_t_CONTENT_ENCODING_BROTLI: wot_td_content_encoding_type_t =
	5;
#[doc = "  @brief  Possible values for the `contentCoding` field in @ref wot_td_form_t."]
#[doc = "  @see"]
#[doc = " https://www.w3.org/TR/wot-thing-description/#td-vocab-contentCoding--Form"]
pub type wot_td_content_encoding_type_t = ::core::ffi::c_uint;
#[doc = " @brief   Communication metadata describing the expected response message."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#expectedresponse"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_expected_res_t {
	#[doc = "< The content type of the expected response."]
	pub content_type: *mut wot_td_content_type_t,
}
#[doc = " @brief   Receiver used for @ref wot_td_extension_t."]
pub type wot_td_serialize_receiver_t =
	::core::option::Option<unsafe extern "C" fn(c: *const ::core::ffi::c_char)>;
#[doc = " @brief   Custom parser for @ref wot_td_extension_t."]
pub type wot_td_ser_parser_t = ::core::option::Option<
	unsafe extern "C" fn(
		receiver: wot_td_serialize_receiver_t,
		name: *const ::core::ffi::c_char,
		data: *const ::core::ffi::c_void,
	),
>;
#[doc = " @brief   Defines possible extensions for WoT objects, modelled as a linked"]
#[doc = " list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_extension {
	#[doc = "< The next extension element in the linked list."]
	pub next: *mut wot_td_extension,
	#[doc = "< Name of the extension element."]
	pub name: *const ::core::ffi::c_char,
	#[doc = "< Data contained in the extension element."]
	pub data: *const ::core::ffi::c_void,
	#[doc = "< Parser used for serializing the extension."]
	pub parser: wot_td_ser_parser_t,
}
#[doc = " @brief   Defines possible extensions for WoT objects, modelled as a linked"]
#[doc = " list."]
pub type wot_td_extension_t = wot_td_extension;
#[doc = " @brief   Representation of a `Form` object."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#form"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_form {
	#[doc = "< The next element in the linked list"]
	pub next: *mut wot_td_form,
	#[doc = "< The operation types in the form"]
	pub op: *mut wot_td_form_op_t,
	#[doc = "< href field pointing to the resource"]
	pub href: *mut wot_td_uri_t,
	#[doc = "< The associated content type"]
	pub content_type: *mut wot_td_content_type_t,
	#[doc = "< The encoding of the resource"]
	pub content_encoding: wot_td_content_encoding_type_t,
	#[doc = "< The sub protocol used (e. g."]
	#[doc = "cov:observe)."]
	pub sub_protocol: *const ::core::ffi::c_char,
	#[doc = "< Associated security definitions."]
	pub security: *mut wot_td_security_t,
	#[doc = "< Set of authorization scope identifiers"]
	#[doc = "used for OAuth2."]
	pub scopes: *mut wot_td_auth_scopes_t,
	#[doc = "< Specification of metadata that"]
	#[doc = "differs from the request."]
	pub expected_response: *mut wot_td_expected_res_t,
	#[doc = "< Potential extensions of the form."]
	pub extensions: *mut wot_td_extension_t,
}
#[doc = " @brief   Representation of a `Form` object."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#form"]
pub type wot_td_form_t = wot_td_form;
#[doc = " @brief   Metadata describing data of type `number`."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#numberschema"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_number_schema_t {
	#[doc = "< Specifies an inclusive lower limit."]
	pub minimum: *const f64,
	#[doc = "< Specifies an inclusive upper limit."]
	pub maximum: *const f64,
}
#[doc = " @brief   Metadata describing data of type `integer`."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#integerschema"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_integer_schema_t {
	#[doc = "< Specifies an inclusive lower limit."]
	pub minimum: *const i32,
	#[doc = "< Specifies an inclusive upper limit."]
	pub maximum: *const i32,
}
#[doc = " @brief   Defines which members of the object type are mandatory, modelled as"]
#[doc = " linked list."]
#[doc = " @see"]
#[doc = " https://www.w3.org/TR/wot-thing-description/#td-vocab-required--ObjectSchema"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_object_required {
	#[doc = "< The next element in the linked list."]
	pub next: *mut wot_td_object_required,
	#[doc = "< The object key the current element refers to."]
	pub value: *const ::core::ffi::c_char,
}
#[doc = " @brief   Defines which members of the object type are mandatory, modelled as"]
#[doc = " linked list."]
#[doc = " @see"]
#[doc = " https://www.w3.org/TR/wot-thing-description/#td-vocab-required--ObjectSchema"]
pub type wot_td_object_required_t = wot_td_object_required;
#[doc = " @brief   A restricted set of values provided as an array, modelled as a"]
#[doc = " linked list."]
#[doc = " @see https://www.w3.org/TR/wot-thing-description/#td-vocab-enum--DataSchema"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_data_enum {
	#[doc = "< The next element in the linked list."]
	pub next: *mut wot_td_data_enum,
	#[doc = "< The< value of the current element in the linked list."]
	pub value: *const ::core::ffi::c_char,
}
#[doc = " @brief   A restricted set of values provided as an array, modelled as a"]
#[doc = " linked list."]
#[doc = " @see https://www.w3.org/TR/wot-thing-description/#td-vocab-enum--DataSchema"]
pub type wot_td_data_enums_t = wot_td_data_enum;
#[doc = "< Missing JSON Schema type."]
pub const wot_td_json_type_t_JSON_TYPE_NONE: wot_td_json_type_t = 0;
#[doc = "< JSON Schema type `object`."]
pub const wot_td_json_type_t_JSON_TYPE_OBJECT: wot_td_json_type_t = 1;
#[doc = "< JSON Schema type `array`."]
pub const wot_td_json_type_t_JSON_TYPE_ARRAY: wot_td_json_type_t = 2;
#[doc = "< JSON Schema type `string`."]
pub const wot_td_json_type_t_JSON_TYPE_STRING: wot_td_json_type_t = 3;
#[doc = "< JSON Schema type `number`."]
pub const wot_td_json_type_t_JSON_TYPE_NUMBER: wot_td_json_type_t = 4;
#[doc = "< JSON Schema type `integer`."]
pub const wot_td_json_type_t_JSON_TYPE_INTEGER: wot_td_json_type_t = 5;
#[doc = "< JSON Schema type `boolean`."]
pub const wot_td_json_type_t_JSON_TYPE_BOOLEAN: wot_td_json_type_t = 6;
#[doc = "< JSON Schema type `null`."]
pub const wot_td_json_type_t_JSON_TYPE_NULL: wot_td_json_type_t = 7;
#[doc = " @brief   Possible data types of a data schema, derived from JSON Schema."]
#[doc = " @see https://www.w3.org/TR/wot-thing-description/#td-vocab-type--DataSchema"]
pub type wot_td_json_type_t = ::core::ffi::c_uint;
#[doc = " @brief   Metadata that describes the data format used. It can be used for"]
#[doc = " validation."]
#[doc = " @see     https://w3c.github.io/wot-thing-description/#dataschema"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_data_schema_t {
	#[doc = "< `@type`, as defined by JSON-LD."]
	pub type_: *mut wot_td_type_t,
	#[doc = "< Provides multi-language human-readable titles."]
	pub titles: *mut wot_td_multi_lang_t,
	#[doc = "< Can be used to support (human-readable) information in"]
	#[doc = "different languages."]
	pub descriptions: *mut wot_td_multi_lang_t,
	#[doc = "< The JSON Schema type of this data schema instance."]
	pub json_type: wot_td_json_type_t,
	#[doc = "< Specifies a constant value."]
	pub constant: *const ::core::ffi::c_char,
	#[doc = "< Provides unit information."]
	pub unit: *const ::core::ffi::c_char,
	#[doc = "< Specifies a number of data schemas to"]
	#[doc = "validate against."]
	pub one_of: *mut wot_td_data_schemas,
	#[doc = "< Restricted set of values."]
	pub enumeration: *mut wot_td_data_enums_t,
	#[doc = "< Labels a property as read-only (if true)."]
	pub read_only: bool,
	#[doc = "< Labels a property as write-only (if true)."]
	pub write_only: bool,
	#[doc = "< Allows validation based on a format pattern such as"]
	#[doc = "\"date-time\", \"email\", \"uri\", etc."]
	pub format: *const ::core::ffi::c_char,
	#[doc = "< Additional, type-specific schema definitions."]
	pub schema: *mut ::core::ffi::c_void,
}
#[doc = " @brief   An array of data schemas, modelled as a linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_data_schemas {
	#[doc = "< The next element in the linked list."]
	pub next: *mut wot_td_data_schemas,
	#[doc = "< The current data schema element in the linked list."]
	pub value: *mut wot_td_data_schema_t,
}
#[doc = " @brief   An array of data schemas, modelled as a linked list."]
pub type wot_td_data_schemas_t = wot_td_data_schemas;
#[doc = " @brief   Metadata describing data of type Array."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#arrayschema"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_array_schema_t {
	#[doc = "< Used to define the characteristics of an array."]
	pub items: *mut wot_td_data_schemas_t,
	#[doc = "< Defines the minimum number of items that have"]
	#[doc = "to be in the array."]
	pub min_items: *const u32,
	#[doc = "< Defines the maximum number of items that have"]
	#[doc = "to be in the array."]
	pub max_items: *const u32,
}
#[doc = " @brief   Maps keys to @ref wot_td_data_schema_t structs, modelled as a linked"]
#[doc = " list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_data_schema_map {
	#[doc = "< The next element in the linked list."]
	pub next: *mut wot_td_data_schema_map,
	#[doc = "< The key used in the map."]
	pub key: *const ::core::ffi::c_char,
	#[doc = "< The value the key is mapping to."]
	pub value: *mut wot_td_data_schema_t,
}
#[doc = " @brief   Maps keys to @ref wot_td_data_schema_t structs, modelled as a linked"]
#[doc = " list."]
pub type wot_td_data_schema_map_t = wot_td_data_schema_map;
#[doc = " @brief   Representation of an `ObjectSchema` definition."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#objectschema"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_object_schema_t {
	#[doc = "< Data schema nested definitions."]
	pub properties: *mut wot_td_data_schema_map_t,
	#[doc = "< Defines which members of the object"]
	#[doc = "type are   mandatory."]
	pub required: *mut wot_td_object_required_t,
}
#[doc = " @brief   Representation of an `InteractionAffordance` definition."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#interactionaffordance"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_int_affordance_t {
	#[doc = "< JSON-LD keyword to label the object with"]
	#[doc = "semantic tags (or types)."]
	pub type_: *mut wot_td_type_t,
	#[doc = "< Provides multi-language human-readable"]
	#[doc = "titles."]
	pub titles: *mut wot_td_multi_lang_t,
	#[doc = "< Can be used to support (human-readable)"]
	#[doc = "information in different languages."]
	pub descriptions: *mut wot_td_multi_lang_t,
	#[doc = "< Set of form hypermedia controls that"]
	#[doc = "describe how an operation can be performed."]
	#[doc = "Forms are serializations of Protocol"]
	#[doc = "Bindings."]
	pub forms: *mut wot_td_form_t,
	#[doc = "< Define URI template variables as collection"]
	#[doc = "based on DataSchema declarations."]
	pub uri_variables: *mut wot_td_data_schema_map_t,
}
#[doc = " @brief   Representation of `PropertyAffordance` definitions, modelled as a"]
#[doc = " linked list."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#propertyaffordance"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_prop_affordance {
	#[doc = "< The next element in the linked list."]
	pub next: *mut wot_td_prop_affordance,
	#[doc = "< Key of this Property Affordance."]
	pub key: *const ::core::ffi::c_char,
	#[doc = "< Indicates whether the Property is observable"]
	#[doc = "or not."]
	pub observable: bool,
	#[doc = "< Data schema applied to this Property"]
	#[doc = "Affordance."]
	pub data_schema: *mut wot_td_data_schema_t,
	#[doc = "< Common Interaction Affordance definitions."]
	pub int_affordance: *mut wot_td_int_affordance_t,
}
#[doc = " @brief   Representation of `PropertyAffordance` definitions, modelled as a"]
#[doc = " linked list."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#propertyaffordance"]
pub type wot_td_prop_affordance_t = wot_td_prop_affordance;
#[doc = " @brief   Representation of `ActionAffordance` definitions, modelled as a"]
#[doc = " linked list."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#actionaffordance"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_action_affordance {
	#[doc = "< The next element in the linked list."]
	pub next: *mut wot_td_action_affordance,
	#[doc = "< Key of this Action Affordance."]
	pub key: *const ::core::ffi::c_char,
	#[doc = "< Used to define the input data schema of the"]
	#[doc = "Action."]
	pub input: *mut wot_td_data_schema_t,
	#[doc = "< Used to define the output data schema of"]
	#[doc = "the Action."]
	pub output: *mut wot_td_data_schema_t,
	#[doc = "< Signals if the Action is safe (=true) or"]
	#[doc = "not."]
	pub safe: bool,
	#[doc = "< Indicates whether the Action is idempotent"]
	#[doc = "(=true) or not."]
	pub idempotent: bool,
	#[doc = "< Common Interaction Affordance definitions."]
	pub int_affordance: *mut wot_td_int_affordance_t,
}
#[doc = " @brief   Representation of `ActionAffordance` definitions, modelled as a"]
#[doc = " linked list."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#actionaffordance"]
pub type wot_td_action_affordance_t = wot_td_action_affordance;
#[doc = " @brief   Representation of `EventAffordance` definitions, modelled as a"]
#[doc = " linked list."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#eventaffordance"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_event_affordance {
	#[doc = "< The next element in the linked list."]
	pub next: *mut wot_td_event_affordance,
	#[doc = "< Key of this Event Affordance."]
	pub key: *const ::core::ffi::c_char,
	#[doc = "< Defines data that needs to be passed"]
	#[doc = "upon subscription."]
	pub subscription: *mut wot_td_data_schema_t,
	#[doc = "< Defines the data schema of the Event instance"]
	#[doc = "messages pushed by the Thing."]
	pub data: *mut wot_td_data_schema_t,
	#[doc = "< Defines any data that needs to be"]
	#[doc = "passed to cancel a subscription,"]
	pub cancellation: *mut wot_td_data_schema_t,
	#[doc = "< Common Interaction Affordance definitions."]
	pub int_affordance: *mut wot_td_int_affordance_t,
}
#[doc = " @brief   Representation of `EventAffordance` definitions, modelled as a"]
#[doc = " linked list."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#eventaffordance"]
pub type wot_td_event_affordance_t = wot_td_event_affordance;
#[doc = " @brief   Representation of a `VersionInfo` definition."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#versioninfo"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_version_info_t {
	#[doc = "< Provides a version indicator of this TD instance."]
	pub instance: *const ::core::ffi::c_char,
}
#[doc = " @brief   Representation of a `dateTime` definition."]
#[doc = " @see     https://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/#dateTime"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_date_time_t {
	#[doc = "< The year within the `dateTime` definition."]
	pub year: i32,
	#[doc = "< The month within the `dateTime` definition."]
	pub month: u8,
	#[doc = "< The day within the `dateTime` definition."]
	pub day: u8,
	#[doc = "< The hour within the `dateTime` definition."]
	pub hour: u8,
	#[doc = "< The minute within the `dateTime` definition."]
	pub minute: u8,
	#[doc = "< The second within the `dateTime` definition."]
	pub second: u8,
	#[doc = "< Timezone offset within the `dateTime` definition."]
	pub timezone_offset: i16,
}
#[doc = " @brief   Representation of `Link` definitions, modelled as a linked list."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#link"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_link {
	#[doc = "< The next element in the linked list."]
	pub next: *mut wot_td_link,
	#[doc = "< Target IRI of the link."]
	pub href: *mut wot_td_uri_t,
	#[doc = "< Target attribute providing a hint indicating"]
	#[doc = "what the media type of the result of"]
	#[doc = "dereferencing the link should be."]
	pub type_: wot_td_media_type_t,
	#[doc = "< A link relation type identifies the semantics of a link."]
	pub rel: *const ::core::ffi::c_char,
	#[doc = "< Overrides the link context (by default the Thing itself"]
	#[doc = "identified by its id) with the given URI or IRI."]
	pub anchor: *mut wot_td_uri_t,
}
#[doc = " @brief   Representation of `Link` definitions, modelled as a linked list."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#link"]
pub type wot_td_link_t = wot_td_link;
#[doc = " @brief   Representation of a `Thing` definition."]
#[doc = " @see     https://www.w3.org/TR/wot-thing-description/#thing"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_thing_t {
	#[doc = "< The context elements. Linked list."]
	pub context: *mut json_ld_context_t,
	#[doc = "< Allows for labelling the object with"]
	#[doc = "semantic tags (or types)."]
	pub type_: *mut wot_td_type_t,
	#[doc = "< Identifier of the Thing in form of a URI."]
	pub id: *mut wot_td_uri_t,
	#[doc = "< Provides multi-language human-readable"]
	#[doc = "titles."]
	pub titles: *mut wot_td_multi_lang_t,
	#[doc = "< Can be used to support (human-readable)"]
	#[doc = "information in different languages."]
	pub descriptions: *mut wot_td_multi_lang_t,
	#[doc = "< Version information."]
	pub version: *mut wot_td_version_info_t,
	#[doc = "< Created timestep."]
	pub created: *mut wot_td_date_time_t,
	#[doc = "< Modified timestep."]
	pub modified: *mut wot_td_date_time_t,
	#[doc = "< URI pointing to support information."]
	pub support: *mut wot_td_uri_t,
	#[doc = "< The Thing's base address."]
	pub base: *mut wot_td_uri_t,
	#[doc = "< Properties exposed by the Thing."]
	pub properties: *mut wot_td_prop_affordance_t,
	#[doc = "< Actions exposed by the Thing."]
	pub actions: *mut wot_td_action_affordance_t,
	#[doc = "< Events exposed by the Thing."]
	pub events: *mut wot_td_event_affordance_t,
	#[doc = "< Provides Web links to arbitrary resources"]
	#[doc = "that relate to the Thing Description."]
	pub links: *mut wot_td_link_t,
	#[doc = "< Top-level forms."]
	pub forms: *mut wot_td_form_t,
	#[doc = "< Set of security definition names,"]
	#[doc = "chosen from those defined in"]
	#[doc = "`security_def`."]
	pub security: *mut wot_td_security_t,
	#[doc = "< Set of named security configurations"]
	#[doc = "(definitions only)."]
	pub security_def: *mut wot_td_security_definition_t,
	#[doc = "< The default language used in the TD."]
	pub default_language_tag: *mut ::core::ffi::c_char,
}
extern "C" {
	pub fn wot_td_thing_context_add(
		thing: *mut wot_td_thing_t,
		context: *mut json_ld_context_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_context_rm(
		thing: *mut wot_td_thing_t,
		context: *mut json_ld_context_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_context_find_nth(
		thing: *mut wot_td_thing_t,
		pos: u8,
	) -> *mut json_ld_context_t;
}
extern "C" {
	pub fn wot_td_thing_context_find_key(
		thing: *mut wot_td_thing_t,
		key: *const ::core::ffi::c_char,
	) -> *mut json_ld_context_t;
}
extern "C" {
	pub fn wot_td_thing_context_find_value(
		thing: *mut wot_td_thing_t,
		value: *const ::core::ffi::c_char,
	) -> *mut json_ld_context_t;
}
extern "C" {
	pub fn wot_td_thing_title_add(
		thing: *mut wot_td_thing_t,
		title: *mut wot_td_multi_lang_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_title_rm(
		thing: *mut wot_td_thing_t,
		title: *mut wot_td_multi_lang_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_titles_find_nth(
		thing: *mut wot_td_thing_t,
		pos: u8,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_thing_titles_find_tag(
		thing: *mut wot_td_thing_t,
		tag: *const ::core::ffi::c_char,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_thing_titles_find_value(
		thing: *mut wot_td_thing_t,
		value: *const ::core::ffi::c_char,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_thing_desc_add(
		thing: *mut wot_td_thing_t,
		desc: *mut wot_td_multi_lang_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_desc_rm(
		thing: *mut wot_td_thing_t,
		desc: *mut wot_td_multi_lang_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_desc_find_nth(
		thing: *mut wot_td_thing_t,
		pos: u8,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_thing_desc_find_tag(
		thing: *mut wot_td_thing_t,
		tag: *const ::core::ffi::c_char,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_thing_desc_find_value(
		thing: *mut wot_td_thing_t,
		value: *const ::core::ffi::c_char,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_thing_type_add(
		thing: *mut wot_td_thing_t,
		type_: *mut wot_td_type_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_type_rm(
		thing: *mut wot_td_thing_t,
		type_: *mut wot_td_type_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_type_find_nth(thing: *mut wot_td_thing_t, pos: u8) -> *mut wot_td_type_t;
}
extern "C" {
	pub fn wot_td_thing_type_find_value(
		thing: *mut wot_td_thing_t,
		value: *const ::core::ffi::c_char,
	) -> *mut wot_td_type_t;
}
extern "C" {
	pub fn wot_td_thing_prop_add(
		thing: *mut wot_td_thing_t,
		property: *mut wot_td_prop_affordance_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_prop_rm(
		thing: *mut wot_td_thing_t,
		property: *mut wot_td_prop_affordance_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_prop_find_nth(
		thing: *mut wot_td_thing_t,
		pos: u8,
	) -> *mut wot_td_prop_affordance_t;
}
extern "C" {
	pub fn wot_td_thing_prop_find_key(
		thing: *mut wot_td_thing_t,
		key: *const ::core::ffi::c_char,
	) -> *mut wot_td_prop_affordance_t;
}
extern "C" {
	pub fn wot_td_thing_action_add(
		thing: *mut wot_td_thing_t,
		action: *mut wot_td_action_affordance_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_action_rm(
		thing: *mut wot_td_thing_t,
		action: *mut wot_td_action_affordance_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_action_find_nth(
		thing: *mut wot_td_thing_t,
		pos: u8,
	) -> *mut wot_td_action_affordance_t;
}
extern "C" {
	pub fn wot_td_thing_action_find_key(
		thing: *mut wot_td_thing_t,
		key: *const ::core::ffi::c_char,
	) -> *mut wot_td_action_affordance_t;
}
extern "C" {
	pub fn wot_td_thing_event_add(
		thing: *mut wot_td_thing_t,
		event: *mut wot_td_event_affordance_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_event_rm(
		thing: *mut wot_td_thing_t,
		event: *mut wot_td_event_affordance_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_event_find_nth(
		thing: *mut wot_td_thing_t,
		pos: u8,
	) -> *mut wot_td_event_affordance_t;
}
extern "C" {
	pub fn wot_td_thing_event_find_key(
		thing: *mut wot_td_thing_t,
		key: *const ::core::ffi::c_char,
	) -> *mut wot_td_event_affordance_t;
}
extern "C" {
	pub fn wot_td_thing_security_add(
		thing: *mut wot_td_thing_t,
		security: *mut wot_td_security_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_security_rm(
		thing: *mut wot_td_thing_t,
		security: *mut wot_td_security_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_security_find_nth(
		thing: *mut wot_td_thing_t,
		pos: u8,
	) -> *mut wot_td_security_t;
}
extern "C" {
	pub fn wot_td_thing_security_def_add(
		thing: *mut wot_td_thing_t,
		security_def: *mut wot_td_security_definition_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_security_def_rm(
		thing: *mut wot_td_thing_t,
		security_def: *mut wot_td_security_definition_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_security_def_find_nth(
		thing: *mut wot_td_thing_t,
		pos: u8,
	) -> *mut wot_td_security_t;
}
extern "C" {
	pub fn wot_td_thing_security_def_find_key(
		thing: *mut wot_td_thing_t,
		key: *mut ::core::ffi::c_char,
	) -> *mut wot_td_security_t;
}
extern "C" {
	pub fn wot_td_thing_link_add(
		thing: *mut wot_td_thing_t,
		link: *mut wot_td_link_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_link_rm(
		thing: *mut wot_td_thing_t,
		link: *mut wot_td_link_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_link_find_nth(thing: *mut wot_td_thing_t, pos: u8) -> *mut wot_td_link_t;
}
extern "C" {
	pub fn wot_td_thing_form_add(
		thing: *mut wot_td_thing_t,
		form: *mut wot_td_form_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_form_rm(
		thing: *mut wot_td_thing_t,
		form: *mut wot_td_form_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_thing_form_find_nth(thing: *mut wot_td_thing_t, pos: u8) -> *mut wot_td_form_t;
}
extern "C" {
	pub fn wot_td_form_security_add(
		form: *mut wot_td_form_t,
		security: *mut wot_td_security_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_form_security_rm(
		form: *mut wot_td_form_t,
		security: *mut wot_td_security_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_form_security_find_nth(
		form: *mut wot_td_form_t,
		pos: u8,
	) -> *mut wot_td_security_t;
}
extern "C" {
	pub fn wot_td_form_security_find_key(
		form: *mut wot_td_form_t,
		key: *mut ::core::ffi::c_char,
	) -> *mut wot_td_security_t;
}
extern "C" {
	pub fn wot_td_form_auth_scope_add(
		form: *mut wot_td_form_t,
		scope: *mut wot_td_auth_scopes_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_form_auth_scope_rm(
		form: *mut wot_td_form_t,
		scope: *mut wot_td_auth_scopes_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_form_auth_scope_find_nth(
		form: *mut wot_td_form_t,
		pos: u8,
	) -> *mut wot_td_auth_scopes_t;
}
extern "C" {
	pub fn wot_td_form_auth_scope_find_value(
		form: *mut wot_td_form_t,
		value: *const ::core::ffi::c_char,
	) -> *mut wot_td_auth_scopes_t;
}
extern "C" {
	pub fn wot_td_form_op_add(
		form: *mut wot_td_form_t,
		op: *mut wot_td_form_op_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_form_op_rm(
		form: *mut wot_td_form_t,
		op: *mut wot_td_form_op_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_form_op_find_nth(form: *mut wot_td_form_t, pos: u8) -> *mut wot_td_form_op_t;
}
extern "C" {
	pub fn wot_td_affordance_title_add(
		affordance: *mut wot_td_int_affordance_t,
		title: *mut wot_td_multi_lang_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_affordance_title_rm(
		affordance: *mut wot_td_int_affordance_t,
		title: *mut wot_td_multi_lang_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_affordance_title_find_nth(
		affordance: *mut wot_td_int_affordance_t,
		pos: u8,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_affordance_title_find_tag(
		affordance: *mut wot_td_int_affordance_t,
		tag: *const ::core::ffi::c_char,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_affordance_title_find_value(
		affordance: *mut wot_td_int_affordance_t,
		value: *const ::core::ffi::c_char,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_affordance_form_add(
		affordance: *mut wot_td_int_affordance_t,
		form: *mut wot_td_form_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_affordance_form_rm(
		affordance: *mut wot_td_int_affordance_t,
		form: *mut wot_td_form_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_affordance_form_find_nth(
		affordance: *mut wot_td_int_affordance_t,
		pos: u8,
	) -> *mut wot_td_form_t;
}
extern "C" {
	pub fn wot_td_security_desc_add(
		security: *mut wot_td_sec_scheme_t,
		desc: *mut wot_td_multi_lang_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_security_desc_rm(
		security: *mut wot_td_sec_scheme_t,
		desc: *mut wot_td_multi_lang_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_security_desc_find_nth(
		security: *mut wot_td_sec_scheme_t,
		pos: u8,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_security_desc_find_tag(
		security: *mut wot_td_sec_scheme_t,
		tag: *const ::core::ffi::c_char,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_security_desc_find_value(
		security: *mut wot_td_sec_scheme_t,
		value: *const ::core::ffi::c_char,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_oauth_auth_scope_add(
		scheme: *mut wot_td_oauth2_sec_scheme_t,
		scope: *mut wot_td_auth_scopes_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_oauth_auth_scope_rm(
		scheme: *mut wot_td_oauth2_sec_scheme_t,
		scope: *mut wot_td_auth_scopes_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_oauth_scope_find_nth(
		scheme: *mut wot_td_oauth2_sec_scheme_t,
		pos: u8,
	) -> *mut wot_td_auth_scopes_t;
}
extern "C" {
	pub fn wot_td_oauth_scope_find_value(
		scheme: *mut wot_td_oauth2_sec_scheme_t,
		value: *const ::core::ffi::c_char,
	) -> *mut wot_td_auth_scopes_t;
}
extern "C" {
	pub fn wot_td_data_schema_desc_add(
		schema: *mut wot_td_data_schema_t,
		desc: *mut wot_td_multi_lang_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_data_schema_desc_rm(
		schema: *mut wot_td_data_schema_t,
		desc: *mut wot_td_multi_lang_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_data_schema_desc_find_nth(
		schema: *mut wot_td_data_schema_t,
		pos: u8,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_data_schema_desc_find_tag(
		schema: *mut wot_td_data_schema_t,
		tag: *const ::core::ffi::c_char,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_data_schema_desc_find_value(
		schema: *mut wot_td_data_schema_t,
		value: *const ::core::ffi::c_char,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_data_schema_title_add(
		schema: *mut wot_td_data_schema_t,
		title: *mut wot_td_multi_lang_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_data_schema_title_rm(
		schema: *mut wot_td_data_schema_t,
		title: *mut wot_td_multi_lang_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_data_data_schema_title_find_nth(
		schema: *mut wot_td_data_schema_t,
		pos: u8,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_data_schema_title_find_tag(
		schema: *mut wot_td_data_schema_t,
		tag: *const ::core::ffi::c_char,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_data_schema_title_find_value(
		schema: *mut wot_td_data_schema_t,
		value: *const ::core::ffi::c_char,
	) -> *mut wot_td_multi_lang_t;
}
extern "C" {
	pub fn wot_td_data_schema_validation_add(
		schema: *mut wot_td_data_schema_t,
		validator: *mut wot_td_data_schemas_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_data_schema_validation_rm(
		schema: *mut wot_td_data_schema_t,
		validator: *mut wot_td_data_schemas_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_data_data_schema_validator_find_nth(
		schema: *mut wot_td_data_schema_t,
		pos: u8,
	) -> *mut wot_td_data_schemas_t;
}
extern "C" {
	pub fn wot_td_data_schema_enum_add(
		schema: *mut wot_td_data_schema_t,
		enumeration: *mut wot_td_data_enums_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_data_schema_enum_rm(
		schema: *mut wot_td_data_schema_t,
		enumeration: *mut wot_td_data_enums_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_data_schema_enum_find_nth(
		schema: *mut wot_td_data_schema_t,
		pos: u8,
	) -> *mut wot_td_data_enums_t;
}
extern "C" {
	pub fn wot_td_data_schema_enum_find_value(
		schema: *mut wot_td_data_schema_t,
		value: *const ::core::ffi::c_char,
	) -> *mut wot_td_data_enums_t;
}
extern "C" {
	pub fn memcpy(
		__dest: *mut ::core::ffi::c_void,
		__src: *const ::core::ffi::c_void,
		__n: ::core::ffi::c_ulong,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn memmove(
		__dest: *mut ::core::ffi::c_void,
		__src: *const ::core::ffi::c_void,
		__n: ::core::ffi::c_ulong,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn memccpy(
		__dest: *mut ::core::ffi::c_void,
		__src: *const ::core::ffi::c_void,
		__c: ::core::ffi::c_int,
		__n: ::core::ffi::c_ulong,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn memset(
		__s: *mut ::core::ffi::c_void,
		__c: ::core::ffi::c_int,
		__n: ::core::ffi::c_ulong,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn memcmp(
		__s1: *const ::core::ffi::c_void,
		__s2: *const ::core::ffi::c_void,
		__n: ::core::ffi::c_ulong,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn __memcmpeq(
		__s1: *const ::core::ffi::c_void,
		__s2: *const ::core::ffi::c_void,
		__n: usize,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn memchr(
		__s: *const ::core::ffi::c_void,
		__c: ::core::ffi::c_int,
		__n: ::core::ffi::c_ulong,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn strcpy(
		__dest: *mut ::core::ffi::c_char,
		__src: *const ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn strncpy(
		__dest: *mut ::core::ffi::c_char,
		__src: *const ::core::ffi::c_char,
		__n: ::core::ffi::c_ulong,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn strcat(
		__dest: *mut ::core::ffi::c_char,
		__src: *const ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn strncat(
		__dest: *mut ::core::ffi::c_char,
		__src: *const ::core::ffi::c_char,
		__n: ::core::ffi::c_ulong,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn strcmp(
		__s1: *const ::core::ffi::c_char,
		__s2: *const ::core::ffi::c_char,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn strncmp(
		__s1: *const ::core::ffi::c_char,
		__s2: *const ::core::ffi::c_char,
		__n: ::core::ffi::c_ulong,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn strcoll(
		__s1: *const ::core::ffi::c_char,
		__s2: *const ::core::ffi::c_char,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn strxfrm(
		__dest: *mut ::core::ffi::c_char,
		__src: *const ::core::ffi::c_char,
		__n: ::core::ffi::c_ulong,
	) -> ::core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
	pub __locales: [*mut __locale_data; 13usize],
	pub __ctype_b: *const ::core::ffi::c_ushort,
	pub __ctype_tolower: *const ::core::ffi::c_int,
	pub __ctype_toupper: *const ::core::ffi::c_int,
	pub __names: [*const ::core::ffi::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
	pub fn strcoll_l(
		__s1: *const ::core::ffi::c_char,
		__s2: *const ::core::ffi::c_char,
		__l: locale_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn strxfrm_l(
		__dest: *mut ::core::ffi::c_char,
		__src: *const ::core::ffi::c_char,
		__n: usize,
		__l: locale_t,
	) -> usize;
}
extern "C" {
	pub fn strdup(__s: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn strndup(
		__string: *const ::core::ffi::c_char,
		__n: ::core::ffi::c_ulong,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn strchr(
		__s: *const ::core::ffi::c_char,
		__c: ::core::ffi::c_int,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn strrchr(
		__s: *const ::core::ffi::c_char,
		__c: ::core::ffi::c_int,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn strcspn(
		__s: *const ::core::ffi::c_char,
		__reject: *const ::core::ffi::c_char,
	) -> ::core::ffi::c_ulong;
}
extern "C" {
	pub fn strspn(
		__s: *const ::core::ffi::c_char,
		__accept: *const ::core::ffi::c_char,
	) -> ::core::ffi::c_ulong;
}
extern "C" {
	pub fn strpbrk(
		__s: *const ::core::ffi::c_char,
		__accept: *const ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn strstr(
		__haystack: *const ::core::ffi::c_char,
		__needle: *const ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn strtok(
		__s: *mut ::core::ffi::c_char,
		__delim: *const ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn __strtok_r(
		__s: *mut ::core::ffi::c_char,
		__delim: *const ::core::ffi::c_char,
		__save_ptr: *mut *mut ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn strtok_r(
		__s: *mut ::core::ffi::c_char,
		__delim: *const ::core::ffi::c_char,
		__save_ptr: *mut *mut ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn strlen(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_ulong;
}
extern "C" {
	pub fn strnlen(__string: *const ::core::ffi::c_char, __maxlen: usize) -> usize;
}
extern "C" {
	pub fn strerror(__errnum: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
	#[link_name = "\u{1}__xpg_strerror_r"]
	pub fn strerror_r(
		__errnum: ::core::ffi::c_int,
		__buf: *mut ::core::ffi::c_char,
		__buflen: usize,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn strerror_l(__errnum: ::core::ffi::c_int, __l: locale_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn bcmp(
		__s1: *const ::core::ffi::c_void,
		__s2: *const ::core::ffi::c_void,
		__n: ::core::ffi::c_ulong,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn bcopy(__src: *const ::core::ffi::c_void, __dest: *mut ::core::ffi::c_void, __n: usize);
}
extern "C" {
	pub fn bzero(__s: *mut ::core::ffi::c_void, __n: ::core::ffi::c_ulong);
}
extern "C" {
	pub fn index(
		__s: *const ::core::ffi::c_char,
		__c: ::core::ffi::c_int,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn rindex(
		__s: *const ::core::ffi::c_char,
		__c: ::core::ffi::c_int,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn ffs(__i: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn ffsl(__l: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn ffsll(__ll: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn strcasecmp(
		__s1: *const ::core::ffi::c_char,
		__s2: *const ::core::ffi::c_char,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn strncasecmp(
		__s1: *const ::core::ffi::c_char,
		__s2: *const ::core::ffi::c_char,
		__n: ::core::ffi::c_ulong,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn strcasecmp_l(
		__s1: *const ::core::ffi::c_char,
		__s2: *const ::core::ffi::c_char,
		__loc: locale_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn strncasecmp_l(
		__s1: *const ::core::ffi::c_char,
		__s2: *const ::core::ffi::c_char,
		__n: usize,
		__loc: locale_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn explicit_bzero(__s: *mut ::core::ffi::c_void, __n: usize);
}
extern "C" {
	pub fn strsep(
		__stringp: *mut *mut ::core::ffi::c_char,
		__delim: *const ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn strsignal(__sig: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn __stpcpy(
		__dest: *mut ::core::ffi::c_char,
		__src: *const ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn stpcpy(
		__dest: *mut ::core::ffi::c_char,
		__src: *const ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn __stpncpy(
		__dest: *mut ::core::ffi::c_char,
		__src: *const ::core::ffi::c_char,
		__n: usize,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn stpncpy(
		__dest: *mut ::core::ffi::c_char,
		__src: *const ::core::ffi::c_char,
		__n: ::core::ffi::c_ulong,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn _assert_panic() -> !;
}
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
	pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
	pub __bindgen_padding_0: u64,
	pub __clang_max_align_nonce2: u128,
}
#[doc = " @brief List node structure"]
#[doc = ""]
#[doc = " Used as is as reference to a list, or as member of any data structure that"]
#[doc = " should be member of a list."]
#[doc = ""]
#[doc = " Actual list objects should have a @c list_node_t as member and then use"]
#[doc = " the container_of() macro in list operations."]
#[doc = " See @ref thread_add_to_list() as example."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_node {
	#[doc = "< pointer to next list entry"]
	pub next: *mut list_node,
}
#[doc = " @brief List node structure"]
#[doc = ""]
#[doc = " Used as is as reference to a list, or as member of any data structure that"]
#[doc = " should be member of a list."]
#[doc = ""]
#[doc = " Actual list objects should have a @c list_node_t as member and then use"]
#[doc = " the container_of() macro in list operations."]
#[doc = " See @ref thread_add_to_list() as example."]
pub type list_node_t = list_node;
#[doc = " @brief List node structure"]
#[doc = ""]
#[doc = " Used as is as reference to a list, or as member of any data structure that"]
#[doc = " should be member of a list."]
#[doc = ""]
#[doc = " Actual list objects should have a @c list_node_t as member and then use"]
#[doc = " the container_of() macro in list operations."]
#[doc = " See @ref thread_add_to_list() as example."]
pub type clist_node_t = list_node_t;
#[doc = " @brief Typedef for comparison function used by @ref clist_sort()"]
#[doc = ""]
pub type clist_cmp_func_t = ::core::option::Option<
	unsafe extern "C" fn(a: *mut clist_node_t, b: *mut clist_node_t) -> ::core::ffi::c_int,
>;
extern "C" {
	#[doc = " @brief   List sorting helper function"]
	#[doc = ""]
	#[doc = " @internal"]
	#[doc = ""]
	#[doc = " @param[in]   list_head   ptr to the first element inside a clist"]
	#[doc = " @param[in]   cmp         comparison function"]
	#[doc = ""]
	#[doc = " @returns     ptr to *last* element in list"]
	pub fn _clist_sort(list_head: *mut clist_node_t, cmp: clist_cmp_func_t) -> *mut clist_node_t;
}
extern "C" {
	pub static mut _native_flash: [::core::ffi::c_char; 16384usize];
}
extern "C" {
	#[doc = " @brief   This function sets the IRQ disable bit in the status register"]
	#[doc = ""]
	#[doc = " @return  Previous value of status register. The return value should not be"]
	#[doc = "          interpreted as a boolean value. The actual value is only"]
	#[doc = "          significant for irq_restore()."]
	#[doc = ""]
	#[doc = " @see     irq_restore"]
	pub fn irq_disable() -> ::core::ffi::c_uint;
}
extern "C" {
	#[doc = " @brief   This function clears the IRQ disable bit in the status register"]
	#[doc = ""]
	#[doc = " @return  Previous value of status register. The return value should not be"]
	#[doc = "          interpreted as a boolean value. The actual value is only"]
	#[doc = "          significant for irq_restore()."]
	#[doc = ""]
	#[doc = " @warning This function is here primarily for internal use, and for"]
	#[doc = "          compatibility with the Arduino environment (which lacks the"]
	#[doc = "          \"disable / restore\" concept. Enabling interrupts when a different"]
	#[doc = "          component disabled them can easily cause unintended behavior there."]
	#[doc = ""]
	#[doc = "          Use @ref irq_restore instead."]
	pub fn irq_enable() -> ::core::ffi::c_uint;
}
extern "C" {
	#[doc = " @brief   This function restores the IRQ disable bit in the status register"]
	#[doc = "          to the value contained within passed state"]
	#[doc = ""]
	#[doc = " @param[in] state   state to restore"]
	#[doc = ""]
	#[doc = " @see     irq_disable"]
	pub fn irq_restore(state: ::core::ffi::c_uint);
}
extern "C" {
	#[doc = " @brief   Test if IRQs are currently enabled"]
	#[doc = ""]
	#[doc = " @warning Use this function from thread context only. When used in interrupt"]
	#[doc = "          context the returned state may be incorrect."]
	#[doc = ""]
	#[doc = " @return  false if IRQs are currently disabled"]
	#[doc = " @return  true if IRQs are currently enabled"]
	pub fn irq_is_enabled() -> bool;
}
extern "C" {
	#[doc = " @brief   Check whether called from interrupt service routine"]
	#[doc = " @return  true, if in interrupt service routine, false if not"]
	pub fn irq_is_in() -> bool;
}
#[doc = " @brief circular integer buffer structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cib_t {
	#[doc = "< number of (successful) read accesses"]
	pub read_count: ::core::ffi::c_uint,
	#[doc = "< number of (successful) write accesses"]
	pub write_count: ::core::ffi::c_uint,
	#[doc = "< Size of buffer -1, i.e. mask of the bits"]
	pub mask: ::core::ffi::c_uint,
}
pub type __gwchar_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
	pub quot: ::core::ffi::c_long,
	pub rem: ::core::ffi::c_long,
}
extern "C" {
	pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
	pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
	pub fn strtoimax(
		__nptr: *const ::core::ffi::c_char,
		__endptr: *mut *mut ::core::ffi::c_char,
		__base: ::core::ffi::c_int,
	) -> intmax_t;
}
extern "C" {
	pub fn strtoumax(
		__nptr: *const ::core::ffi::c_char,
		__endptr: *mut *mut ::core::ffi::c_char,
		__base: ::core::ffi::c_int,
	) -> uintmax_t;
}
extern "C" {
	pub fn wcstoimax(
		__nptr: *const __gwchar_t,
		__endptr: *mut *mut __gwchar_t,
		__base: ::core::ffi::c_int,
	) -> intmax_t;
}
extern "C" {
	pub fn wcstoumax(
		__nptr: *const __gwchar_t,
		__endptr: *mut *mut __gwchar_t,
		__base: ::core::ffi::c_int,
	) -> uintmax_t;
}
extern "C" {
	#[doc = " @brief Compilation with g++ may require the declaration of this function."]
	#[doc = ""]
	#[doc = " If implementation of this function is required, it can be realized in"]
	#[doc = " thread_arch.c."]
	pub fn sched_yield() -> ::core::ffi::c_int;
}
#[doc = " Unique process identifier"]
pub type kernel_pid_t = i16;
#[doc = " @brief @c thread_t holds thread's context data."]
pub type thread_t = _thread;
#[doc = "< has terminated"]
pub const thread_status_t_STATUS_STOPPED: thread_status_t = 0;
#[doc = "< has terminated & keeps thread's thread_t"]
pub const thread_status_t_STATUS_ZOMBIE: thread_status_t = 1;
#[doc = "< sleeping"]
pub const thread_status_t_STATUS_SLEEPING: thread_status_t = 2;
#[doc = "< waiting for a locked mutex"]
pub const thread_status_t_STATUS_MUTEX_BLOCKED: thread_status_t = 3;
#[doc = "< waiting for a message"]
pub const thread_status_t_STATUS_RECEIVE_BLOCKED: thread_status_t = 4;
#[doc = "< waiting for message to be delivered"]
pub const thread_status_t_STATUS_SEND_BLOCKED: thread_status_t = 5;
#[doc = "< waiting for a message response"]
pub const thread_status_t_STATUS_REPLY_BLOCKED: thread_status_t = 6;
#[doc = "< waiting for any flag from flag_mask"]
pub const thread_status_t_STATUS_FLAG_BLOCKED_ANY: thread_status_t = 7;
#[doc = "< waiting for all flags in flag_mask"]
pub const thread_status_t_STATUS_FLAG_BLOCKED_ALL: thread_status_t = 8;
#[doc = "< waiting for get/put on mbox"]
pub const thread_status_t_STATUS_MBOX_BLOCKED: thread_status_t = 9;
#[doc = "< waiting for a condition variable"]
pub const thread_status_t_STATUS_COND_BLOCKED: thread_status_t = 10;
#[doc = "< currently running"]
pub const thread_status_t_STATUS_RUNNING: thread_status_t = 11;
#[doc = "< waiting to be scheduled to run"]
pub const thread_status_t_STATUS_PENDING: thread_status_t = 12;
#[doc = "< number of supported thread states"]
pub const thread_status_t_STATUS_NUMOF: thread_status_t = 13;
#[doc = " @name Thread states supported by RIOT"]
#[doc = ""]
#[doc = "       Keep in sync with OpenOCD src/rtos/riot.c"]
#[doc = " @{"]
pub type thread_status_t = ::core::ffi::c_uint;
extern "C" {
	#[doc = " @brief   Triggers the scheduler to schedule the next thread"]
	#[doc = ""]
	#[doc = " @returns     The new thread to schedule if sched_active_thread/sched_active_pid"]
	#[doc = "              was changed,"]
	#[doc = " @returns     NULL if the active thread was not changed."]
	pub fn sched_run() -> *mut thread_t;
}
extern "C" {
	#[doc = " @brief   Set the status of the specified process"]
	#[doc = ""]
	#[doc = " @param[in]   process     Pointer to the thread control block of the"]
	#[doc = "                          targeted process"]
	#[doc = " @param[in]   status      The new status of this thread"]
	pub fn sched_set_status(process: *mut thread_t, status: thread_status_t);
}
extern "C" {
	#[doc = " @brief       Yield if appropriate."]
	#[doc = ""]
	#[doc = " @details     Either yield if other_prio is higher than the current priority,"]
	#[doc = "              or if the current thread is not on the runqueue."]
	#[doc = ""]
	#[doc = "              Depending on whether the current execution is in an ISR (irq_is_in()),"]
	#[doc = "              thread_yield_higher() is called or @ref sched_context_switch_request is set,"]
	#[doc = "              respectively."]
	#[doc = ""]
	#[doc = " @param[in]   other_prio      The priority of the target thread."]
	pub fn sched_switch(other_prio: u16);
}
extern "C" {
	#[doc = " @brief   Call context switching at thread exit"]
	pub fn cpu_switch_context_exit() -> !;
}
extern "C" {
	#[doc = " Flag indicating whether a context switch is necessary after handling an"]
	#[doc = " interrupt. Supposed to be set in an ISR."]
	pub static mut sched_context_switch_request: ::core::ffi::c_uint;
}
extern "C" {
	#[doc = "  Thread table"]
	pub static mut sched_threads: [*mut thread_t; 33usize];
}
extern "C" {
	#[doc = "  Number of running (non-terminated) threads"]
	pub static mut sched_num_threads: ::core::ffi::c_int;
}
extern "C" {
	#[doc = " List of runqueues per priority level"]
	pub static mut sched_runqueues: [clist_node_t; 16usize];
}
extern "C" {
	#[doc = " @brief  Removes thread from scheduler and set status to #STATUS_STOPPED"]
	pub fn sched_task_exit() -> !;
}
extern "C" {
	#[doc = " @brief   Change the priority of the given thread"]
	#[doc = ""]
	#[doc = " @note    This functions expects interrupts to be disabled when called!"]
	#[doc = ""]
	#[doc = " @pre     (thread != NULL)"]
	#[doc = " @pre     (priority < SCHED_PRIO_LEVELS)"]
	#[doc = ""]
	#[doc = " @param[in,out] thread    target thread"]
	#[doc = " @param[in]     priority  new priority to assign to @p thread"]
	pub fn sched_change_priority(thread: *mut thread_t, priority: u8);
}
extern "C" {
	#[doc = " @brief  Set CPU to idle mode (CPU dependent)"]
	#[doc = ""]
	#[doc = " Only used when there's no idle thread."]
	#[doc = ""]
	#[doc = " This function will be called by the scheduler when there's no runnable thread."]
	#[doc = " It will be called from ISR context, and *must* allow other ISR handlers to be run."]
	#[doc = " E.g., on Cortex-M, the PendSV priority is temporarily lowered (set to higher"]
	#[doc = " value) in order to enable other exceptions to be run."]
	#[doc = ""]
	#[doc = " This function should also invoke setting a low power mode, e.g., by calling"]
	#[doc = " 'pm_set_lowest()'."]
	pub fn sched_arch_idle();
}
#[doc = " @brief Describes a message object which can be sent between threads."]
#[doc = ""]
#[doc = " User can set type and one of content.ptr and content.value. (content is a union)"]
#[doc = " The meaning of type and the content fields is totally up to the user,"]
#[doc = " the corresponding fields are never read by the kernel."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msg_t {
	#[doc = "< PID of sending thread. Will be filled in"]
	#[doc = "by msg_send."]
	pub sender_pid: kernel_pid_t,
	#[doc = "< Type field."]
	pub type_: u16,
	#[doc = "< Content of the message."]
	pub content: msg_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msg_t__bindgen_ty_1 {
	#[doc = "< Pointer content field."]
	pub ptr: *mut ::core::ffi::c_void,
	#[doc = "< Value content field."]
	pub value: u32,
}
extern "C" {
	#[doc = " @brief Send a message (blocking)."]
	#[doc = ""]
	#[doc = " This function sends a message to another thread. The ``msg_t`` structure has"]
	#[doc = " to be allocated (e.g. on the stack) before calling the function and can be"]
	#[doc = " freed afterwards. If called from an interrupt, this function will never"]
	#[doc = " block."]
	#[doc = ""]
	#[doc = " @param[in] m             Pointer to preallocated ``msg_t`` structure, must"]
	#[doc = "                          not be NULL."]
	#[doc = " @param[in] target_pid    PID of target thread"]
	#[doc = ""]
	#[doc = " @return 1, if sending was successful (message delivered directly or to a"]
	#[doc = "            queue)"]
	#[doc = " @return 0, if called from ISR and receiver cannot receive the message now"]
	#[doc = "            (it is not waiting or it's message queue is full)"]
	#[doc = " @return -1, on error (invalid PID)"]
	pub fn msg_send(m: *mut msg_t, target_pid: kernel_pid_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief Send a message (non-blocking)."]
	#[doc = ""]
	#[doc = " This function sends a message to another thread. The ``msg_t`` structure has"]
	#[doc = " to be allocated (e.g. on the stack) before calling the function and can be"]
	#[doc = " freed afterwards. This function will never block."]
	#[doc = ""]
	#[doc = " @param[in] m             Pointer to preallocated ``msg_t`` structure, must"]
	#[doc = "                          not be NULL."]
	#[doc = " @param[in] target_pid    PID of target thread"]
	#[doc = ""]
	#[doc = " @return 1, if sending was successful (message delivered directly or to a"]
	#[doc = "         queue)"]
	#[doc = " @return 0, if receiver is not waiting or has a full message queue"]
	#[doc = " @return -1, on error (invalid PID)"]
	pub fn msg_try_send(m: *mut msg_t, target_pid: kernel_pid_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief Send a message to the current thread."]
	#[doc = " @details Will work only if the thread has a message queue."]
	#[doc = ""]
	#[doc = " Will be automatically chosen instead of @c msg_send"]
	#[doc = " if @c target_pid == @c thread_pid."]
	#[doc = " This function never blocks."]
	#[doc = ""]
	#[doc = " @param  m pointer to message structure"]
	#[doc = ""]
	#[doc = " @return 1 if sending was successful"]
	#[doc = " @return 0 if the thread's message queue is full (or inexistent)"]
	pub fn msg_send_to_self(m: *mut msg_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief Send message from interrupt."]
	#[doc = ""]
	#[doc = " Will be automatically chosen instead of msg_send() if called from an"]
	#[doc = " interrupt/ISR."]
	#[doc = ""]
	#[doc = " The value of ``m->sender_pid`` is set to @ref KERNEL_PID_ISR."]
	#[doc = ""]
	#[doc = " @see msg_sent_by_int()"]
	#[doc = ""]
	#[doc = " @param[in] m             Pointer to preallocated @ref msg_t structure, must"]
	#[doc = "                          not be NULL."]
	#[doc = " @param[in] target_pid    PID of target thread."]
	#[doc = ""]
	#[doc = " @return 1, if sending was successful"]
	#[doc = " @return 0, if receiver is not waiting and ``block == 0``"]
	#[doc = " @return -1, on error (invalid PID)"]
	pub fn msg_send_int(m: *mut msg_t, target_pid: kernel_pid_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief Receive a message."]
	#[doc = ""]
	#[doc = " This function blocks until a message was received."]
	#[doc = ""]
	#[doc = " @param[out] m    Pointer to preallocated ``msg_t`` structure, must not be"]
	#[doc = "                  NULL."]
	#[doc = ""]
	#[doc = " @return  1, Function always succeeds or blocks forever."]
	pub fn msg_receive(m: *mut msg_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief Try to receive a message."]
	#[doc = ""]
	#[doc = " This function does not block if no message can be received."]
	#[doc = ""]
	#[doc = " @param[out] m    Pointer to preallocated ``msg_t`` structure, must not be"]
	#[doc = "                  NULL."]
	#[doc = ""]
	#[doc = " @return  1, if a message was received"]
	#[doc = " @return  -1, otherwise."]
	pub fn msg_try_receive(m: *mut msg_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief Send a message, block until reply received."]
	#[doc = ""]
	#[doc = " This function sends a message to *target_pid* and then blocks until target"]
	#[doc = " has sent a reply which is then stored in *reply*. The responding thread must"]
	#[doc = " use @ref msg_reply()."]
	#[doc = ""]
	#[doc = " Any incoming messages other than the reply are put into the queue (if one is"]
	#[doc = " configured), block the sender (if sent with @ref msg_send from a thread), or"]
	#[doc = " rejected (if sent with @ref msg_try_send or from an interrupt) -- just like"]
	#[doc = " if the thread were blocked on anything different than message reception."]
	#[doc = ""]
	#[doc = " @pre     @p target_pid is not the PID of the current thread."]
	#[doc = ""]
	#[doc = " @param[in] m             Pointer to preallocated ``msg_t`` structure with"]
	#[doc = "                          the message to send, must not be NULL."]
	#[doc = " @param[out] reply        Pointer to preallocated msg. Reply will be written"]
	#[doc = "                          here, must not be NULL. Can be identical to @p m."]
	#[doc = " @param[in] target_pid    The PID of the target process"]
	#[doc = ""]
	#[doc = " @return  1, if successful."]
	pub fn msg_send_receive(
		m: *mut msg_t,
		reply: *mut msg_t,
		target_pid: kernel_pid_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief Replies to a message."]
	#[doc = ""]
	#[doc = " Sender must have sent the message with msg_send_receive()."]
	#[doc = ""]
	#[doc = " @param[in] m         message to reply to, must not be NULL."]
	#[doc = " @param[out] reply    message that target will get as reply, must not be NULL."]
	#[doc = ""]
	#[doc = " @return 1, if successful"]
	#[doc = " @return -1, on error"]
	pub fn msg_reply(m: *mut msg_t, reply: *mut msg_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief Replies to a message from interrupt."]
	#[doc = ""]
	#[doc = " An ISR can obviously not receive messages, however a thread might delegate"]
	#[doc = " replying to a message to an ISR."]
	#[doc = ""]
	#[doc = " @param[in] m         message to reply to, must not be NULL."]
	#[doc = " @param[out] reply    message that target will get as reply, must not be NULL."]
	#[doc = ""]
	#[doc = " @return 1, if successful"]
	#[doc = " @return -1, on error"]
	pub fn msg_reply_int(m: *mut msg_t, reply: *mut msg_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief Check how many messages are available (waiting) in the message queue"]
	#[doc = "        of a specific thread"]
	#[doc = ""]
	#[doc = " @param[in] pid    a PID"]
	#[doc = ""]
	#[doc = " @return Number of messages available in queue of @p pid on success"]
	#[doc = " @return 0, if no caller's message queue is initialized"]
	pub fn msg_avail_thread(pid: kernel_pid_t) -> ::core::ffi::c_uint;
}
extern "C" {
	#[doc = " @brief Check how many messages are available (waiting) in the message queue"]
	#[doc = ""]
	#[doc = " @return Number of messages available in our queue on success"]
	#[doc = " @return 0, if no caller's message queue is initialized"]
	pub fn msg_avail() -> ::core::ffi::c_uint;
}
extern "C" {
	#[doc = " @brief Get maximum capacity of a thread's queue length"]
	#[doc = ""]
	#[doc = " @return Number of total messages that fit in the queue of @p pid on success"]
	#[doc = " @return 0, if no caller's message queue is initialized"]
	pub fn msg_queue_capacity(pid: kernel_pid_t) -> ::core::ffi::c_uint;
}
extern "C" {
	#[doc = " @brief Initialize the current thread's message queue."]
	#[doc = ""]
	#[doc = " @pre @p num **MUST BE A POWER OF TWO!**"]
	#[doc = ""]
	#[doc = " @param[in] array Pointer to preallocated array of ``msg_t`` structures, must"]
	#[doc = "                  not be NULL."]
	#[doc = " @param[in] num   Number of ``msg_t`` structures in array."]
	#[doc = "                  **MUST BE POWER OF TWO!**"]
	#[doc = ""]
	#[doc = " If array resides on the stack, the containing stack frame must never be"]
	#[doc = " left, not even if it is the current thread's entry function."]
	pub fn msg_init_queue(array: *mut msg_t, num: ::core::ffi::c_int);
}
extern "C" {
	#[doc = " @brief   Prints the message queue of the current thread."]
	pub fn msg_queue_print();
}
#[doc = " @brief Prototype for a thread entry function"]
pub type thread_task_func_t = ::core::option::Option<
	unsafe extern "C" fn(arg: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
>;
#[doc = " @brief @c thread_t holds thread's context data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _thread {
	#[doc = "< thread's stack pointer"]
	pub sp: *mut ::core::ffi::c_char,
	#[doc = "< thread's status"]
	pub status: thread_status_t,
	#[doc = "< thread's priority"]
	pub priority: u8,
	#[doc = "< thread's process id"]
	pub pid: kernel_pid_t,
	#[doc = "< run queue entry"]
	pub rq_entry: clist_node_t,
}
extern "C" {
	#[doc = " @brief Creates a new thread."]
	#[doc = ""]
	#[doc = " For an in-depth discussion of thread priorities, behavior and and flags,"]
	#[doc = " see @ref core_thread."]
	#[doc = ""]
	#[doc = " @note Avoid assigning the same priority to two or more threads."]
	#[doc = " @note Creating threads from within an ISR is currently supported, however it"]
	#[doc = "       is considered to be a bad programming practice and we strongly"]
	#[doc = "       discourage you from doing so."]
	#[doc = ""]
	#[doc = " @param[out] stack    start address of the preallocated stack memory"]
	#[doc = " @param[in] stacksize the size of the thread's stack in bytes"]
	#[doc = " @param[in] priority  priority of the new thread, lower mean higher priority"]
	#[doc = " @param[in] flags     optional flags for the creation of the new thread"]
	#[doc = " @param[in] task_func pointer to the code that is executed in the new thread"]
	#[doc = " @param[in] arg       the argument to the function"]
	#[doc = " @param[in] name      a human readable descriptor for the thread"]
	#[doc = ""]
	#[doc = " @return              PID of newly created task on success"]
	#[doc = " @return              -EINVAL, if @p priority is greater than or equal to"]
	#[doc = "                      @ref SCHED_PRIO_LEVELS"]
	#[doc = " @return              -EOVERFLOW, if there are too many threads running already"]
	pub fn thread_create(
		stack: *mut ::core::ffi::c_char,
		stacksize: ::core::ffi::c_int,
		priority: u8,
		flags: ::core::ffi::c_int,
		task_func: thread_task_func_t,
		arg: *mut ::core::ffi::c_void,
		name: *const ::core::ffi::c_char,
	) -> kernel_pid_t;
}
extern "C" {
	#[doc = " @brief Returns the status of a process"]
	#[doc = ""]
	#[doc = " @param[in] pid   the PID of the thread to get the status from"]
	#[doc = ""]
	#[doc = " @return          status of the thread"]
	#[doc = " @return          `STATUS_NOT_FOUND` if pid is unknown"]
	pub fn thread_getstatus(pid: kernel_pid_t) -> thread_status_t;
}
extern "C" {
	#[doc = " @brief Puts the current thread into sleep mode. Has to be woken up externally."]
	pub fn thread_sleep();
}
extern "C" {
	#[doc = " @brief   Lets current thread yield."]
	#[doc = ""]
	#[doc = " @details The current thread will resume operation immediately,"]
	#[doc = "          if there is no other ready thread with the same or a higher priority."]
	#[doc = ""]
	#[doc = "          Differently from thread_yield_higher() the current thread will be put to the"]
	#[doc = "          end of the thread's in its priority class."]
	#[doc = ""]
	#[doc = " @see     thread_yield_higher()"]
	pub fn thread_yield();
}
extern "C" {
	#[doc = " @brief   Lets current thread yield in favor of a higher prioritized thread."]
	#[doc = ""]
	#[doc = " @details The current thread will resume operation immediately,"]
	#[doc = "          if there is no other ready thread with a higher priority."]
	#[doc = ""]
	#[doc = "          Differently from thread_yield() the current thread will be scheduled next"]
	#[doc = "          in its own priority class, i.e. it stays the first thread in its"]
	#[doc = "          priority class."]
	#[doc = ""]
	#[doc = " @see     thread_yield()"]
	pub fn thread_yield_higher();
}
extern "C" {
	#[doc = " @brief   Puts the current thread into zombie state."]
	#[doc = ""]
	#[doc = " @details Does nothing when in ISR."]
	#[doc = "          A thread in zombie state will never be scheduled again,"]
	#[doc = "          but its scheduler entry and stack will be kept."]
	#[doc = "          A zombie state thread is supposed to be cleaned up"]
	#[doc = "          by @ref thread_kill_zombie()."]
	pub fn thread_zombify();
}
extern "C" {
	#[doc = " @brief Terminates zombie thread."]
	#[doc = ""]
	#[doc = " @param[in] pid   the PID of the thread to terminate"]
	#[doc = ""]
	#[doc = " @return          `1` on success"]
	#[doc = " @return          `STATUS_NOT_FOUND` if pid is unknown or not a zombie"]
	pub fn thread_kill_zombie(pid: kernel_pid_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief Wakes up a sleeping thread."]
	#[doc = ""]
	#[doc = " @param[in] pid   the PID of the thread to be woken up"]
	#[doc = ""]
	#[doc = " @return          `1` on success"]
	#[doc = " @return          `STATUS_NOT_FOUND` if pid is unknown or not sleeping"]
	pub fn thread_wakeup(pid: kernel_pid_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Gets called upon thread creation to set CPU registers"]
	#[doc = ""]
	#[doc = " @param[in] task_func     First function to call within the thread"]
	#[doc = " @param[in] arg           Argument to supply to task_func"]
	#[doc = " @param[in] stack_start   Start address of the stack"]
	#[doc = " @param[in] stack_size    Stack size"]
	#[doc = ""]
	#[doc = " @return stack pointer"]
	pub fn thread_stack_init(
		task_func: thread_task_func_t,
		arg: *mut ::core::ffi::c_void,
		stack_start: *mut ::core::ffi::c_void,
		stack_size: ::core::ffi::c_int,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	#[doc = " @brief Add thread to list, sorted by priority (internal)"]
	#[doc = ""]
	#[doc = " This will add @p thread to @p list sorted by the thread priority."]
	#[doc = " It reuses the thread's rq_entry field."]
	#[doc = " Used internally by msg and mutex implementations."]
	#[doc = ""]
	#[doc = " @note Only use for threads *not on any runqueue* and with interrupts"]
	#[doc = "       disabled."]
	#[doc = ""]
	#[doc = " @param[in] list      ptr to list root node"]
	#[doc = " @param[in] thread    thread to add"]
	pub fn thread_add_to_list(list: *mut list_node_t, thread: *mut thread_t);
}
extern "C" {
	#[doc = " @brief Returns the name of a process"]
	#[doc = ""]
	#[doc = " @note when compiling without DEVELHELP, this *always* returns NULL!"]
	#[doc = ""]
	#[doc = " @param[in] pid   the PID of the thread to get the name from"]
	#[doc = ""]
	#[doc = " @return          the threads name"]
	#[doc = " @return          `NULL` if pid is unknown"]
	pub fn thread_getname(pid: kernel_pid_t) -> *const ::core::ffi::c_char;
}
extern "C" {
	#[doc = " @brief   Get the number of bytes used on the ISR stack"]
	pub fn thread_isr_stack_usage() -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Get the current ISR stack pointer"]
	pub fn thread_isr_stack_pointer() -> *mut ::core::ffi::c_void;
}
extern "C" {
	#[doc = " @brief   Get the start of the ISR stack"]
	pub fn thread_isr_stack_start() -> *mut ::core::ffi::c_void;
}
extern "C" {
	#[doc = " @brief Print the current stack to stdout"]
	pub fn thread_stack_print();
}
extern "C" {
	#[doc = " @brief   Prints human readable, ps-like thread information for debugging purposes"]
	pub fn thread_print_stack();
}
extern "C" {
	#[doc = " Convert a thread state code to a human readable string."]
	#[doc = ""]
	#[doc = " @param   state   thread state to convert"]
	#[doc = " @returns ptr to string representation of thread state (or to \"unknown\")"]
	pub fn thread_state_to_string(state: thread_status_t) -> *const ::core::ffi::c_char;
}
#[doc = " @brief Type definition of thread_flags_t"]
pub type thread_flags_t = u16;
extern "C" {
	#[doc = " @brief Set thread flags, possibly waking it up"]
	#[doc = ""]
	#[doc = " @param[in]   thread     thread to work on"]
	#[doc = " @param[in]   mask    additional flags to be set for the current thread,"]
	#[doc = "                      represented as a bitmask"]
	pub fn thread_flags_set(thread: *mut thread_t, mask: thread_flags_t);
}
extern "C" {
	#[doc = " @brief Clear current thread's flags"]
	#[doc = ""]
	#[doc = " @param[in]   mask    unset flags for the current thread,"]
	#[doc = "                      represented as a bitmask"]
	#[doc = ""]
	#[doc = " @returns     flags that have actually been cleared (mask & thread->flags before clear)"]
	pub fn thread_flags_clear(mask: thread_flags_t) -> thread_flags_t;
}
extern "C" {
	#[doc = " @brief Wait for any flag in mask to become set (blocking)"]
	#[doc = ""]
	#[doc = " If any of the flags in mask are already set, this function will return"]
	#[doc = " immediately, otherwise, it will suspend the thread (as"]
	#[doc = " THREAD_STATUS_WAIT_ANY) until any of the flags in mask get set."]
	#[doc = ""]
	#[doc = " Both ways, it will clear and return (`thread_get_active()->flags & mask`)."]
	#[doc = ""]
	#[doc = " @param[in]   mask    mask of flags to wait for"]
	#[doc = ""]
	#[doc = " @returns     flags that caused return/wakeup (`thread_get_active()->flags & mask`)."]
	pub fn thread_flags_wait_any(mask: thread_flags_t) -> thread_flags_t;
}
extern "C" {
	#[doc = " @brief Wait for all flags in mask to become set (blocking)"]
	#[doc = ""]
	#[doc = " If all the flags in mask are already set, this function will return"]
	#[doc = " immediately, otherwise, it will suspend the thread (as"]
	#[doc = " THREAD_STATUS_WAIT_ALL) until all of the flags in mask have been set."]
	#[doc = ""]
	#[doc = " Both ways, it will clear and return (`thread_get_active()->flags & mask`)."]
	#[doc = ""]
	#[doc = " @param[in]   mask    mask of flags to wait for"]
	#[doc = ""]
	#[doc = " @returns     mask"]
	pub fn thread_flags_wait_all(mask: thread_flags_t) -> thread_flags_t;
}
extern "C" {
	#[doc = " @brief Wait for any flags in mask to become set (blocking), one at a time"]
	#[doc = ""]
	#[doc = " This function is like thread_flags_wait_any(), but will only clear and return"]
	#[doc = " one flag at a time, least significant set bit first."]
	#[doc = ""]
	#[doc = " @param[in]   mask    mask of flags to wait for"]
	#[doc = ""]
	#[doc = " @returns     flag that triggered the return / wait"]
	pub fn thread_flags_wait_one(mask: thread_flags_t) -> thread_flags_t;
}
extern "C" {
	#[doc = " @brief Possibly Wake up thread waiting for flags"]
	#[doc = ""]
	#[doc = " Wakes up a thread if it is thread flag blocked and its condition is met."]
	#[doc = " Has to be called with interrupts disabled."]
	#[doc = " Does not trigger yield."]
	#[doc = ""]
	#[doc = " @internal"]
	#[doc = ""]
	#[doc = " @param[in]   thread  thread to possibly wake up"]
	#[doc = " @return      1       if @p thread has been woken up"]
	#[doc = "              0       otherwise"]
	pub fn thread_flags_wake(thread: *mut thread_t) -> ::core::ffi::c_int;
}
#[doc = " @brief   event structure"]
pub type event_t = event;
#[doc = " @brief   event handler type definition"]
pub type event_handler_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut event_t)>;
#[doc = " @brief   event structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event {
	#[doc = "< event queue list entry"]
	pub list_node: clist_node_t,
	#[doc = "< pointer to event handler function"]
	pub handler: event_handler_t,
}
#[doc = " @brief   event queue structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_queue_t {
	#[doc = "< list of queued events"]
	pub event_list: clist_node_t,
	#[doc = "< thread owning event queue"]
	pub waiter: *mut thread_t,
}
extern "C" {
	#[doc = " @brief   Queue an event"]
	#[doc = ""]
	#[doc = " The given event will be posted on the given @p queue. If the event is already"]
	#[doc = " queued when calling this function, the event will not be touched and remain"]
	#[doc = " in the previous position on the queue. So reposting an event while it is"]
	#[doc = " already on the queue will have no effect."]
	#[doc = ""]
	#[doc = " @param[in]   queue   event queue to queue event in"]
	#[doc = " @param[in]   event   event to queue in event queue"]
	pub fn event_post(queue: *mut event_queue_t, event: *mut event_t);
}
extern "C" {
	#[doc = " @brief   Cancel a queued event"]
	#[doc = ""]
	#[doc = " This will remove a queued event from an event queue."]
	#[doc = ""]
	#[doc = " @note    Due to the underlying list implementation, this will run in O(n)."]
	#[doc = ""]
	#[doc = " @param[in]   queue   event queue to remove event from"]
	#[doc = " @param[in]   event   event to remove from queue"]
	pub fn event_cancel(queue: *mut event_queue_t, event: *mut event_t);
}
extern "C" {
	#[doc = " @brief   Get next event from event queue, non-blocking"]
	#[doc = ""]
	#[doc = " In order to handle an event retrieved using this function,"]
	#[doc = " call event->handler(event)."]
	#[doc = ""]
	#[doc = " @param[in]   queue   event queue to get event from"]
	#[doc = ""]
	#[doc = " @returns     pointer to next event"]
	#[doc = " @returns     NULL if no event available"]
	pub fn event_get(queue: *mut event_queue_t) -> *mut event_t;
}
extern "C" {
	#[doc = " @brief   Get next event from the given event queues, blocking"]
	#[doc = ""]
	#[doc = " This function will block until an event becomes available. If more than one"]
	#[doc = " queue contains an event, the queue with the lowest index is chosen. Thus,"]
	#[doc = " a lower index in the @p queues array translates into a higher priority of"]
	#[doc = " the queue."]
	#[doc = ""]
	#[doc = " In order to handle an event retrieved using this function,"]
	#[doc = " call event->handler(event)."]
	#[doc = ""]
	#[doc = " @warning There can only be a single waiter on a queue!"]
	#[doc = ""]
	#[doc = " @note    This function *can* be suitable for having a single thread"]
	#[doc = "          handling both real-time and non-real-time events. However, a real"]
	#[doc = "          time event can be delayed for the whole duration a single"]
	#[doc = "          non-real-time event takes (in addition to all other sources of"]
	#[doc = "          latency). Thus, the slowest to handle non-real-time event must still"]
	#[doc = "          execute fast enough to add an amount of latency (on top of other"]
	#[doc = "          sources of latency) that is acceptable to the real-time event with"]
	#[doc = "          the strictest requirements."]
	#[doc = ""]
	#[doc = " @pre     0 < @p n_queues (expect blowing `assert()` otherwise)"]
	#[doc = ""]
	#[doc = " @param[in]   queues      Array of event queues to get event from"]
	#[doc = " @param[in]   n_queues    Number of event queues passed in @p queues"]
	#[doc = ""]
	#[doc = " @returns     pointer to next event"]
	pub fn event_wait_multi(queues: *mut event_queue_t, n_queues: usize) -> *mut event_t;
}
#[doc = " @brief Callback Event structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_callback_t {
	#[doc = "< event_t structure that gets extended"]
	pub super_: event_t,
	#[doc = "< callback function"]
	pub callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
	#[doc = "< callback function argument"]
	pub arg: *mut ::core::ffi::c_void,
}
extern "C" {
	#[doc = " @brief   event callback initialization function"]
	#[doc = ""]
	#[doc = " @param[out]  event_callback  object to initialize"]
	#[doc = " @param[in]   callback        callback to set up"]
	#[doc = " @param[in]   arg             callback argument to set up"]
	pub fn event_callback_init(
		event_callback: *mut event_callback_t,
		callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
		arg: *mut ::core::ffi::c_void,
	);
}
extern "C" {
	#[doc = " @brief   event callback handler function (used internally)"]
	#[doc = ""]
	#[doc = " @internal"]
	#[doc = ""]
	#[doc = " @param[in]   event   callback event to process"]
	pub fn _event_callback_handler(event: *mut event_t);
}
#[doc = " @brief Mutex structure. Must never be modified by the user."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mutex_t {
	#[doc = " @brief   The process waiting queue of the mutex. **Must never be changed"]
	#[doc = "          by the user.**"]
	#[doc = " @internal"]
	pub queue: list_node_t,
}
#[doc = " @brief   A cancellation structure for use with @ref mutex_lock_cancelable"]
#[doc = "          and @ref mutex_cancel"]
#[doc = ""]
#[doc = " @note    The contents of this structure are internal."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mutex_cancel_t {
	#[doc = "< The mutex to lock"]
	pub mutex: *mut mutex_t,
	#[doc = "< The thread trying to lock the mutex"]
	pub thread: *mut thread_t,
	#[doc = "< Flag whether the mutex has been cancelled"]
	pub cancelled: u8,
}
extern "C" {
	#[doc = " @brief   Tries to get a mutex, non-blocking."]
	#[doc = ""]
	#[doc = " @internal"]
	#[doc = " @note    This function is intended for use by languages incompatible"]
	#[doc = "          with C (such as C++). Code in C should use @ref mutex_trylock"]
	#[doc = "          instead"]
	#[doc = ""]
	#[doc = " @param[in,out]   mutex   Mutex object to lock."]
	#[doc = ""]
	#[doc = " @retval  1               if mutex was unlocked, now it is locked."]
	#[doc = " @retval  0               if the mutex was locked."]
	#[doc = ""]
	#[doc = " @pre     @p mutex is not `NULL`"]
	#[doc = " @pre     Mutex at @p mutex has been initialized"]
	#[doc = " @pre     Must be called in thread context"]
	pub fn mutex_trylock_ffi(mutex: *mut mutex_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Locks a mutex, blocking."]
	#[doc = ""]
	#[doc = " @param[in,out]   mutex   Mutex object to lock."]
	#[doc = ""]
	#[doc = " @pre     @p mutex is not `NULL`"]
	#[doc = " @pre     Mutex at @p mutex has been initialized"]
	#[doc = " @pre     Must be called in thread context"]
	#[doc = ""]
	#[doc = " @post    The mutex @p is locked and held by the calling thread."]
	pub fn mutex_lock(mutex: *mut mutex_t);
}
extern "C" {
	#[doc = " @brief   Locks a mutex, blocking. This function can be canceled."]
	#[doc = ""]
	#[doc = " @param[in,out]   mc      Mutex cancellation structure to work on"]
	#[doc = ""]
	#[doc = " @retval  0               The mutex was locked by the caller"]
	#[doc = " @retval  -ECANCELED      The mutex was ***NOT*** locked, operation was"]
	#[doc = "                          canceled. See @ref mutex_cancel"]
	#[doc = ""]
	#[doc = " @note    This function is considered internal. Out of tree users should be"]
	#[doc = "          aware that breaking API changes or removal of this API without"]
	#[doc = "          an deprecation period might happen."]
	#[doc = ""]
	#[doc = " @pre     Must be called in thread context"]
	#[doc = " @pre     @p mc has been initialized with @ref mutex_cancel_init by the"]
	#[doc = "          calling thread."]
	#[doc = " @pre     @p mc has ***NOT*** been used for previous calls to"]
	#[doc = "          this function. (Reinitialize before reusing!)"]
	#[doc = ""]
	#[doc = " @post    The mutex referred to by @p mc is locked and held by the calling"]
	#[doc = "          thread, unless `-ECANCELED` was returned."]
	pub fn mutex_lock_cancelable(mc: *mut mutex_cancel_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Unlocks the mutex."]
	#[doc = ""]
	#[doc = " @param[in,out]   mutex   Mutex object to unlock."]
	#[doc = ""]
	#[doc = " @pre     @p mutex is not `NULL`"]
	#[doc = " @note    It is safe to unlock a mutex held by a different thread."]
	#[doc = " @note    It is safe to call this function from IRQ context."]
	pub fn mutex_unlock(mutex: *mut mutex_t);
}
extern "C" {
	#[doc = " @brief   Unlocks the mutex and sends the current thread to sleep"]
	#[doc = ""]
	#[doc = " @param[in,out]   mutex   Mutex object to unlock."]
	#[doc = " @pre     @p mutex is not `NULL`"]
	#[doc = " @pre     Must be called in thread context."]
	pub fn mutex_unlock_and_sleep(mutex: *mut mutex_t);
}
extern "C" {
	#[doc = " @brief   Cancels a call to @ref mutex_lock_cancelable"]
	#[doc = ""]
	#[doc = " @param[in,out]   mc      Mutex cancellation structure referring to the"]
	#[doc = "                          thread calling @ref mutex_lock_cancelable and to"]
	#[doc = "                          the mutex to cancel the operation on"]
	#[doc = ""]
	#[doc = " @note    This function is considered internal. Out of tree users should be"]
	#[doc = "          aware that breaking API changes or removal of this API without"]
	#[doc = "          an deprecation period might happen."]
	#[doc = ""]
	#[doc = " @pre     @p mc is used to cancel at most one call to"]
	#[doc = "          @ref mutex_lock_cancelable. (You can reinitialize the same memory"]
	#[doc = "          to safely reuse it.)"]
	#[doc = " @warning You ***MUST NOT*** call this function once the thread referred to by"]
	#[doc = "          @p mc re-uses the mutex object referred to by @p mc (not counting"]
	#[doc = "          the call to @ref mutex_lock_cancelable @p mc was used in)."]
	#[doc = " @note    It is safe to call this function from IRQ context, e.g. from a timer"]
	#[doc = "          interrupt."]
	#[doc = " @note    It is safe to call this function more than once on the same @p mc"]
	#[doc = "          while it is still valid (see the warning above). The first call will"]
	#[doc = "          cancel the operation and subsequent calls will have no effect."]
	#[doc = ""]
	#[doc = " @details If @p thread is currently running (or pending), a subsequent call"]
	#[doc = "          from @p thread to @ref mutex_lock_cancelable will also fail"]
	#[doc = ""]
	#[doc = " Canonical use:"]
	#[doc = ""]
	#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}"]
	#[doc = " static void timeout_cb(void *arg) {"]
	#[doc = "     mutex_cancel(arg);"]
	#[doc = " }"]
	#[doc = ""]
	#[doc = " int ztimer_mutex_lock_timeout(ztimer_clock_t *clock, mutex_t *mutex,"]
	#[doc = "                               uint32_t timeout)"]
	#[doc = " {"]
	#[doc = "     mutex_cancel_t mc = mutex_cancel_init(mutex);"]
	#[doc = "     ztimer_t t = { .callback = timeout_cb, .arg = &mc };"]
	#[doc = "     ztimer_set(clock, &t, timeout);"]
	#[doc = "     if (mutex_lock_cancelable(&mc)) {"]
	#[doc = "         return -ECANCELED;"]
	#[doc = "     }"]
	#[doc = "     ztimer_remove(clock, &t);"]
	#[doc = "     return 0;"]
	#[doc = " }"]
	#[doc = " ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"]
	#[doc = ""]
	#[doc = " In the above example a simple implementation of how to implement mutex"]
	#[doc = " locking with a timeout is given. There are two corner cases:"]
	#[doc = ""]
	#[doc = " 1. The call to @ref mutex_cancel could occur *before* the call to"]
	#[doc = "    @ref mutex_lock_cancelable. (E.g. for `timeout == 0`.)"]
	#[doc = " 2. The call to @ref mutex_cancel could occur right after the mutex was"]
	#[doc = "    *successfully* obtained, but before `ztimer_remove()` was executed."]
	#[doc = ""]
	#[doc = " In the first corner case the cancellation is stored in @p mc. Hence, the"]
	#[doc = " subsequent call to @ref mutex_lock_cancelable gets indeed canceled. In the"]
	#[doc = " second corner case the cancellation is also stored in @p mc but never used -"]
	#[doc = " the mutex cancellation structure @p mc is not allowed to be reused without"]
	#[doc = " reinitialization."]
	pub fn mutex_cancel(mc: *mut mutex_cancel_t);
}
#[doc = " @brief Mutex structure. Must never be modified by the user."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmutex_t {
	#[doc = " @brief The mutex used for locking. **Must never be changed by"]
	#[doc = "        the user.**"]
	#[doc = " @internal"]
	pub mutex: mutex_t,
	#[doc = " @brief   Number of locks owned by the thread owner"]
	#[doc = " @internal"]
	pub refcount: u16,
	#[doc = " @brief   Owner thread of the mutex."]
	#[doc = " @details Owner is written by the mutex holder, and read"]
	#[doc = "          concurrently to ensure consistency,"]
	#[doc = "          atomic_int_least16_t is used. Note @ref kernel_pid_t is an int16"]
	#[doc = " @internal"]
	pub owner: kernel_pid_t,
}
extern "C" {
	#[doc = " @brief Tries to get a recursive mutex, non-blocking."]
	#[doc = ""]
	#[doc = " @param[in] rmutex Recursive mutex object to lock. Has to be"]
	#[doc = "                  initialized first. Must not be NULL."]
	#[doc = ""]
	#[doc = " @return 1 if mutex was unlocked, now it is locked."]
	#[doc = " @return 0 if the mutex was locked."]
	pub fn rmutex_trylock(rmutex: *mut rmutex_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief Locks a recursive mutex, blocking."]
	#[doc = ""]
	#[doc = " @param[in] rmutex Recursive mutex object to lock. Has to be"]
	#[doc = "                 initialized first. Must not be NULL."]
	pub fn rmutex_lock(rmutex: *mut rmutex_t);
}
extern "C" {
	#[doc = " @brief Unlocks the recursive mutex."]
	#[doc = ""]
	#[doc = " @param[in] rmutex Recursive mutex object to unlock, must not be NULL."]
	pub fn rmutex_unlock(rmutex: *mut rmutex_t);
}
#[doc = " @brief   Minimum information for each timer"]
pub type ztimer_base_t = ztimer_base;
#[doc = " @brief   ztimer device structure"]
pub type ztimer_clock_t = ztimer_clock;
#[doc = " @brief Type of callbacks in @ref ztimer_t \"timers\""]
pub type ztimer_callback_t =
	::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
#[doc = " @brief   Minimum information for each timer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ztimer_base {
	#[doc = "< next timer in list"]
	pub next: *mut ztimer_base_t,
	#[doc = "< offset from last timer in list"]
	pub offset: u32,
}
pub type ztimer_now_t = u32;
#[doc = " @brief   ztimer structure"]
#[doc = ""]
#[doc = " This type represents an instance of a timer, which is set on an"]
#[doc = " underlying clock object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ztimer_t {
	#[doc = "< clock list entry"]
	pub base: ztimer_base_t,
	#[doc = "< timer callback function pointer"]
	pub callback: ztimer_callback_t,
	#[doc = "< timer callback argument"]
	pub arg: *mut ::core::ffi::c_void,
}
#[doc = " @brief   ztimer backend method structure"]
#[doc = ""]
#[doc = " This table contains pointers to the virtual methods for a ztimer clock."]
#[doc = ""]
#[doc = " These functions used by ztimer core to interact with the underlying clock."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ztimer_ops_t {
	#[doc = " @brief   Set a new timer target"]
	#[doc = " @param   clock       ztimer clock to set the new target"]
	#[doc = " @param   val         Relative target (e.g. fire at value `now() + val`)"]
	pub set: ::core::option::Option<unsafe extern "C" fn(clock: *mut ztimer_clock_t, val: u32)>,
	#[doc = " @brief   Get the current count of the timer"]
	#[doc = " @param   clock       ztimer clock to get the current time from"]
	pub now: ::core::option::Option<unsafe extern "C" fn(clock: *mut ztimer_clock_t) -> u32>,
	#[doc = " @brief   Cancel any set target"]
	#[doc = " @param   clock       ztimer clock to cancel a pending alarm, if any"]
	pub cancel: ::core::option::Option<unsafe extern "C" fn(clock: *mut ztimer_clock_t)>,
}
#[doc = " @brief   ztimer device structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ztimer_clock {
	#[doc = "< list of active timers"]
	pub list: ztimer_base_t,
	#[doc = "< pointer to methods structure"]
	pub ops: *const ztimer_ops_t,
	#[doc = "< last timer in queue, for _is_set()"]
	pub last: *mut ztimer_base_t,
	#[doc = "< will be subtracted on every set()"]
	pub adjust_set: u16,
	#[doc = "< will be subtracted on every sleep(),"]
	#[doc = "in addition to adjust_set"]
	pub adjust_sleep: u16,
}
extern "C" {
	#[doc = " @brief   main ztimer callback handler"]
	#[doc = ""]
	#[doc = " This gets called by clock implementations, and must only be called by them"]
	#[doc = " with interrupts disabled."]
	pub fn ztimer_handler(clock: *mut ztimer_clock_t);
}
extern "C" {
	#[doc = " @brief   Set a timer on a clock"]
	#[doc = ""]
	#[doc = " This will place @p timer in the timer targets queue of @p clock."]
	#[doc = ""]
	#[doc = " @note The memory pointed to by @p timer is not copied and must"]
	#[doc = "       remain in scope until the callback is fired or the timer"]
	#[doc = "       is removed via @ref ztimer_remove"]
	#[doc = ""]
	#[doc = " @param[in]   clock       ztimer clock to operate on"]
	#[doc = " @param[in]   timer       timer entry to set"]
	#[doc = " @param[in]   val         timer target (relative ticks from now)"]
	#[doc = ""]
	#[doc = " @return The value of @ref ztimer_now() that @p timer was set against"]
	#[doc = "         (`now() + @p val = absolute trigger time`)."]
	pub fn ztimer_set(clock: *mut ztimer_clock_t, timer: *mut ztimer_t, val: u32) -> u32;
}
extern "C" {
	#[doc = " @brief   Check if a timer is currently active"]
	#[doc = ""]
	#[doc = " @param[in]   clock       ztimer clock to operate on"]
	#[doc = " @param[in]   timer       timer to check"]
	#[doc = ""]
	#[doc = " @return  > 0 if timer is active"]
	#[doc = " @return 0 if timer is not active"]
	pub fn ztimer_is_set(
		clock: *const ztimer_clock_t,
		timer: *const ztimer_t,
	) -> ::core::ffi::c_uint;
}
extern "C" {
	#[doc = " @brief   Remove a timer from a clock"]
	#[doc = ""]
	#[doc = " This will place @p timer in the timer targets queue for @p clock."]
	#[doc = ""]
	#[doc = " This function does nothing if @p timer is not found in the timer queue of"]
	#[doc = " @p clock."]
	#[doc = ""]
	#[doc = " @param[in]   clock       ztimer clock to operate on"]
	#[doc = " @param[in]   timer       timer entry to remove"]
	#[doc = ""]
	#[doc = " @retval  true    The timer was removed (and thus its callback neither was nor"]
	#[doc = "                  will be called by ztimer)."]
	#[doc = " @retval  false   The timer fired previously or is not set on the @p clock"]
	#[doc = "                  at all."]
	#[doc = ""]
	pub fn ztimer_remove(clock: *mut ztimer_clock_t, timer: *mut ztimer_t) -> bool;
}
extern "C" {
	#[doc = " @brief   Post a message after a delay"]
	#[doc = ""]
	#[doc = " This function sets a timer that will send a message @p offset ticks"]
	#[doc = " from now."]
	#[doc = ""]
	#[doc = " @note The memory pointed to by @p timer and @p msg will not be copied, i.e."]
	#[doc = "       `*timer` and `*msg` needs to remain valid until the timer has triggered."]
	#[doc = ""]
	#[doc = " @param[in]   clock           ztimer clock to operate on"]
	#[doc = " @param[in]   timer           ztimer timer struct to use"]
	#[doc = " @param[in]   offset          ticks from now"]
	#[doc = " @param[in]   msg             pointer to msg that will be sent"]
	#[doc = " @param[in]   target_pid      pid the message will be sent to"]
	pub fn ztimer_set_msg(
		clock: *mut ztimer_clock_t,
		timer: *mut ztimer_t,
		offset: u32,
		msg: *mut msg_t,
		target_pid: kernel_pid_t,
	);
}
extern "C" {
	#[doc = " @brief receive a message (blocking, with timeout)"]
	#[doc = ""]
	#[doc = " Similar to msg_receive(), but with a timeout parameter."]
	#[doc = " The function will return after waiting at most @p timeout ticks."]
	#[doc = ""]
	#[doc = " @note: This might function might leave a message with type MSG_ZTIMER in the"]
	#[doc = "        thread's message queue, which must be handled (ignored)."]
	#[doc = ""]
	#[doc = " @param[in]   clock           ztimer clock to operate on"]
	#[doc = " @param[out]  msg             pointer to buffer which will be filled if a"]
	#[doc = "                              message is received"]
	#[doc = " @param[in]   timeout         relative timeout, in @p clock time units"]
	#[doc = ""]
	#[doc = " @return  >=0 if a message was received"]
	#[doc = " @return  -ETIME on timeout"]
	pub fn ztimer_msg_receive_timeout(
		clock: *mut ztimer_clock_t,
		msg: *mut msg_t,
		timeout: u32,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief ztimer_now() for extending timers"]
	#[doc = ""]
	#[doc = " @internal"]
	#[doc = ""]
	#[doc = " @param[in]   clock          ztimer clock to operate on"]
	#[doc = " @return  Current count on the clock @p clock"]
	pub fn _ztimer_now_extend(clock: *mut ztimer_clock_t) -> ztimer_now_t;
}
extern "C" {
	#[doc = " @brief Suspend the calling thread until the time (@p last_wakeup + @p period)"]
	#[doc = ""]
	#[doc = " This function can be used to create periodic wakeups."]
	#[doc = ""]
	#[doc = " When the function returns, @p last_wakeup is set to"]
	#[doc = " (@p last_wakeup + @p period)."]
	#[doc = ""]
	#[doc = " @c last_wakeup should be set to ztimer_now(@p clock) before first call of the"]
	#[doc = " function."]
	#[doc = ""]
	#[doc = " If the time (@p last_wakeup + @p period) has already passed, the function"]
	#[doc = " sets @p last_wakeup to @p last_wakeup + @p period and returns immediately."]
	#[doc = ""]
	#[doc = " @param[in]   clock           ztimer clock to operate on"]
	#[doc = " @param[in]   last_wakeup     base time stamp for the wakeup"]
	#[doc = " @param[in]   period          time in ticks that will be added to @p last_wakeup"]
	pub fn ztimer_periodic_wakeup(clock: *mut ztimer_clock_t, last_wakeup: *mut u32, period: u32);
}
extern "C" {
	#[doc = " @brief   Put the calling thread to sleep for the specified number of ticks"]
	#[doc = ""]
	#[doc = " @param[in]   clock           ztimer clock to use"]
	#[doc = " @param[in]   duration        duration of sleep, in @p ztimer time units"]
	pub fn ztimer_sleep(clock: *mut ztimer_clock_t, duration: u32);
}
extern "C" {
	#[doc = " @brief Set a timer that wakes up a thread"]
	#[doc = ""]
	#[doc = " This function sets a timer that will wake up a thread when the timer has"]
	#[doc = " expired."]
	#[doc = ""]
	#[doc = " @param[in] clock         ztimer clock to operate on"]
	#[doc = " @param[in] timer         timer struct to work with."]
	#[doc = " @param[in] offset        clock ticks from now"]
	#[doc = " @param[in] pid           pid of the thread that will be woken up"]
	pub fn ztimer_set_wakeup(
		clock: *mut ztimer_clock_t,
		timer: *mut ztimer_t,
		offset: u32,
		pid: kernel_pid_t,
	);
}
extern "C" {
	#[doc = " @brief    Set timeout thread flag after @p timeout"]
	#[doc = ""]
	#[doc = " This function will set THREAD_FLAG_TIMEOUT on the current thread after @p"]
	#[doc = " timeout usec have passed."]
	#[doc = ""]
	#[doc = " @param[in]   clock           ztimer clock to operate on"]
	#[doc = " @param[in]   timer           timer struct to use"]
	#[doc = " @param[in]   timeout         timeout in ztimer_clock's ticks"]
	pub fn ztimer_set_timeout_flag(clock: *mut ztimer_clock_t, timer: *mut ztimer_t, timeout: u32);
}
extern "C" {
	#[doc = " @brief   Try to lock the given mutex, but give up after @p timeout"]
	#[doc = ""]
	#[doc = " @param[in]       clock       ztimer clock to operate on"]
	#[doc = " @param[in,out]   mutex       Mutex object to lock"]
	#[doc = " @param[in]       timeout     timeout after which to give up"]
	#[doc = ""]
	#[doc = " @retval  0               Success, caller has the mutex"]
	#[doc = " @retval  -ECANCELED      Failed to obtain mutex within @p timeout"]
	pub fn ztimer_mutex_lock_timeout(
		clock: *mut ztimer_clock_t,
		mutex: *mut mutex_t,
		timeout: u32,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Try to lock the given rmutex, but give up after @p timeout"]
	#[doc = ""]
	#[doc = " @param[in]       clock       ztimer clock to operate on"]
	#[doc = " @param[in,out]   rmutex      rmutex object to lock"]
	#[doc = " @param[in]       timeout     timeout after which to give up"]
	#[doc = ""]
	#[doc = " @retval  0               Success, caller has the rmutex"]
	#[doc = " @retval  -ECANCELED      Failed to obtain rmutex within @p timeout"]
	pub fn ztimer_rmutex_lock_timeout(
		clock: *mut ztimer_clock_t,
		rmutex: *mut rmutex_t,
		timeout: u32,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Initialize the board-specific default ztimer configuration"]
	pub fn ztimer_init();
}
extern "C" {
	#[doc = " @brief   Default ztimer microsecond clock"]
	pub static ZTIMER_USEC: *mut ztimer_clock_t;
}
extern "C" {
	#[doc = " @brief   Default ztimer millisecond clock"]
	pub static ZTIMER_MSEC: *mut ztimer_clock_t;
}
extern "C" {
	#[doc = " @brief   Default ztimer second clock"]
	pub static ZTIMER_SEC: *mut ztimer_clock_t;
}
extern "C" {
	#[doc = " @brief   Base ztimer for the microsecond clock (ZTIMER_USEC)"]
	#[doc = ""]
	#[doc = " This ztimer will reference the counter device object at the end of the"]
	#[doc = " chain of ztimer_clock_t for ZTIMER_USEC."]
	#[doc = ""]
	#[doc = " If the base counter device object's frequency (CONFIG_ZTIMER_USEC_BASE_FREQ)"]
	#[doc = " is not 1MHz then ZTIMER_USEC will be converted on top of this one. Otherwise"]
	#[doc = " they will reference the same ztimer_clock."]
	#[doc = ""]
	#[doc = " To avoid chained conversions its better to base new ztimer_clock on top of"]
	#[doc = " ZTIMER_USEC_BASE running at CONFIG_ZTIMER_USEC_BASE_FREQ."]
	#[doc = ""]
	pub static ZTIMER_USEC_BASE: *mut ztimer_clock_t;
}
extern "C" {
	#[doc = " @brief   Base ztimer for the millisecond clock (ZTIMER_MSEC)"]
	#[doc = ""]
	#[doc = " This ztimer will reference the counter device object at the end of the"]
	#[doc = " chain of ztimer_clock_t for ZTIMER_MSEC."]
	#[doc = ""]
	#[doc = " If ztimer_periph_rtt is not used then ZTIMER_MSEC_BASE will reference the"]
	#[doc = " same base as ZTIMER_USEC_BASE."]
	#[doc = ""]
	#[doc = " If the base counter device object's frequency (CONFIG_ZTIMER_MSEC_BASE_FREQ)"]
	#[doc = " is not 1KHz then ZTIMER_MSEC will be converted on top of this one. Otherwise"]
	#[doc = " they will reference the same ztimer_clock."]
	#[doc = ""]
	#[doc = " To avoid chained conversions its better to base new ztimer_clock on top of"]
	#[doc = " ZTIMER_MSEC_BASE running at CONFIG_ZTIMER_MSEC_BASE_FREQ."]
	#[doc = ""]
	pub static ZTIMER_MSEC_BASE: *mut ztimer_clock_t;
}
#[doc = " @brief   Timeout Event structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_timeout_t {
	#[doc = "< ztimer clock to use"]
	pub clock: *mut ztimer_clock_t,
	#[doc = "< ztimer object used for timeout"]
	pub timer: ztimer_t,
	#[doc = "< event queue to post event to"]
	pub queue: *mut event_queue_t,
	#[doc = "< event to post after timeout"]
	pub event: *mut event_t,
}
extern "C" {
	#[doc = " @brief   Initialize timeout event object"]
	#[doc = ""]
	#[doc = " @param[in]   event_timeout   event_timeout object to initialize"]
	#[doc = " @param[in]   clock           the clock backend, eg: ZTIMER_USEC, ZTIMER_MSEC"]
	#[doc = " @param[in]   queue           queue that the timed-out event will be added to"]
	#[doc = " @param[in]   event           event to add to queue after timeout"]
	pub fn event_timeout_ztimer_init(
		event_timeout: *mut event_timeout_t,
		clock: *mut ztimer_clock_t,
		queue: *mut event_queue_t,
		event: *mut event_t,
	);
}
extern "C" {
	#[doc = " @brief   Set a timeout"]
	#[doc = ""]
	#[doc = " This will make the event as configured in @p event_timeout be triggered"]
	#[doc = " after @p timeout microseconds (if using @ref xtimer) or the @ref"]
	#[doc = " ztimer_clock_t ticks."]
	#[doc = ""]
	#[doc = " @note: the used event_timeout struct must stay valid until after the timeout"]
	#[doc = "        event has been processed!"]
	#[doc = ""]
	#[doc = " @param[in]   event_timeout   event_timout context object to use"]
	#[doc = " @param[in]   timeout         timeout in microseconds or the ztimer_clock_t"]
	#[doc = "                              ticks units"]
	pub fn event_timeout_set(event_timeout: *mut event_timeout_t, timeout: u32);
}
extern "C" {
	#[doc = " @brief   Clear a timeout event"]
	#[doc = ""]
	#[doc = " Calling this function will cancel the timeout by removing its underlying"]
	#[doc = " timer. If the timer has already fired before calling this function, the"]
	#[doc = " connected event will be put already into the given event queue and this"]
	#[doc = " function does not have any effect."]
	#[doc = ""]
	#[doc = " @param[in]   event_timeout   event_timeout context object to use"]
	pub fn event_timeout_clear(event_timeout: *mut event_timeout_t);
}
#[doc = " @brief Unaligned access helper struct (uint16_t version)"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct uint16_una_t {
	#[doc = "< value"]
	pub val: u16,
}
#[doc = " @brief Unaligned access helper struct (uint32_t version)"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct uint32_una_t {
	#[doc = "< value"]
	pub val: u32,
}
#[doc = " @brief Unaligned access helper struct (uint64_t version)"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct uint64_una_t {
	#[doc = "< value"]
	pub val: u64,
}
#[doc = " @brief          A 16 bit integer in little endian."]
#[doc = " @details        This is a wrapper around an uint16_t to catch missing conversions"]
#[doc = "                 between different byte orders at compile time."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union le_uint16_t {
	#[doc = "< 16 bit representation"]
	pub u16_: u16,
	#[doc = "< 8 bit representation"]
	pub u8_: [u8; 2usize],
}
#[doc = " @brief          A 32 bit integer in little endian."]
#[doc = " @details        This is a wrapper around an uint32_t to catch missing conversions"]
#[doc = "                 between different byte orders at compile time."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union le_uint32_t {
	#[doc = "< 32 bit representation"]
	pub u32_: u32,
	#[doc = "< 8 bit representation"]
	pub u8_: [u8; 4usize],
	#[doc = "< 16 bit representation"]
	pub u16_: [u16; 2usize],
	#[doc = "< little endian 16 bit representation"]
	pub l16: [le_uint16_t; 2usize],
}
#[doc = " @brief          A 64 bit integer in little endian."]
#[doc = " @details        This is a wrapper around an uint64_t to catch missing conversions"]
#[doc = "                 between different byte orders at compile time."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union le_uint64_t {
	#[doc = "< 64 bit representation"]
	pub u64_: u64,
	#[doc = "< 8 bit representation"]
	pub u8_: [u8; 8usize],
	#[doc = "< 16 bit representation"]
	pub u16_: [u16; 4usize],
	#[doc = "< 32 bit representation"]
	pub u32_: [u32; 2usize],
	#[doc = "< little endian 16 bit representation"]
	pub l16: [le_uint16_t; 4usize],
	#[doc = "< little endian 32 bit representation"]
	pub l32: [le_uint32_t; 2usize],
}
#[doc = " @brief          A 16 bit integer in big endian aka network byte order."]
#[doc = " @details        This is a wrapper around an uint16_t to catch missing conversions"]
#[doc = "                 between different byte orders at compile time."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union be_uint16_t {
	#[doc = "< 16 bit representation"]
	pub u16_: u16,
	#[doc = "< 8 bit representation"]
	pub u8_: [u8; 2usize],
}
#[doc = " @brief          A 32 bit integer in big endian aka network byte order."]
#[doc = " @details        This is a wrapper around an uint32_t to catch missing conversions"]
#[doc = "                 between different byte orders at compile time."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union be_uint32_t {
	#[doc = "< 32 bit representation"]
	pub u32_: u32,
	#[doc = "< 8 bit representation"]
	pub u8_: [u8; 4usize],
	#[doc = "< 16 bit representation"]
	pub u16_: [u16; 2usize],
	#[doc = "< big endian 16 bit representation"]
	pub b16: [be_uint16_t; 2usize],
}
#[doc = " @brief          A 64 bit integer in big endian aka network byte order."]
#[doc = " @details        This is a wrapper around an uint64_t to catch missing conversions"]
#[doc = "                 between different byte orders at compile time."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union be_uint64_t {
	#[doc = "< 64 bit representation"]
	pub u64_: u64,
	#[doc = "< 8 bit representation"]
	pub u8_: [u8; 8usize],
	#[doc = "< 16 bit representation"]
	pub u16_: [u16; 4usize],
	#[doc = "< 32 bit representation"]
	pub u32_: [u32; 2usize],
	#[doc = "< big endian 16 bit representation"]
	pub b16: [be_uint16_t; 4usize],
	#[doc = "< big endian 32 bit representation"]
	pub b32: [be_uint32_t; 2usize],
}
#[doc = " @brief          A 16 bit integer in big endian aka network byte order."]
#[doc = " @details        This is a wrapper around an uint16_t to catch missing conversions"]
#[doc = "                 between different byte orders at compile time."]
pub type network_uint16_t = be_uint16_t;
#[doc = " @brief          A 32 bit integer in big endian aka network byte order."]
#[doc = " @details        This is a wrapper around an uint32_t to catch missing conversions"]
#[doc = "                 between different byte orders at compile time."]
pub type network_uint32_t = be_uint32_t;
#[doc = " @brief          A 64 bit integer in big endian aka network byte order."]
#[doc = " @details        This is a wrapper around an uint64_t to catch missing conversions"]
#[doc = "                 between different byte orders at compile time."]
pub type network_uint64_t = be_uint64_t;
#[doc = " @brief Data type to represent an IPv4 address."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ipv4_addr_t {
	#[doc = "< as 4 8-bit unsigned integer"]
	pub u8_: [u8; 4usize],
	#[doc = "< as 32-bit unsigned integer"]
	pub u32_: network_uint32_t,
}
extern "C" {
	#[doc = " @brief   Converts an IPv4 address to its string representation"]
	#[doc = ""]
	#[doc = " @param[out] result       The resulting string representation of at least"]
	#[doc = "                          @ref IPV4_ADDR_MAX_STR_LEN."]
	#[doc = " @param[in] addr          An IPv4 address"]
	#[doc = " @param[in] result_len    Length of @p result"]
	#[doc = ""]
	#[doc = " @return  @p result, on success"]
	#[doc = " @return  NULL, if @p result_len was lesser than IPV4_ADDR_MAX_STR_LEN"]
	#[doc = " @return  NULL, if @p result or @p addr was NULL"]
	pub fn ipv4_addr_to_str(
		result: *mut ::core::ffi::c_char,
		addr: *const ipv4_addr_t,
		result_len: u8,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	#[doc = " @brief   Converts an IPv4 address string representation to a byte-represented"]
	#[doc = "          IPv4 address"]
	#[doc = ""]
	#[doc = " @param[out] result    The resulting byte representation"]
	#[doc = " @param[in] addr       An IPv4 address string representation"]
	#[doc = ""]
	#[doc = " @return  @p result, on success"]
	#[doc = " @return  NULL, if @p addr was malformed"]
	#[doc = " @return  NULL, if @p result or @p addr was NULL"]
	pub fn ipv4_addr_from_str(
		result: *mut ipv4_addr_t,
		addr: *const ::core::ffi::c_char,
	) -> *mut ipv4_addr_t;
}
extern "C" {
	#[doc = " @brief   Converts an IPv4 address from a buffer of characters to a"]
	#[doc = "          byte-represented IPv4 address"]
	#[doc = ""]
	#[doc = " @note    @p addr_len should be between 0 and IPV4_ADDR_MAX_STR_LEN"]
	#[doc = ""]
	#[doc = " @param[out] result    The resulting byte representation"]
	#[doc = " @param[in] addr       An IPv4 address string representation"]
	#[doc = " @param[in] addr_len   The amount of characters to parse"]
	#[doc = ""]
	#[doc = " @return  @p result, on success"]
	#[doc = " @return  NULL, if @p addr was malformed"]
	#[doc = " @return  NULL, if @p result or @p addr was NULL"]
	pub fn ipv4_addr_from_buf(
		result: *mut ipv4_addr_t,
		addr: *const ::core::ffi::c_char,
		addr_len: usize,
	) -> *mut ipv4_addr_t;
}
#[doc = " @brief Data type to represent an IPv6 address."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ipv6_addr_t {
	#[doc = "< divided by 16 8-bit words."]
	pub u8_: [u8; 16usize],
	#[doc = "< divided by 8 16-bit words."]
	pub u16_: [network_uint16_t; 8usize],
	#[doc = "< divided by 4 32-bit words."]
	pub u32_: [network_uint32_t; 4usize],
	#[doc = "< divided by 2 64-bit words."]
	pub u64_: [network_uint64_t; 2usize],
}
extern "C" {
	#[doc = " @brief In-memory constants of defined addresses and prefixes"]
	#[doc = " @{"]
	#[doc = " @see @ref IPV6_ADDR_UNSPECIFIED"]
	pub static ipv6_addr_unspecified: ipv6_addr_t;
}
extern "C" {
	#[doc = " @see @ref IPV6_ADDR_LOOPBACK"]
	pub static ipv6_addr_loopback: ipv6_addr_t;
}
extern "C" {
	#[doc = " @see @ref IPV6_ADDR_LINK_LOCAL_PREFIX"]
	pub static ipv6_addr_link_local_prefix: ipv6_addr_t;
}
extern "C" {
	#[doc = " @see @ref IPV6_ADDR_ALL_NODES_IF_LOCAL"]
	pub static ipv6_addr_all_nodes_if_local: ipv6_addr_t;
}
extern "C" {
	#[doc = " @see @ref IPV6_ADDR_ALL_NODES_LINK_LOCAL"]
	pub static ipv6_addr_all_nodes_link_local: ipv6_addr_t;
}
extern "C" {
	#[doc = " @see @ref IPV6_ADDR_ALL_ROUTERS_IF_LOCAL"]
	pub static ipv6_addr_all_routers_if_local: ipv6_addr_t;
}
extern "C" {
	#[doc = " @see @ref IPV6_ADDR_ALL_ROUTERS_LINK_LOCAL"]
	pub static ipv6_addr_all_routers_link_local: ipv6_addr_t;
}
extern "C" {
	#[doc = " @see @ref IPV6_ADDR_ALL_ROUTERS_SITE_LOCAL"]
	pub static ipv6_addr_all_routers_site_local: ipv6_addr_t;
}
extern "C" {
	#[doc = " @see @ref IPV6_ADDR_SOLICITED_NODE_PREFIX"]
	pub static ipv6_addr_solicited_node_prefix: ipv6_addr_t;
}
extern "C" {
	#[doc = " @brief   Checks if two IPv6 addresses are equal."]
	#[doc = ""]
	#[doc = " @param[in] a     An IPv6 address."]
	#[doc = " @param[in] b     Another IPv6 address."]
	#[doc = ""]
	#[doc = " @return  true, if @p a and @p b are equal"]
	#[doc = " @return  false, otherwise."]
	pub fn ipv6_addr_equal(a: *const ipv6_addr_t, b: *const ipv6_addr_t) -> bool;
}
extern "C" {
	#[doc = " @brief   Checks up to which bit-count two IPv6 addresses match in their"]
	#[doc = "          prefix."]
	#[doc = ""]
	#[doc = " @param[in] a An IPv6 address."]
	#[doc = " @param[in] b Another IPv6 address."]
	#[doc = ""]
	#[doc = " @return  The number of bits @p a and @p b match in their prefix"]
	pub fn ipv6_addr_match_prefix(a: *const ipv6_addr_t, b: *const ipv6_addr_t) -> u8;
}
extern "C" {
	#[doc = " @brief   Sets IPv6 address @p out with the first @p bits taken"]
	#[doc = "          from @p prefix and leaves the remaining bits untouched."]
	#[doc = ""]
	#[doc = " @param[out]  out     Prefix to be set."]
	#[doc = " @param[in]   prefix  Address to take prefix from."]
	#[doc = " @param[in]   bits    Bits to be copied from @p prefix to @p out"]
	#[doc = "                      (set to 128 when greater than 128)."]
	pub fn ipv6_addr_init_prefix(out: *mut ipv6_addr_t, prefix: *const ipv6_addr_t, bits: u8);
}
extern "C" {
	#[doc = " @brief   Sets the last @p bits of IPv6 address @p out to @p iid."]
	#[doc = "          Leading bits of @p out stay untouched."]
	#[doc = ""]
	#[doc = " @param[out]  out     IPv6 address to be set."]
	#[doc = " @param[in]   iid     buffer representing the iid."]
	#[doc = " @param[in]   bits    Bits to be copied from @p iid to @p out"]
	#[doc = "                      (set to 128 when greater than 128)."]
	pub fn ipv6_addr_init_iid(out: *mut ipv6_addr_t, iid: *const u8, bits: u8);
}
extern "C" {
	#[doc = " @brief   Converts an IPv6 address to its string representation"]
	#[doc = ""]
	#[doc = " @see <a href=\"https://tools.ietf.org/html/rfc5952\">"]
	#[doc = "          RFC 5952"]
	#[doc = "      </a>"]
	#[doc = ""]
	#[doc = " @param[out] result       The resulting string representation of at least"]
	#[doc = "                          @ref IPV6_ADDR_MAX_STR_LEN"]
	#[doc = " @param[in] addr          An IPv6 address"]
	#[doc = " @param[in] result_len    Length of @p result"]
	#[doc = ""]
	#[doc = " @return  @p result, on success"]
	#[doc = " @return  NULL, if @p result_len was lesser than IPV6_ADDR_MAX_STR_LEN"]
	#[doc = " @return  NULL, if @p result or @p addr was NULL"]
	pub fn ipv6_addr_to_str(
		result: *mut ::core::ffi::c_char,
		addr: *const ipv6_addr_t,
		result_len: u8,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	#[doc = " @brief   Converts an IPv6 address string representation to a byte-represented"]
	#[doc = "          IPv6 address"]
	#[doc = ""]
	#[doc = " @see <a href=\"https://tools.ietf.org/html/rfc5952\">"]
	#[doc = "          RFC 5952"]
	#[doc = "      </a>"]
	#[doc = ""]
	#[doc = " @param[out] result    The resulting byte representation"]
	#[doc = " @param[in] addr       An IPv6 address string representation"]
	#[doc = ""]
	#[doc = " @return  @p result, on success"]
	#[doc = " @return  NULL, if @p addr was malformed"]
	#[doc = " @return  NULL, if @p result or @p addr was NULL"]
	pub fn ipv6_addr_from_str(
		result: *mut ipv6_addr_t,
		addr: *const ::core::ffi::c_char,
	) -> *mut ipv6_addr_t;
}
extern "C" {
	#[doc = " @brief   Converts an IPv6 address from a buffer of characters to a"]
	#[doc = "          byte-represented IPv6 address"]
	#[doc = ""]
	#[doc = " @see <a href=\"https://tools.ietf.org/html/rfc5952\">"]
	#[doc = "          RFC 5952"]
	#[doc = "      </a>"]
	#[doc = ""]
	#[doc = " @note    @p addr_len should be between 0 and IPV6_ADDR_MAX_STR_LEN"]
	#[doc = ""]
	#[doc = " @param[out] result    The resulting byte representation"]
	#[doc = " @param[in] addr       An IPv6 address string representation"]
	#[doc = " @param[in] addr_len   The amount of characters to parse"]
	#[doc = ""]
	#[doc = " @return  @p result, on success"]
	#[doc = " @return  NULL, if @p addr was malformed"]
	#[doc = " @return  NULL, if @p result or @p addr was NULL"]
	pub fn ipv6_addr_from_buf(
		result: *mut ipv6_addr_t,
		addr: *const ::core::ffi::c_char,
		addr_len: usize,
	) -> *mut ipv6_addr_t;
}
extern "C" {
	#[doc = " @brief split IPv6 address string representation and return remaining string"]
	#[doc = ""]
	#[doc = " Will change @p separator position in @p addr_str to '\\0'"]
	#[doc = ""]
	#[doc = " @param[in,out]   addr_str    Address to split"]
	#[doc = " @param[in]       separator   Separator char to use"]
	#[doc = ""]
	#[doc = " @return      string following the first occurrence of @p separator in"]
	#[doc = "              @p addr_str."]
	#[doc = " @return      NULL if @p separator was not found."]
	pub fn ipv6_addr_split_str(
		addr_str: *mut ::core::ffi::c_char,
		separator: ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	#[doc = " @brief split IPv6 address string representation"]
	#[doc = ""]
	#[doc = " @note Will change @p separator position in @p addr_str to '\\0'"]
	#[doc = ""]
	#[doc = " @param[in,out]   addr_str    Address to split"]
	#[doc = " @param[in]       separator   Separator char to use"]
	#[doc = " @param[in]       _default    Default value"]
	#[doc = ""]
	#[doc = " @return      atoi(string after split)"]
	#[doc = " @return      @p _default if no string after @p separator"]
	pub fn ipv6_addr_split_int(
		addr_str: *mut ::core::ffi::c_char,
		separator: ::core::ffi::c_char,
		_default: ::core::ffi::c_int,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief Print IPv6 address to stdout"]
	#[doc = ""]
	#[doc = " @param[in]   addr  Pointer to ipv6_addr_t to print"]
	pub fn ipv6_addr_print(addr: *const ipv6_addr_t);
}
extern "C" {
	pub fn __errno_location() -> *mut ::core::ffi::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
	pub quot: ::core::ffi::c_int,
	pub rem: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
	pub quot: ::core::ffi::c_long,
	pub rem: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
	pub quot: ::core::ffi::c_longlong,
	pub rem: ::core::ffi::c_longlong,
}
extern "C" {
	pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
	pub fn atof(__nptr: *const ::core::ffi::c_char) -> f64;
}
extern "C" {
	pub fn atoi(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn atol(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
	pub fn atoll(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_longlong;
}
extern "C" {
	pub fn strtod(
		__nptr: *const ::core::ffi::c_char,
		__endptr: *mut *mut ::core::ffi::c_char,
	) -> f64;
}
extern "C" {
	pub fn strtof(
		__nptr: *const ::core::ffi::c_char,
		__endptr: *mut *mut ::core::ffi::c_char,
	) -> f32;
}
extern "C" {
	pub fn strtold(
		__nptr: *const ::core::ffi::c_char,
		__endptr: *mut *mut ::core::ffi::c_char,
	) -> u128;
}
extern "C" {
	pub fn strtol(
		__nptr: *const ::core::ffi::c_char,
		__endptr: *mut *mut ::core::ffi::c_char,
		__base: ::core::ffi::c_int,
	) -> ::core::ffi::c_long;
}
extern "C" {
	pub fn strtoul(
		__nptr: *const ::core::ffi::c_char,
		__endptr: *mut *mut ::core::ffi::c_char,
		__base: ::core::ffi::c_int,
	) -> ::core::ffi::c_ulong;
}
extern "C" {
	pub fn strtoq(
		__nptr: *const ::core::ffi::c_char,
		__endptr: *mut *mut ::core::ffi::c_char,
		__base: ::core::ffi::c_int,
	) -> ::core::ffi::c_longlong;
}
extern "C" {
	pub fn strtouq(
		__nptr: *const ::core::ffi::c_char,
		__endptr: *mut *mut ::core::ffi::c_char,
		__base: ::core::ffi::c_int,
	) -> ::core::ffi::c_ulonglong;
}
extern "C" {
	pub fn strtoll(
		__nptr: *const ::core::ffi::c_char,
		__endptr: *mut *mut ::core::ffi::c_char,
		__base: ::core::ffi::c_int,
	) -> ::core::ffi::c_longlong;
}
extern "C" {
	pub fn strtoull(
		__nptr: *const ::core::ffi::c_char,
		__endptr: *mut *mut ::core::ffi::c_char,
		__base: ::core::ffi::c_int,
	) -> ::core::ffi::c_ulonglong;
}
extern "C" {
	pub fn l64a(__n: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn a64l(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::core::ffi::c_ulong;
pub type ushort = ::core::ffi::c_ushort;
pub type uint = ::core::ffi::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
	pub tv_sec: __time_t,
	pub tv_usec: __suseconds_t,
}
pub type suseconds_t = __suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
	pub tz_minuteswest: ::core::ffi::c_int,
	pub tz_dsttime: ::core::ffi::c_int,
}
extern "C" {
	pub fn gettimeofday(__tv: *mut timeval, __tz: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::core::ffi::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
	pub it_interval: timeval,
	pub it_value: timeval,
}
pub type __itimer_which_t = ::core::ffi::c_int;
extern "C" {
	pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn setitimer(
		__which: __itimer_which_t,
		__new: *const itimerval,
		__old: *mut itimerval,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn utimes(__file: *const ::core::ffi::c_char, __tvp: *const timeval) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn lutimes(__file: *const ::core::ffi::c_char, __tvp: *const timeval)
		-> ::core::ffi::c_int;
}
extern "C" {
	pub fn futimes(__fd: ::core::ffi::c_int, __tvp: *const timeval) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn bf_get_unset(field: *mut u8, len: usize) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
	pub fds: [u8; 2usize],
}
extern "C" {
	pub fn select(
		nfds: ::core::ffi::c_int,
		readfds: *mut fd_set,
		writefds: *mut fd_set,
		errorfds: *mut fd_set,
		timeout: *mut timeval,
	) -> ::core::ffi::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
	pub __value64: ::core::ffi::c_ulonglong,
	pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
	pub __low: ::core::ffi::c_uint,
	pub __high: ::core::ffi::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
	pub __prev: *mut __pthread_internal_list,
	pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
	pub __next: *mut __pthread_internal_slist,
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
	pub __lock: ::core::ffi::c_int,
	pub __count: ::core::ffi::c_uint,
	pub __owner: ::core::ffi::c_int,
	pub __nusers: ::core::ffi::c_uint,
	pub __kind: ::core::ffi::c_int,
	pub __spins: ::core::ffi::c_short,
	pub __elision: ::core::ffi::c_short,
	pub __list: __pthread_list_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
	pub __readers: ::core::ffi::c_uint,
	pub __writers: ::core::ffi::c_uint,
	pub __wrphase_futex: ::core::ffi::c_uint,
	pub __writers_futex: ::core::ffi::c_uint,
	pub __pad3: ::core::ffi::c_uint,
	pub __pad4: ::core::ffi::c_uint,
	pub __cur_writer: ::core::ffi::c_int,
	pub __shared: ::core::ffi::c_int,
	pub __rwelision: ::core::ffi::c_schar,
	pub __pad1: [::core::ffi::c_uchar; 7usize],
	pub __pad2: ::core::ffi::c_ulong,
	pub __flags: ::core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
	pub __wseq: __atomic_wide_counter,
	pub __g1_start: __atomic_wide_counter,
	pub __g_refs: [::core::ffi::c_uint; 2usize],
	pub __g_size: [::core::ffi::c_uint; 2usize],
	pub __g1_orig_size: ::core::ffi::c_uint,
	pub __wrefs: ::core::ffi::c_uint,
	pub __g_signals: [::core::ffi::c_uint; 2usize],
}
pub type __tss_t = ::core::ffi::c_uint;
pub type __thrd_t = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
	pub __data: ::core::ffi::c_int,
}
pub type pthread_t = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
	pub __size: [::core::ffi::c_char; 4usize],
	pub __align: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
	pub __size: [::core::ffi::c_char; 4usize],
	pub __align: ::core::ffi::c_int,
}
pub type pthread_key_t = ::core::ffi::c_uint;
pub type pthread_once_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
	pub __size: [::core::ffi::c_char; 56usize],
	pub __align: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
	pub __data: __pthread_mutex_s,
	pub __size: [::core::ffi::c_char; 40usize],
	pub __align: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
	pub __data: __pthread_cond_s,
	pub __size: [::core::ffi::c_char; 48usize],
	pub __align: ::core::ffi::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
	pub __data: __pthread_rwlock_arch_t,
	pub __size: [::core::ffi::c_char; 56usize],
	pub __align: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
	pub __size: [::core::ffi::c_char; 8usize],
	pub __align: ::core::ffi::c_long,
}
pub type pthread_spinlock_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
	pub __size: [::core::ffi::c_char; 32usize],
	pub __align: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
	pub __size: [::core::ffi::c_char; 4usize],
	pub __align: ::core::ffi::c_int,
}
extern "C" {
	pub fn random() -> ::core::ffi::c_long;
}
extern "C" {
	pub fn srandom(__seed: ::core::ffi::c_uint);
}
extern "C" {
	pub fn initstate(
		__seed: ::core::ffi::c_uint,
		__statebuf: *mut ::core::ffi::c_char,
		__statelen: usize,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn setstate(__statebuf: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
	pub fptr: *mut i32,
	pub rptr: *mut i32,
	pub state: *mut i32,
	pub rand_type: ::core::ffi::c_int,
	pub rand_deg: ::core::ffi::c_int,
	pub rand_sep: ::core::ffi::c_int,
	pub end_ptr: *mut i32,
}
extern "C" {
	pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn srandom_r(__seed: ::core::ffi::c_uint, __buf: *mut random_data) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn initstate_r(
		__seed: ::core::ffi::c_uint,
		__statebuf: *mut ::core::ffi::c_char,
		__statelen: usize,
		__buf: *mut random_data,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn setstate_r(
		__statebuf: *mut ::core::ffi::c_char,
		__buf: *mut random_data,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn rand() -> ::core::ffi::c_int;
}
extern "C" {
	pub fn srand(__seed: ::core::ffi::c_uint);
}
extern "C" {
	pub fn rand_r(__seed: *mut ::core::ffi::c_uint) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn drand48() -> f64;
}
extern "C" {
	pub fn erand48(__xsubi: *mut ::core::ffi::c_ushort) -> f64;
}
extern "C" {
	pub fn lrand48() -> ::core::ffi::c_long;
}
extern "C" {
	pub fn nrand48(__xsubi: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
	pub fn mrand48() -> ::core::ffi::c_long;
}
extern "C" {
	pub fn jrand48(__xsubi: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
	pub fn srand48(__seedval: ::core::ffi::c_long);
}
extern "C" {
	pub fn seed48(__seed16v: *mut ::core::ffi::c_ushort) -> *mut ::core::ffi::c_ushort;
}
extern "C" {
	pub fn lcong48(__param: *mut ::core::ffi::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
	pub __x: [::core::ffi::c_ushort; 3usize],
	pub __old_x: [::core::ffi::c_ushort; 3usize],
	pub __c: ::core::ffi::c_ushort,
	pub __init: ::core::ffi::c_ushort,
	pub __a: ::core::ffi::c_ulonglong,
}
extern "C" {
	pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn erand48_r(
		__xsubi: *mut ::core::ffi::c_ushort,
		__buffer: *mut drand48_data,
		__result: *mut f64,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn lrand48_r(
		__buffer: *mut drand48_data,
		__result: *mut ::core::ffi::c_long,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn nrand48_r(
		__xsubi: *mut ::core::ffi::c_ushort,
		__buffer: *mut drand48_data,
		__result: *mut ::core::ffi::c_long,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn mrand48_r(
		__buffer: *mut drand48_data,
		__result: *mut ::core::ffi::c_long,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn jrand48_r(
		__xsubi: *mut ::core::ffi::c_ushort,
		__buffer: *mut drand48_data,
		__result: *mut ::core::ffi::c_long,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn srand48_r(
		__seedval: ::core::ffi::c_long,
		__buffer: *mut drand48_data,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn seed48_r(
		__seed16v: *mut ::core::ffi::c_ushort,
		__buffer: *mut drand48_data,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn lcong48_r(
		__param: *mut ::core::ffi::c_ushort,
		__buffer: *mut drand48_data,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn arc4random() -> __uint32_t;
}
extern "C" {
	pub fn arc4random_buf(__buf: *mut ::core::ffi::c_void, __size: usize);
}
extern "C" {
	pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
	pub fn malloc(__size: ::core::ffi::c_ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn calloc(
		__nmemb: ::core::ffi::c_ulong,
		__size: ::core::ffi::c_ulong,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn realloc(
		__ptr: *mut ::core::ffi::c_void,
		__size: ::core::ffi::c_ulong,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn free(__ptr: *mut ::core::ffi::c_void);
}
extern "C" {
	pub fn reallocarray(
		__ptr: *mut ::core::ffi::c_void,
		__nmemb: usize,
		__size: usize,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn alloca(__size: ::core::ffi::c_ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn valloc(__size: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn posix_memalign(
		__memptr: *mut *mut ::core::ffi::c_void,
		__alignment: usize,
		__size: usize,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn aligned_alloc(
		__alignment: ::core::ffi::c_ulong,
		__size: ::core::ffi::c_ulong,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn abort() -> !;
}
extern "C" {
	pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn at_quick_exit(
		__func: ::core::option::Option<unsafe extern "C" fn()>,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn on_exit(
		__func: ::core::option::Option<
			unsafe extern "C" fn(__status: ::core::ffi::c_int, __arg: *mut ::core::ffi::c_void),
		>,
		__arg: *mut ::core::ffi::c_void,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
	pub fn quick_exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
	pub fn _Exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
	pub fn getenv(__name: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn putenv(__string: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn setenv(
		__name: *const ::core::ffi::c_char,
		__value: *const ::core::ffi::c_char,
		__replace: ::core::ffi::c_int,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn unsetenv(__name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn clearenv() -> ::core::ffi::c_int;
}
extern "C" {
	pub fn mktemp(__template: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn mkstemp(__template: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn mkstemps(
		__template: *mut ::core::ffi::c_char,
		__suffixlen: ::core::ffi::c_int,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn mkdtemp(__template: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn system(__command: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn realpath(
		__name: *const ::core::ffi::c_char,
		__resolved: *mut ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_char;
}
pub type __compar_fn_t = ::core::option::Option<
	unsafe extern "C" fn(
		arg1: *const ::core::ffi::c_void,
		arg2: *const ::core::ffi::c_void,
	) -> ::core::ffi::c_int,
>;
extern "C" {
	pub fn bsearch(
		__key: *const ::core::ffi::c_void,
		__base: *const ::core::ffi::c_void,
		__nmemb: usize,
		__size: usize,
		__compar: __compar_fn_t,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn qsort(
		__base: *mut ::core::ffi::c_void,
		__nmemb: usize,
		__size: usize,
		__compar: __compar_fn_t,
	);
}
extern "C" {
	pub fn abs(__x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn labs(__x: ::core::ffi::c_long) -> ::core::ffi::c_long;
}
extern "C" {
	pub fn llabs(__x: ::core::ffi::c_longlong) -> ::core::ffi::c_longlong;
}
extern "C" {
	pub fn div(__numer: ::core::ffi::c_int, __denom: ::core::ffi::c_int) -> div_t;
}
extern "C" {
	pub fn ldiv(__numer: ::core::ffi::c_long, __denom: ::core::ffi::c_long) -> ldiv_t;
}
extern "C" {
	pub fn lldiv(__numer: ::core::ffi::c_longlong, __denom: ::core::ffi::c_longlong) -> lldiv_t;
}
extern "C" {
	pub fn ecvt(
		__value: f64,
		__ndigit: ::core::ffi::c_int,
		__decpt: *mut ::core::ffi::c_int,
		__sign: *mut ::core::ffi::c_int,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn fcvt(
		__value: f64,
		__ndigit: ::core::ffi::c_int,
		__decpt: *mut ::core::ffi::c_int,
		__sign: *mut ::core::ffi::c_int,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn gcvt(
		__value: f64,
		__ndigit: ::core::ffi::c_int,
		__buf: *mut ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn qecvt(
		__value: u128,
		__ndigit: ::core::ffi::c_int,
		__decpt: *mut ::core::ffi::c_int,
		__sign: *mut ::core::ffi::c_int,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn qfcvt(
		__value: u128,
		__ndigit: ::core::ffi::c_int,
		__decpt: *mut ::core::ffi::c_int,
		__sign: *mut ::core::ffi::c_int,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn qgcvt(
		__value: u128,
		__ndigit: ::core::ffi::c_int,
		__buf: *mut ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn ecvt_r(
		__value: f64,
		__ndigit: ::core::ffi::c_int,
		__decpt: *mut ::core::ffi::c_int,
		__sign: *mut ::core::ffi::c_int,
		__buf: *mut ::core::ffi::c_char,
		__len: usize,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn fcvt_r(
		__value: f64,
		__ndigit: ::core::ffi::c_int,
		__decpt: *mut ::core::ffi::c_int,
		__sign: *mut ::core::ffi::c_int,
		__buf: *mut ::core::ffi::c_char,
		__len: usize,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn qecvt_r(
		__value: u128,
		__ndigit: ::core::ffi::c_int,
		__decpt: *mut ::core::ffi::c_int,
		__sign: *mut ::core::ffi::c_int,
		__buf: *mut ::core::ffi::c_char,
		__len: usize,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn qfcvt_r(
		__value: u128,
		__ndigit: ::core::ffi::c_int,
		__decpt: *mut ::core::ffi::c_int,
		__sign: *mut ::core::ffi::c_int,
		__buf: *mut ::core::ffi::c_char,
		__len: usize,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn mblen(__s: *const ::core::ffi::c_char, __n: usize) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn mbtowc(
		__pwc: *mut wchar_t,
		__s: *const ::core::ffi::c_char,
		__n: usize,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wctomb(__s: *mut ::core::ffi::c_char, __wchar: wchar_t) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::core::ffi::c_char, __n: usize) -> usize;
}
extern "C" {
	pub fn wcstombs(__s: *mut ::core::ffi::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
	pub fn rpmatch(__response: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn getsubopt(
		__optionp: *mut *mut ::core::ffi::c_char,
		__tokens: *const *mut ::core::ffi::c_char,
		__valuep: *mut *mut ::core::ffi::c_char,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn getloadavg(__loadavg: *mut f64, __nelem: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
	pub fn access(
		__name: *const ::core::ffi::c_char,
		__type: ::core::ffi::c_int,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn faccessat(
		__fd: ::core::ffi::c_int,
		__file: *const ::core::ffi::c_char,
		__type: ::core::ffi::c_int,
		__flag: ::core::ffi::c_int,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn lseek(
		__fd: ::core::ffi::c_int,
		__offset: __off_t,
		__whence: ::core::ffi::c_int,
	) -> __off_t;
}
extern "C" {
	pub fn close(__fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn closefrom(__lowfd: ::core::ffi::c_int);
}
extern "C" {
	pub fn read(
		__fd: ::core::ffi::c_int,
		__buf: *mut ::core::ffi::c_void,
		__nbytes: usize,
	) -> isize;
}
extern "C" {
	pub fn write(__fd: ::core::ffi::c_int, __buf: *const ::core::ffi::c_void, __n: usize) -> isize;
}
extern "C" {
	pub fn pread(
		__fd: ::core::ffi::c_int,
		__buf: *mut ::core::ffi::c_void,
		__nbytes: usize,
		__offset: __off_t,
	) -> isize;
}
extern "C" {
	pub fn pwrite(
		__fd: ::core::ffi::c_int,
		__buf: *const ::core::ffi::c_void,
		__n: usize,
		__offset: __off_t,
	) -> isize;
}
extern "C" {
	pub fn pipe(__pipedes: *mut ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn alarm(__seconds: ::core::ffi::c_uint) -> ::core::ffi::c_uint;
}
extern "C" {
	pub fn sleep(__seconds: ::core::ffi::c_uint) -> ::core::ffi::c_uint;
}
extern "C" {
	pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
	pub fn usleep(__useconds: __useconds_t) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn pause() -> ::core::ffi::c_int;
}
extern "C" {
	pub fn chown(
		__file: *const ::core::ffi::c_char,
		__owner: __uid_t,
		__group: __gid_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn fchown(
		__fd: ::core::ffi::c_int,
		__owner: __uid_t,
		__group: __gid_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn lchown(
		__file: *const ::core::ffi::c_char,
		__owner: __uid_t,
		__group: __gid_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn fchownat(
		__fd: ::core::ffi::c_int,
		__file: *const ::core::ffi::c_char,
		__owner: __uid_t,
		__group: __gid_t,
		__flag: ::core::ffi::c_int,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn chdir(__path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn fchdir(__fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn getcwd(__buf: *mut ::core::ffi::c_char, __size: usize) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn getwd(__buf: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn dup(__fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn dup2(__fd: ::core::ffi::c_int, __fd2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
	pub static mut __environ: *mut *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn execve(
		__path: *const ::core::ffi::c_char,
		__argv: *const *mut ::core::ffi::c_char,
		__envp: *const *mut ::core::ffi::c_char,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn fexecve(
		__fd: ::core::ffi::c_int,
		__argv: *const *mut ::core::ffi::c_char,
		__envp: *const *mut ::core::ffi::c_char,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn execv(
		__path: *const ::core::ffi::c_char,
		__argv: *const *mut ::core::ffi::c_char,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn execle(
		__path: *const ::core::ffi::c_char,
		__arg: *const ::core::ffi::c_char,
		...
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn execl(
		__path: *const ::core::ffi::c_char,
		__arg: *const ::core::ffi::c_char,
		...
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn execvp(
		__file: *const ::core::ffi::c_char,
		__argv: *const *mut ::core::ffi::c_char,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn execlp(
		__file: *const ::core::ffi::c_char,
		__arg: *const ::core::ffi::c_char,
		...
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn nice(__inc: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn _exit(__status: ::core::ffi::c_int) -> !;
}
pub const _PC_LINK_MAX: _bindgen_ty_1 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_1 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_1 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_1 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_1 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_1 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_1 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_1 = 7;
pub const _PC_VDISABLE: _bindgen_ty_1 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_1 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_1 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_1 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_1 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_1 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_1 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_1 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_1 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_1 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_1 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_1 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_1 = 20;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_2 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_2 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_2 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_2 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_2 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_2 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_2 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_2 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_2 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_2 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_2 = 10;
pub const _SC_TIMERS: _bindgen_ty_2 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_2 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_2 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_2 = 14;
pub const _SC_FSYNC: _bindgen_ty_2 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_2 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_2 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_2 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_2 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_2 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_2 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_2 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_2 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_2 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_2 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_2 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_2 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_2 = 28;
pub const _SC_VERSION: _bindgen_ty_2 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_2 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_2 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_2 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_2 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_2 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_2 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_2 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_2 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_2 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_2 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_2 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_2 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_2 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_2 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_2 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_2 = 45;
pub const _SC_2_VERSION: _bindgen_ty_2 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_2 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_2 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_2 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_2 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_2 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_2 = 52;
pub const _SC_PII: _bindgen_ty_2 = 53;
pub const _SC_PII_XTI: _bindgen_ty_2 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_2 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_2 = 56;
pub const _SC_PII_OSI: _bindgen_ty_2 = 57;
pub const _SC_POLL: _bindgen_ty_2 = 58;
pub const _SC_SELECT: _bindgen_ty_2 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_2 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_2 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_2 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_2 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_2 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_2 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_2 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_2 = 66;
pub const _SC_THREADS: _bindgen_ty_2 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_2 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_2 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_2 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_2 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_2 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_2 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_2 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_2 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_2 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_2 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_2 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_2 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_2 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_2 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_2 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_2 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_2 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_2 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_2 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_2 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_2 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_2 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_2 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_2 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_2 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_2 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_2 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_2 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_2 = 96;
pub const _SC_2_UPE: _bindgen_ty_2 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_2 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_2 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_2 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_2 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_2 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_2 = 103;
pub const _SC_INT_MAX: _bindgen_ty_2 = 104;
pub const _SC_INT_MIN: _bindgen_ty_2 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_2 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_2 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_2 = 108;
pub const _SC_NZERO: _bindgen_ty_2 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_2 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_2 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_2 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_2 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_2 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_2 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_2 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_2 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_2 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_2 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_2 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_2 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_2 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_2 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_2 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_2 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_2 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_2 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_2 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_2 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_2 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_2 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_2 = 132;
pub const _SC_BARRIERS: _bindgen_ty_2 = 133;
pub const _SC_BASE: _bindgen_ty_2 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_2 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_2 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_2 = 137;
pub const _SC_CPUTIME: _bindgen_ty_2 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_2 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_2 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_2 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_2 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_2 = 143;
pub const _SC_FIFO: _bindgen_ty_2 = 144;
pub const _SC_PIPE: _bindgen_ty_2 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_2 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_2 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_2 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_2 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_2 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_2 = 151;
pub const _SC_NETWORKING: _bindgen_ty_2 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_2 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_2 = 154;
pub const _SC_REGEXP: _bindgen_ty_2 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_2 = 156;
pub const _SC_SHELL: _bindgen_ty_2 = 157;
pub const _SC_SIGNALS: _bindgen_ty_2 = 158;
pub const _SC_SPAWN: _bindgen_ty_2 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_2 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_2 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_2 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_2 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_2 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_2 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_2 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_2 = 167;
pub const _SC_2_PBS: _bindgen_ty_2 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_2 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_2 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_2 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_2 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_2 = 173;
pub const _SC_STREAMS: _bindgen_ty_2 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_2 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_2 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_2 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_2 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_2 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_2 = 180;
pub const _SC_TRACE: _bindgen_ty_2 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_2 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_2 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_2 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_2 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_2 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_2 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_2 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_2 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_2 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_2 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_2 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_2 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_2 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_2 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_2 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_2 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_2 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_2 = 199;
pub const _SC_IPV6: _bindgen_ty_2 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_2 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_2 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_2 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_2 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_2 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_2 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_2 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_2 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_2 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_2 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_2 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_2 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_2 = 248;
pub const _SC_MINSIGSTKSZ: _bindgen_ty_2 = 249;
pub const _SC_SIGSTKSZ: _bindgen_ty_2 = 250;
pub type _bindgen_ty_2 = ::core::ffi::c_uint;
pub const _CS_PATH: _bindgen_ty_3 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_3 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_3 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_3 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_3 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_3 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_3 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_3 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_3 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_3 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_3 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_3 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_3 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_3 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_3 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_3 = 1149;
pub type _bindgen_ty_3 = ::core::ffi::c_uint;
extern "C" {
	pub fn pathconf(
		__path: *const ::core::ffi::c_char,
		__name: ::core::ffi::c_int,
	) -> ::core::ffi::c_long;
}
extern "C" {
	pub fn fpathconf(__fd: ::core::ffi::c_int, __name: ::core::ffi::c_int) -> ::core::ffi::c_long;
}
extern "C" {
	pub fn sysconf(__name: ::core::ffi::c_int) -> ::core::ffi::c_long;
}
extern "C" {
	pub fn confstr(
		__name: ::core::ffi::c_int,
		__buf: *mut ::core::ffi::c_char,
		__len: usize,
	) -> usize;
}
extern "C" {
	pub fn getpid() -> __pid_t;
}
extern "C" {
	pub fn getppid() -> __pid_t;
}
extern "C" {
	pub fn getpgrp() -> __pid_t;
}
extern "C" {
	pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
	pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
	pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn setpgrp() -> ::core::ffi::c_int;
}
extern "C" {
	pub fn setsid() -> __pid_t;
}
extern "C" {
	pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
	pub fn getuid() -> __uid_t;
}
extern "C" {
	pub fn geteuid() -> __uid_t;
}
extern "C" {
	pub fn getgid() -> __gid_t;
}
extern "C" {
	pub fn getegid() -> __gid_t;
}
extern "C" {
	pub fn getgroups(__size: ::core::ffi::c_int, __list: *mut __gid_t) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn setuid(__uid: __uid_t) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn seteuid(__uid: __uid_t) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn setgid(__gid: __gid_t) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn setegid(__gid: __gid_t) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn fork() -> __pid_t;
}
extern "C" {
	pub fn vfork() -> ::core::ffi::c_int;
}
extern "C" {
	pub fn ttyname(__fd: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn ttyname_r(
		__fd: ::core::ffi::c_int,
		__buf: *mut ::core::ffi::c_char,
		__buflen: usize,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn isatty(__fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn ttyslot() -> ::core::ffi::c_int;
}
extern "C" {
	pub fn link(
		__from: *const ::core::ffi::c_char,
		__to: *const ::core::ffi::c_char,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn linkat(
		__fromfd: ::core::ffi::c_int,
		__from: *const ::core::ffi::c_char,
		__tofd: ::core::ffi::c_int,
		__to: *const ::core::ffi::c_char,
		__flags: ::core::ffi::c_int,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn symlink(
		__from: *const ::core::ffi::c_char,
		__to: *const ::core::ffi::c_char,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn readlink(
		__path: *const ::core::ffi::c_char,
		__buf: *mut ::core::ffi::c_char,
		__len: usize,
	) -> isize;
}
extern "C" {
	pub fn symlinkat(
		__from: *const ::core::ffi::c_char,
		__tofd: ::core::ffi::c_int,
		__to: *const ::core::ffi::c_char,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn readlinkat(
		__fd: ::core::ffi::c_int,
		__path: *const ::core::ffi::c_char,
		__buf: *mut ::core::ffi::c_char,
		__len: usize,
	) -> isize;
}
extern "C" {
	pub fn unlink(__name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn unlinkat(
		__fd: ::core::ffi::c_int,
		__name: *const ::core::ffi::c_char,
		__flag: ::core::ffi::c_int,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn rmdir(__path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn tcgetpgrp(__fd: ::core::ffi::c_int) -> __pid_t;
}
extern "C" {
	pub fn tcsetpgrp(__fd: ::core::ffi::c_int, __pgrp_id: __pid_t) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn getlogin() -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn getlogin_r(__name: *mut ::core::ffi::c_char, __name_len: usize) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn setlogin(__name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub static mut optarg: *mut ::core::ffi::c_char;
}
extern "C" {
	pub static mut optind: ::core::ffi::c_int;
}
extern "C" {
	pub static mut opterr: ::core::ffi::c_int;
}
extern "C" {
	pub static mut optopt: ::core::ffi::c_int;
}
extern "C" {
	pub fn getopt(
		___argc: ::core::ffi::c_int,
		___argv: *const *mut ::core::ffi::c_char,
		__shortopts: *const ::core::ffi::c_char,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn gethostname(__name: *mut ::core::ffi::c_char, __len: usize) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn sethostname(__name: *const ::core::ffi::c_char, __len: usize) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn sethostid(__id: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn getdomainname(__name: *mut ::core::ffi::c_char, __len: usize) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn setdomainname(__name: *const ::core::ffi::c_char, __len: usize) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn vhangup() -> ::core::ffi::c_int;
}
extern "C" {
	pub fn revoke(__file: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn profil(
		__sample_buffer: *mut ::core::ffi::c_ushort,
		__size: usize,
		__offset: usize,
		__scale: ::core::ffi::c_uint,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn acct(__name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn getusershell() -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn endusershell();
}
extern "C" {
	pub fn setusershell();
}
extern "C" {
	pub fn daemon(
		__nochdir: ::core::ffi::c_int,
		__noclose: ::core::ffi::c_int,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn chroot(__path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn getpass(__prompt: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn fsync(__fd: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn gethostid() -> ::core::ffi::c_long;
}
extern "C" {
	pub fn sync();
}
extern "C" {
	pub fn getpagesize() -> ::core::ffi::c_int;
}
extern "C" {
	pub fn getdtablesize() -> ::core::ffi::c_int;
}
extern "C" {
	pub fn truncate(__file: *const ::core::ffi::c_char, __length: __off_t) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn ftruncate(__fd: ::core::ffi::c_int, __length: __off_t) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn brk(__addr: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn sbrk(__delta: isize) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn syscall(__sysno: ::core::ffi::c_long, ...) -> ::core::ffi::c_long;
}
extern "C" {
	pub fn lockf(
		__fd: ::core::ffi::c_int,
		__cmd: ::core::ffi::c_int,
		__len: __off_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn fdatasync(__fildes: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn crypt(
		__key: *const ::core::ffi::c_char,
		__salt: *const ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	pub fn getentropy(__buffer: *mut ::core::ffi::c_void, __length: usize) -> ::core::ffi::c_int;
}
#[doc = " @brief   iolist structure definition"]
pub type iolist_t = iolist;
#[doc = " @brief   iolist structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iolist {
	#[doc = "< ptr to next list entry"]
	pub iol_next: *mut iolist_t,
	#[doc = "< ptr to this list entries data"]
	pub iol_base: *mut ::core::ffi::c_void,
	#[doc = "< size of data pointet to by ptr"]
	pub iol_len: usize,
}
extern "C" {
	#[doc = " @brief   Count number of entries in an iolist_t"]
	#[doc = ""]
	#[doc = " @param[in]   iolist  iolist to count"]
	#[doc = ""]
	#[doc = " @returns number of entries (zero for NULL parameter)"]
	pub fn iolist_count(iolist: *const iolist_t) -> ::core::ffi::c_uint;
}
extern "C" {
	#[doc = " @brief   Sum up number of bytes in iolist"]
	#[doc = ""]
	#[doc = " This function returns the summed ip length values of all entries in @p"]
	#[doc = " iolist."]
	#[doc = ""]
	#[doc = " @param[in]   iolist  iolist to sum up"]
	#[doc = ""]
	#[doc = " @returns summed up number of bytes or zero if @p iolist == NULL"]
	pub fn iolist_size(iolist: *const iolist_t) -> usize;
}
extern "C" {
	#[doc = " @brief   Create struct iovec from iolist"]
	#[doc = ""]
	#[doc = " This function fills an array of struct iovecs with the contents of @p"]
	#[doc = " iolist. It will write the number of used array entries into @p count."]
	#[doc = ""]
	#[doc = " The caller *must* ensure that @p iov p points to an array of size >= count!"]
	#[doc = ""]
	#[doc = " @param[in]   iolist  iolist to read from"]
	#[doc = " @param[out]  iov     ptr to array of struct iovec that will be filled"]
	#[doc = " @param[out]  count   number of elements in @p iolist"]
	#[doc = ""]
	#[doc = " @returns iolist_size(iolist)"]
	pub fn iolist_to_iovec(
		iolist: *const iolist_t,
		iov: *mut iovec,
		count: *mut ::core::ffi::c_uint,
	) -> usize;
}
#[doc = " @brief   Abstract IP end point and end point for a raw IP sock object"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sock_ip_ep_t {
	#[doc = " @brief family of sock_ip_ep_t::addr"]
	#[doc = ""]
	#[doc = " @see @ref net_af"]
	pub family: ::core::ffi::c_int,
	#[doc = "< address"]
	pub addr: sock_ip_ep_t__bindgen_ty_1,
	#[doc = " @brief   stack-specific network interface ID"]
	#[doc = ""]
	#[doc = " @todo    port to common network interface identifiers in PR #5511."]
	#[doc = ""]
	#[doc = " Use @ref SOCK_ADDR_ANY_NETIF for any interface."]
	#[doc = " For reception this is the local interface the message came over,"]
	#[doc = " for transmission, this is the local interface the message should be send"]
	#[doc = " over"]
	pub netif: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_ip_ep_t__bindgen_ty_1 {
	#[doc = "< IPv4 address mode"]
	pub ipv4: [u8; 4usize],
	#[doc = "< IPv4 address *in network byte order*"]
	pub ipv4_u32: u32,
}
#[doc = " @brief   Common IP-based transport layer end point"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _sock_tl_ep {
	#[doc = " @brief family of sock_ip_ep_t::addr"]
	#[doc = ""]
	#[doc = " @see @ref net_af"]
	pub family: ::core::ffi::c_int,
	#[doc = "< address"]
	pub addr: _sock_tl_ep__bindgen_ty_1,
	#[doc = " @brief   stack-specific network interface ID"]
	#[doc = ""]
	#[doc = " @todo    port to common network interface identifiers in PR #5511."]
	#[doc = ""]
	#[doc = " Use @ref SOCK_ADDR_ANY_NETIF for any interface."]
	#[doc = " For reception this is the local interface the message came over,"]
	#[doc = " for transmission, this is the local interface the message should be send"]
	#[doc = " over"]
	pub netif: u16,
	#[doc = "< transport layer port (in host byte order)"]
	pub port: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _sock_tl_ep__bindgen_ty_1 {
	#[doc = "< IPv4 address mode"]
	pub ipv4: [u8; 4usize],
	#[doc = "< IPv4 address *in network byte order*"]
	pub ipv4_u32: u32,
}
#[doc = " @brief   Flag to request the local address/endpoint"]
#[doc = ""]
#[doc = " @note    Select module `sock_aux_local` and a compatible network stack"]
#[doc = "          to use this"]
#[doc = ""]
#[doc = " This is the address/endpoint the packet/datagram/segment was received on."]
#[doc = " This flag will be cleared if the network stack stored the local"]
#[doc = " address/endpoint as requested, otherwise the bit remains set."]
#[doc = ""]
#[doc = " Depending on the family of the socket, the timestamp will be stored in"]
#[doc = " @ref sock_udp_aux_rx_t::local, @ref sock_ip_aux_rx_t::local, or in"]
#[doc = " @ref sock_dtls_aux_rx_t::local."]
pub const SOCK_AUX_GET_LOCAL: _bindgen_ty_4 = 1;
#[doc = " @brief   Flag to request the time stamp of transmission / reception"]
#[doc = ""]
#[doc = " @note    Select module `sock_aux_timestamp` and a compatible network"]
#[doc = "          stack to use this"]
#[doc = ""]
#[doc = " Unless otherwise noted, the time stamp is the current system time in"]
#[doc = " nanoseconds on which the start of frame delimiter or preamble was"]
#[doc = " sent / received."]
#[doc = ""]
#[doc = " Set this flag in the auxiliary data structure prior to the call of"]
#[doc = " @ref sock_udp_recv_aux / @ref sock_udp_send_aux / @ref sock_ip_recv_aux"]
#[doc = " / etc. to request the time stamp of reception / transmission. This flag"]
#[doc = " will be cleared if the timestamp was stored, otherwise it remains set."]
#[doc = ""]
#[doc = " Depending on the family of the socket, the timestamp will be stored in"]
#[doc = " for reception in @ref sock_udp_aux_rx_t::timestamp,"]
#[doc = " @ref sock_ip_aux_rx_t::timestamp, or @ref sock_dtls_aux_rx_t::timestamp."]
#[doc = " For transmission it will be stored in @ref sock_udp_aux_tx_t::timestamp,"]
#[doc = " @ref sock_ip_aux_tx_t::timestamp, or @ref sock_dtls_aux_tx_t::timestamp."]
pub const SOCK_AUX_GET_TIMESTAMP: _bindgen_ty_4 = 2;
#[doc = " @brief   Flag to request the RSSI value of received frame"]
#[doc = ""]
#[doc = " @note    Select module `sock_aux_rssi` and a compatible network stack to"]
#[doc = "          use this"]
#[doc = ""]
#[doc = " Set this flag in the auxiliary data structure prior to the call of"]
#[doc = " @ref sock_udp_recv_aux / @ref sock_ip_recv_aux / etc. to request the"]
#[doc = " RSSI value of a received frame. This flag will be cleared if the"]
#[doc = " timestamp was stored, otherwise it remains set."]
#[doc = ""]
#[doc = " Depending on the family of the socket, the RSSI value will be stored in"]
#[doc = " @ref sock_udp_aux_rx_t::rssi, @ref sock_ip_aux_rx_t::rssi, or"]
#[doc = " @ref sock_dtls_aux_rx_t::rssi."]
pub const SOCK_AUX_GET_RSSI: _bindgen_ty_4 = 4;
#[doc = " @brief   Flags used to request auxiliary data"]
pub type _bindgen_ty_4 = ::core::ffi::c_uint;
#[doc = " @brief   Type holding the flags used to request specific auxiliary data"]
#[doc = ""]
#[doc = " This is a bitmask of `SOCK_AUX_GET_...`, e.g. if the mask contains"]
#[doc = " @ref SOCK_AUX_GET_LOCAL, the local address/endpoint is requested"]
#[doc = ""]
#[doc = " @details The underlying type can be changed without further notice, if more"]
#[doc = "          flags are needed. Thus, only the `typedef`ed type should be used"]
#[doc = "          to store the flags."]
pub type sock_aux_flags_t = u8;
#[doc = " @brief   Common IP-based transport layer end point"]
pub type sock_udp_ep_t = _sock_tl_ep;
#[doc = " @brief   UDP sock type"]
#[doc = " @internal"]
pub type sock_udp_t = sock_udp;
#[doc = " @brief   Auxiliary data provided when receiving using an UDP sock object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_udp_aux_rx_t {
	#[doc = "< Flags used request information"]
	pub flags: sock_aux_flags_t,
}
#[doc = " @brief   Auxiliary data provided when sending using an UDP sock object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_udp_aux_tx_t {
	#[doc = "< Flags used request information"]
	pub flags: sock_aux_flags_t,
}
extern "C" {
	#[doc = " @brief   Creates a new UDP sock object"]
	#[doc = ""]
	#[doc = " @pre `(sock != NULL)`"]
	#[doc = " @pre `(remote == NULL) || (remote->port != 0)`"]
	#[doc = ""]
	#[doc = " @param[out] sock     The resulting sock object."]
	#[doc = " @param[in] local     Local end point for the sock object."]
	#[doc = "                      May be NULL."]
	#[doc = "                      sock_udp_ep_t::netif must either be"]
	#[doc = "                      @ref SOCK_ADDR_ANY_NETIF or equal to"]
	#[doc = "                      sock_udp_ep_t::netif of @p remote if `remote != NULL`."]
	#[doc = "                      If NULL @ref sock_udp_send() may bind implicitly."]
	#[doc = "                      sock_udp_ep_t::port may also be 0 to bind the `sock` to"]
	#[doc = "                      an ephemeral port."]
	#[doc = " @param[in] remote    Remote end point for the sock object."]
	#[doc = "                      May be `NULL` but then the `remote` parameter of"]
	#[doc = "                      @ref sock_udp_send() may not be `NULL` or it will"]
	#[doc = "                      always error with return value -ENOTCONN."]
	#[doc = "                      sock_udp_ep_t::port must not be 0 if `remote != NULL`."]
	#[doc = "                      sock_udp_ep_t::netif must either be"]
	#[doc = "                      @ref SOCK_ADDR_ANY_NETIF or equal to sock_udp_ep_t::netif"]
	#[doc = "                      of @p local if `local != NULL`."]
	#[doc = " @param[in] flags     Flags for the sock object. See also"]
	#[doc = "                      [sock flags](@ref net_sock_flags)."]
	#[doc = "                      May be 0."]
	#[doc = ""]
	#[doc = " @return  0 on success."]
	#[doc = " @return  -EADDRINUSE, if `local != NULL` and @p local is already used"]
	#[doc = "          elsewhere or if `local->port == 0` but the pool of ephemeral ports"]
	#[doc = "          is depleted"]
	#[doc = " @return  -EAFNOSUPPORT, if `local != NULL` or `remote != NULL` and"]
	#[doc = "          sock_udp_ep_t::family of @p local or @p remote is not supported."]
	#[doc = " @return  -EINVAL, if sock_udp_ep_t::addr of @p remote is an invalid address."]
	#[doc = " @return  -EINVAL, if sock_udp_ep_t::netif of @p local or @p remote are not a"]
	#[doc = "          valid interfaces or contradict each other (i.e."]
	#[doc = "          `(local->netif != remote->netif) &&"]
	#[doc = "          ((local->netif != SOCK_ADDR_ANY_NETIF) ||"]
	#[doc = "          (remote->netif != SOCK_ADDR_ANY_NETIF))` if neither is `NULL`)."]
	#[doc = " @return  -ENOMEM, if not enough resources can be provided for `sock` to be"]
	#[doc = "          created."]
	pub fn sock_udp_create(
		sock: *mut sock_udp_t,
		local: *const sock_udp_ep_t,
		remote: *const sock_udp_ep_t,
		flags: u16,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Closes a UDP sock object"]
	#[doc = ""]
	#[doc = " @pre `(sock != NULL)`"]
	#[doc = ""]
	#[doc = " @param[in] sock  A UDP sock object."]
	pub fn sock_udp_close(sock: *mut sock_udp_t);
}
extern "C" {
	#[doc = " @brief   Gets the local end point of a UDP sock object"]
	#[doc = ""]
	#[doc = " @pre `(sock != NULL) && (ep != NULL)`"]
	#[doc = ""]
	#[doc = " @param[in] sock  A UDP sock object."]
	#[doc = " @param[out] ep   The local end point."]
	#[doc = ""]
	#[doc = " @return  0 on success."]
	#[doc = " @return  -EADDRNOTAVAIL, when @p sock has no local end point."]
	pub fn sock_udp_get_local(sock: *mut sock_udp_t, ep: *mut sock_udp_ep_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Gets the remote end point of a UDP sock object"]
	#[doc = " @pre `(sock != NULL) && (ep != NULL)`"]
	#[doc = ""]
	#[doc = " @param[in] sock  A UDP sock object."]
	#[doc = " @param[out] ep   The remote end point."]
	#[doc = ""]
	#[doc = " @return  0 on success."]
	#[doc = " @return  -ENOTCONN, when @p sock has no remote end point bound to it."]
	pub fn sock_udp_get_remote(sock: *mut sock_udp_t, ep: *mut sock_udp_ep_t)
		-> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Receives a UDP message from a remote end point"]
	#[doc = ""]
	#[doc = " @pre `(sock != NULL) && (data != NULL) && (max_len > 0)`"]
	#[doc = ""]
	#[doc = " @param[in] sock      A UDP sock object."]
	#[doc = " @param[out] data     Pointer where the received data should be stored."]
	#[doc = " @param[in] max_len   Maximum space available at @p data."]
	#[doc = " @param[in] timeout   Timeout for receive in microseconds."]
	#[doc = "                      If 0 and no data is available, the function returns"]
	#[doc = "                      immediately."]
	#[doc = "                      May be @ref SOCK_NO_TIMEOUT for no timeout (wait until"]
	#[doc = "                      data is available)."]
	#[doc = " @param[out] remote   Remote end point of the received data."]
	#[doc = "                      May be `NULL`, if it is not required by the application."]
	#[doc = " @param[out] aux      Auxiliary data about the received datagram."]
	#[doc = "                      May be `NULL`, if it is not required by the application."]
	#[doc = ""]
	#[doc = " @note    Function blocks if no packet is currently waiting."]
	#[doc = ""]
	#[doc = " @return  The number of bytes received on success."]
	#[doc = " @return  0, if no received data is available, but everything is in order."]
	#[doc = " @return  -EADDRNOTAVAIL, if local of @p sock is not given."]
	#[doc = " @return  -EAGAIN, if @p timeout is `0` and no data is available."]
	#[doc = " @return  -EINVAL, if @p remote is invalid or @p sock is not properly"]
	#[doc = "          initialized (or closed while sock_udp_recv() blocks)."]
	#[doc = " @return  -ENOBUFS, if buffer space is not large enough to store received"]
	#[doc = "          data."]
	#[doc = " @return  -ENOMEM, if no memory was available to receive @p data."]
	#[doc = " @return  -EPROTO, if source address of received packet did not equal"]
	#[doc = "          the remote of @p sock."]
	#[doc = " @return  -ETIMEDOUT, if @p timeout expired."]
	pub fn sock_udp_recv_aux(
		sock: *mut sock_udp_t,
		data: *mut ::core::ffi::c_void,
		max_len: usize,
		timeout: u32,
		remote: *mut sock_udp_ep_t,
		aux: *mut sock_udp_aux_rx_t,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Provides stack-internal buffer space containing a UDP message from"]
	#[doc = "          a remote end point"]
	#[doc = ""]
	#[doc = " @pre `(sock != NULL) && (data != NULL) && (buf_ctx != NULL)`"]
	#[doc = ""]
	#[doc = " @param[in] sock      A UDP sock object."]
	#[doc = " @param[out] data     Pointer to a stack-internal buffer space containing the"]
	#[doc = "                      received data."]
	#[doc = " @param[in,out] buf_ctx  Stack-internal buffer context. If it points to a"]
	#[doc = "                      `NULL` pointer, the stack returns a new buffer space"]
	#[doc = "                      for a new packet. If it does not point to a `NULL`"]
	#[doc = "                      pointer, an existing context is assumed to get a next"]
	#[doc = "                      segment in a buffer."]
	#[doc = " @param[in] timeout   Timeout for receive in microseconds."]
	#[doc = "                      If 0 and no data is available, the function returns"]
	#[doc = "                      immediately."]
	#[doc = "                      May be @ref SOCK_NO_TIMEOUT for no timeout (wait until"]
	#[doc = "                      data is available)."]
	#[doc = " @param[out] remote   Remote end point of the received data."]
	#[doc = "                      May be `NULL`, if it is not required by the application."]
	#[doc = " @param[out] aux      Auxiliary data about the received datagram."]
	#[doc = "                      May be `NULL`, if it is not required by the application."]
	#[doc = ""]
	#[doc = " @experimental    This function is quite new, not implemented for all stacks"]
	#[doc = "                  yet, and may be subject to sudden API changes. Do not use in"]
	#[doc = "                  production if this is unacceptable."]
	#[doc = ""]
	#[doc = " @note    Function blocks if no packet is currently waiting."]
	#[doc = ""]
	#[doc = " @return  The number of bytes received on success. May not be the complete"]
	#[doc = "          payload. Continue calling with the returned `buf_ctx` to get more"]
	#[doc = "          buffers until result is 0 or an error."]
	#[doc = " @return  0, if no received data is available, but everything is in order."]
	#[doc = "          If @p buf_ctx was provided, it was released."]
	#[doc = " @return  -EADDRNOTAVAIL, if local of @p sock is not given."]
	#[doc = " @return  -EAGAIN, if @p timeout is `0` and no data is available."]
	#[doc = " @return  -EINVAL, if @p remote is invalid or @p sock is not properly"]
	#[doc = "          initialized (or closed while sock_udp_recv() blocks)."]
	#[doc = " @return  -ENOMEM, if no memory was available to receive @p data."]
	#[doc = " @return  -EPROTO, if source address of received packet did not equal"]
	#[doc = "          the remote of @p sock."]
	#[doc = " @return  -ETIMEDOUT, if @p timeout expired."]
	pub fn sock_udp_recv_buf_aux(
		sock: *mut sock_udp_t,
		data: *mut *mut ::core::ffi::c_void,
		buf_ctx: *mut *mut ::core::ffi::c_void,
		timeout: u32,
		remote: *mut sock_udp_ep_t,
		aux: *mut sock_udp_aux_rx_t,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Sends a UDP message to remote end point with non-continous payload"]
	#[doc = ""]
	#[doc = " @pre `((sock != NULL || remote != NULL))`"]
	#[doc = ""]
	#[doc = " @param[in] sock      A UDP sock object. May be `NULL`."]
	#[doc = "                      A sensible local end point should be selected by the"]
	#[doc = "                      implementation in that case."]
	#[doc = " @param[in] snips     List of payload chunks, will be processed in order."]
	#[doc = "                      May be `NULL`."]
	#[doc = " @param[in] remote    Remote end point for the sent data."]
	#[doc = "                      May be `NULL`, if @p sock has a remote end point."]
	#[doc = "                      sock_udp_ep_t::family may be AF_UNSPEC, if local"]
	#[doc = "                      end point of @p sock provides this information."]
	#[doc = "                      sock_udp_ep_t::port may not be 0."]
	#[doc = " @param[out] aux      Auxiliary data about the transmission."]
	#[doc = "                      May be `NULL`, if it is not required by the application."]
	#[doc = ""]
	#[doc = " @return  The number of bytes sent on success."]
	#[doc = " @return  -EADDRINUSE, if `sock` has no local end-point or was `NULL` and the"]
	#[doc = "          pool of available ephemeral ports is depleted."]
	#[doc = " @return  -EAFNOSUPPORT, if `remote != NULL` and sock_udp_ep_t::family of"]
	#[doc = "          @p remote is != AF_UNSPEC and not supported."]
	#[doc = " @return  -EHOSTUNREACH, if @p remote or remote end point of @p sock is not"]
	#[doc = "          reachable."]
	#[doc = " @return  -EINVAL, if sock_udp_ep_t::addr of @p remote is an invalid address."]
	#[doc = " @return  -EINVAL, if sock_udp_ep_t::netif of @p remote is not a valid"]
	#[doc = "          interface or contradicts the given local interface (i.e."]
	#[doc = "          neither the local end point of `sock` nor remote are assigned to"]
	#[doc = "          `SOCK_ADDR_ANY_NETIF` but are nevertheless different."]
	#[doc = " @return  -EINVAL, if sock_udp_ep_t::port of @p remote is 0."]
	#[doc = " @return  -ENOMEM, if no memory was available to send @p data."]
	#[doc = " @return  -ENOTCONN, if `remote == NULL`, but @p sock has no remote end point."]
	pub fn sock_udp_sendv_aux(
		sock: *mut sock_udp_t,
		snips: *const iolist_t,
		remote: *const sock_udp_ep_t,
		aux: *mut sock_udp_aux_tx_t,
	) -> isize;
}
#[doc = " @brief Mailbox struct definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbox_t {
	#[doc = "< list of threads waiting for message"]
	pub readers: list_node_t,
	#[doc = "< list of threads waiting to send"]
	pub writers: list_node_t,
	#[doc = "< cib for msg array"]
	pub cib: cib_t,
	#[doc = "< ptr to array of msg queue"]
	pub msg_array: *mut msg_t,
}
#[doc = "< non-blocking mode"]
pub const NON_BLOCKING: _bindgen_ty_5 = 0;
#[doc = "< blocking mode"]
pub const BLOCKING: _bindgen_ty_5 = 1;
pub type _bindgen_ty_5 = ::core::ffi::c_uint;
extern "C" {
	#[doc = " @brief Add message to mailbox"]
	#[doc = ""]
	#[doc = " If the mailbox is full, this function will return right away."]
	#[doc = ""]
	#[doc = " @internal"]
	#[doc = ""]
	#[doc = " @param[in] mbox      ptr to mailbox to operate on"]
	#[doc = " @param[in] msg       ptr to message that will be copied into mailbox"]
	#[doc = " @param[in] blocking  block if 1, don't block if 0"]
	#[doc = ""]
	#[doc = " @return  1   if msg could be delivered"]
	#[doc = " @return  0   otherwise"]
	pub fn _mbox_put(
		mbox: *mut mbox_t,
		msg: *mut msg_t,
		blocking: ::core::ffi::c_int,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief Get message from mailbox"]
	#[doc = ""]
	#[doc = " If the mailbox is empty, this function will return right away."]
	#[doc = ""]
	#[doc = " @internal"]
	#[doc = ""]
	#[doc = " @param[in] mbox  ptr to mailbox to operate on"]
	#[doc = " @param[in] msg   ptr to storage for retrieved message"]
	#[doc = " @param[in] blocking  block if 1, don't block if 0"]
	#[doc = ""]
	#[doc = " @return  1   if msg could be retrieved"]
	#[doc = " @return  0   otherwise"]
	pub fn _mbox_get(
		mbox: *mut mbox_t,
		msg: *mut msg_t,
		blocking: ::core::ffi::c_int,
	) -> ::core::ffi::c_int;
}
#[doc = "< unspecified address family"]
pub const unix_af_t_AF_UNSPEC: unix_af_t = 0;
#[doc = "< local to host (pipes, portals) address family."]
pub const unix_af_t_AF_UNIX: unix_af_t = 1;
#[doc = "< packet family"]
pub const unix_af_t_AF_PACKET: unix_af_t = 2;
#[doc = "< internetwork address family: UDP, TCP, etc."]
pub const unix_af_t_AF_INET: unix_af_t = 3;
#[doc = "< internetwork address family with IPv6: UDP, TCP, etc."]
pub const unix_af_t_AF_INET6: unix_af_t = 4;
#[doc = "< maximum number of address families on this system"]
pub const unix_af_t_AF_NUMOF: unix_af_t = 5;
#[doc = " @brief   UNIX address family definitions"]
pub type unix_af_t = ::core::ffi::c_uint;
#[doc = " @brief   (uint16_t) channel number"]
pub const netopt_t_NETOPT_CHANNEL: netopt_t = 0;
#[doc = " @brief   (@ref netopt_enable_t) check whether the network medium is clear"]
#[doc = ""]
#[doc = " Getting this option can be used to trigger a manual clear channel"]
#[doc = " assessment (CCA) on some wireless devices."]
pub const netopt_t_NETOPT_IS_CHANNEL_CLR: netopt_t = 1;
#[doc = " @brief   (byte array, see below) link layer address in network byte order"]
#[doc = ""]
#[doc = " Device type   | Length | Meaning"]
#[doc = " ------------- | ------ | -----"]
#[doc = " IEEE 802.15.4 | 2      | device short address"]
#[doc = " Ethernet      | 6      | device MAC address"]
#[doc = " nrfmin        | 2      | device short address"]
#[doc = " CC110x        | 1      | device address"]
#[doc = " NRF24L01+     | 5      | device address"]
#[doc = " LoRaWAN       | 4      | device address"]
pub const netopt_t_NETOPT_ADDRESS: netopt_t = 2;
#[doc = " @brief   (byte array, see below) long link layer address in network byte order"]
#[doc = ""]
#[doc = " Device type   | Length   | Meaning"]
#[doc = " ------------- | -------- | -----"]
#[doc = " IEEE 802.15.4 | 8        | device long address (EUI-64), @ref eui64_t"]
#[doc = " nrfmin        | 8        | device long address (based on short address)"]
#[doc = " BLE           | 8        | device long address (EUI-64), @ref eui64_t"]
#[doc = " LoRaWAN       | 8        | Device EUI"]
pub const netopt_t_NETOPT_ADDRESS_LONG: netopt_t = 3;
#[doc = " @brief   (uint16_t) get the default address length a network device expects"]
pub const netopt_t_NETOPT_ADDR_LEN: netopt_t = 4;
#[doc = " @brief   (uint16_t) address length to use for the link layer source address"]
pub const netopt_t_NETOPT_SRC_LEN: netopt_t = 5;
#[doc = " @brief   (uint16_t) network ID"]
#[doc = ""]
#[doc = " Examples for this include the PAN ID in IEEE 802.15.4 and netid in"]
#[doc = " LoRaWAN (uint32_t in this case)"]
pub const netopt_t_NETOPT_NID: netopt_t = 6;
#[doc = " @brief   (uint8_t) hop limit"]
pub const netopt_t_NETOPT_HOP_LIMIT: netopt_t = 7;
#[doc = " @brief   (@ref eui64_t) get the IPv6 interface identifier of a network interface"]
#[doc = ""]
#[doc = " @see <a href=\"https://tools.ietf.org/html/rfc4291#section-2.5.1\">"]
#[doc = "          RFC 4291, section 2.5.1"]
#[doc = "      </a>"]
#[doc = ""]
#[doc = " @note    Do not implement this in a network device driver. Other APIs"]
#[doc = "          utilizing [netopt](@ref net_netopt) such as @ref net_gnrc_netif"]
#[doc = "          or @ref net_netif may still implement it."]
#[doc = ""]
#[doc = " The generation of the interface identifier is dependent on the link-layer."]
#[doc = " Please refer to the appropriate IPv6 over `<link>` specification for"]
#[doc = " further implementation details (such as"]
#[doc = " <a href=\"https://tools.ietf.org/html/rfc2464\">RFC 2464</a> or"]
#[doc = " <a href=\"https://tools.ietf.org/html/rfc4944\">RFC 4944</a>)."]
pub const netopt_t_NETOPT_IPV6_IID: netopt_t = 8;
#[doc = " @brief   (@ref ipv6_addr_t[]) get IPv6 addresses of an interface as array"]
#[doc = "          of @ref ipv6_addr_t or add an IPv6 address as @ref ipv6_addr_t"]
#[doc = "          to an interface"]
#[doc = ""]
#[doc = " When adding an IPv6 address to a GNRC interface using"]
#[doc = " @ref GNRC_NETAPI_MSG_TYPE_SET, the gnrc_netapi_opt_t::context field can"]
#[doc = " be used to pass the prefix length (8 MSB) and some flags (8 LSB)"]
#[doc = " according to @ref net_gnrc_netif_ipv6_addrs_flags. The address is however"]
#[doc = " always considered to be manually added."]
#[doc = " When getting the option you can pass an array of @ref ipv6_addr_t of any"]
#[doc = " length greater than 0 to the getter. The array will be filled up to to"]
#[doc = " its maximum and the remaining addresses on the interface will be ignored"]
pub const netopt_t_NETOPT_IPV6_ADDR: netopt_t = 9;
#[doc = " @brief   (@ref ipv6_addr_t) Removes an IPv6 address from an interface"]
pub const netopt_t_NETOPT_IPV6_ADDR_REMOVE: netopt_t = 10;
#[doc = " @brief   (array of uint8_t) get the flags to the addresses returned by"]
#[doc = "          @ref NETOPT_IPV6_ADDR as array"]
#[doc = ""]
#[doc = " The information contained in the array is very specific to the"]
#[doc = " interface's API. For GNRC e.g. the values are according to"]
#[doc = " @ref net_gnrc_netif_ipv6_addrs_flags."]
pub const netopt_t_NETOPT_IPV6_ADDR_FLAGS: netopt_t = 11;
#[doc = " @brief   (@ref ipv6_addr_t) get IPv6 multicast groups of an interface as"]
#[doc = "          array of @ref ipv6_addr_t or join an IPv6 multicast group as"]
#[doc = "          @ref ipv6_addr_t on an interface"]
#[doc = ""]
#[doc = " When adding an IPv6 address to a GNRC interface using"]
#[doc = " @ref GNRC_NETAPI_MSG_TYPE_SET, the gnrc_netapi_opt_t::context field can"]
#[doc = " be used to pass the prefix length (8 MSB) and some flags (8 LSB)"]
#[doc = " according to @ref net_gnrc_netif_ipv6_addrs_flags. The address is however always"]
#[doc = " considered to be manually added."]
#[doc = " When getting the option you can pass an array of @ref ipv6_addr_t of any"]
#[doc = " length greater than 0 to the getter. The array will be filled up to to"]
#[doc = " its maximum and the remaining addresses on the interface will be ignored"]
pub const netopt_t_NETOPT_IPV6_GROUP: netopt_t = 12;
#[doc = " @brief   (@ref ipv6_addr_t) Leave an IPv6 multicast group on an interface"]
pub const netopt_t_NETOPT_IPV6_GROUP_LEAVE: netopt_t = 13;
#[doc = " @brief   (@ref netopt_enable_t) IPv6 forwarding state"]
pub const netopt_t_NETOPT_IPV6_FORWARDING: netopt_t = 14;
#[doc = " @brief   (@ref netopt_enable_t) sending of IPv6 router advertisements"]
pub const netopt_t_NETOPT_IPV6_SND_RTR_ADV: netopt_t = 15;
#[doc = " @brief   (int16_t) transmit power for radio devices in dBm"]
pub const netopt_t_NETOPT_TX_POWER: netopt_t = 16;
#[doc = " @brief   (uint16_t) maximum protocol data unit"]
pub const netopt_t_NETOPT_MAX_PDU_SIZE: netopt_t = 17;
#[doc = " @brief   (uint16_t) protocol data unit size"]
#[doc = ""]
#[doc = " When set, fixes the number of bytes to be received. This is required for"]
#[doc = " MAC layers with implicit header mode (no packet length information in"]
#[doc = " PDDU) and predictable packet length (e.g LoRaWAN beacons). The device"]
#[doc = " driver implementation should attempt to read exactly the expected number"]
#[doc = " of bytes (possibly filling it up with garbage data if the payload is"]
#[doc = " smaller)."]
#[doc = ""]
#[doc = " When get, returns the number of expected bytes for the next reception."]
#[doc = ""]
#[doc = " In some MAC layers it will only be effective if used in conjunction with"]
#[doc = " @ref NETOPT_FIXED_HEADER"]
pub const netopt_t_NETOPT_PDU_SIZE: netopt_t = 18;
#[doc = " @brief   (@ref netopt_enable_t) frame preloading"]
#[doc = ""]
#[doc = " Preload frame data using gnrc_netdev_driver_t::send_data() or gnrc_netapi_send(),"]
#[doc = " trigger sending by setting state to @ref NETOPT_STATE_TX"]
pub const netopt_t_NETOPT_PRELOADING: netopt_t = 19;
#[doc = " @brief   (@ref netopt_enable_t) promiscuous mode"]
pub const netopt_t_NETOPT_PROMISCUOUSMODE: netopt_t = 20;
#[doc = " @brief   (@ref netopt_enable_t) automatic link layer ACKs"]
pub const netopt_t_NETOPT_AUTOACK: netopt_t = 21;
#[doc = " @brief   (@ref netopt_enable_t) frame pending bit of ACKs"]
#[doc = ""]
#[doc = " For IEEE 802.15.4, this bit is copied into the frame pending subfield of"]
#[doc = " the ACK if it is the response to a data request MAC command frame."]
pub const netopt_t_NETOPT_ACK_PENDING: netopt_t = 22;
#[doc = " @brief   (@ref netopt_enable_t) acknowledgement request on outgoing frames"]
#[doc = ""]
#[doc = " For IEEE 802.15.4, this bit is copied into the ACK req subfield of the"]
#[doc = " frame control field."]
pub const netopt_t_NETOPT_ACK_REQ: netopt_t = 23;
#[doc = " @brief   (uint8_t) maximum number of retransmissions"]
pub const netopt_t_NETOPT_RETRANS: netopt_t = 24;
#[doc = " @brief   (@ref gnrc_nettype_t) the protocol for the layer"]
pub const netopt_t_NETOPT_PROTO: netopt_t = 25;
#[doc = " @brief   (@ref netopt_state_t) state of network device"]
pub const netopt_t_NETOPT_STATE: netopt_t = 26;
#[doc = " @brief   (@ref netopt_enable_t) when enabled, bypass protocol processing of incoming frames"]
pub const netopt_t_NETOPT_RAWMODE: netopt_t = 27;
#[doc = " @brief   (@ref netopt_enable_t) Used to check if the driver generates NETDEV_EVENT_RX_STARTED"]
#[doc = "          events"]
#[doc = ""]
#[doc = " It is mostly triggered after the preamble is correctly received"]
#[doc = ""]
#[doc = " @warning This value is read-only and cannot be configured at run-time"]
pub const netopt_t_NETOPT_RX_START_IRQ: netopt_t = 28;
#[doc = " @brief   (@ref netopt_enable_t) Used to check if the driver generates"]
#[doc = "          NETDEV_EVENT_RX_COMPLETE events"]
#[doc = ""]
#[doc = " This interrupt is triggered after a complete frame is received."]
#[doc = ""]
#[doc = " @note    In case a transceiver does not support this interrupt, the event"]
#[doc = "          may be triggered by the driver"]
#[doc = " @warning This value is read-only and cannot be configured at run-time"]
pub const netopt_t_NETOPT_RX_END_IRQ: netopt_t = 29;
#[doc = " @brief   (@ref netopt_enable_t) Used to check if the driver generates NETDEV_EVENT_TX_STARTED"]
#[doc = "          events"]
#[doc = ""]
#[doc = " This interrupt is triggered when the transceiver starts to send out the"]
#[doc = " frame."]
#[doc = ""]
#[doc = " @note    In case a transceiver does not support this interrupt, the event"]
#[doc = "          may be triggered by the driver"]
#[doc = " @warning This value is read-only and cannot be configured at run-time"]
pub const netopt_t_NETOPT_TX_START_IRQ: netopt_t = 30;
#[doc = " @brief   (@ref netopt_enable_t) Used to check if the driver generates"]
#[doc = "          NETDEV_EVENT_TX_COMPLETE events"]
#[doc = ""]
#[doc = " This interrupt is triggered when the full frame has been transmitted."]
#[doc = ""]
#[doc = " @note not all transceivers may support this interrupt"]
pub const netopt_t_NETOPT_TX_END_IRQ: netopt_t = 31;
#[doc = " @brief   (@ref netopt_enable_t) perform channel clear assessment before transmitting"]
#[doc = ""]
#[doc = " This may be a hardware feature of the given transceiver, or might be"]
#[doc = " otherwise implemented in software. If the device supports CSMA this"]
#[doc = " option will enable CSMA with a certain set of parameters to emulate the"]
#[doc = " desired behaviour."]
#[doc = ""]
#[doc = " @note Be sure not to set NETOPT_CSMA simultaneously."]
#[doc = ""]
#[doc = " @todo How to get feedback?"]
pub const netopt_t_NETOPT_AUTOCCA: netopt_t = 32;
#[doc = " @brief (@ref netopt_enable_t) network interface link status."]
#[doc = ""]
#[doc = " This option is used to set or check the link status (up or down)."]
#[doc = ""]
#[doc = " @note On error this option should return a negative number."]
pub const netopt_t_NETOPT_LINK: netopt_t = 33;
#[doc = " @brief   (@ref netopt_enable_t) CSMA/CA support"]
#[doc = ""]
#[doc = " If the device supports CSMA in hardware, this option enables it with"]
#[doc = " default parameters. For further configuration refer to the other"]
#[doc = " NETOPT_CSMA_* options."]
pub const netopt_t_NETOPT_CSMA: netopt_t = 34;
#[doc = " @brief   (uint8_t) maximum number of CSMA retries"]
#[doc = ""]
#[doc = " The maximum number of backoffs the CSMA-CA algorithm will attempt before"]
#[doc = " declaring a channel access failure. Named macMaxCsmaBackoffs in"]
#[doc = " IEEE Std 802.15.4-2015."]
#[doc = ""]
#[doc = " IEEE 802.15.4 default: 4"]
pub const netopt_t_NETOPT_CSMA_RETRIES: netopt_t = 35;
#[doc = " @brief   (uint8_t) maximum backoff exponent for the CSMA-CA algorithm"]
#[doc = ""]
#[doc = " Named macMaxBE in IEEE Std 802.15.4-2015."]
#[doc = ""]
#[doc = " IEEE 802.15.4 default: 5"]
pub const netopt_t_NETOPT_CSMA_MAXBE: netopt_t = 36;
#[doc = " @brief   (uint8_t) minimum backoff exponent for the CSMA-CA algorithm"]
#[doc = ""]
#[doc = " Named macMinBE in IEEE Std 802.15.4-2015."]
#[doc = ""]
#[doc = " IEEE 802.15.4 default: 3"]
pub const netopt_t_NETOPT_CSMA_MINBE: netopt_t = 37;
#[doc = " @brief   (@ref netopt_enable_t) block transceiver sleep"]
#[doc = ""]
#[doc = " Enabling this option tells the MAC layer to never put the radio to sleep."]
#[doc = " Useful in gateways and routers not running on batteries to improve"]
#[doc = " responsiveness and allow battery powered nodes on the same network to"]
#[doc = " sleep more often."]
pub const netopt_t_NETOPT_MAC_NO_SLEEP: netopt_t = 38;
#[doc = " @brief   (@ref netopt_enable_t) read-only check for a wired interface."]
#[doc = ""]
#[doc = " This option will return -ENOTSUP for wireless interfaces."]
#[doc = ""]
#[doc = " @note Setting this option will always return -ENOTSUP."]
pub const netopt_t_NETOPT_IS_WIRED: netopt_t = 39;
#[doc = " @brief   (uint16_t) device type"]
#[doc = ""]
#[doc = " e.g. NETDEV_TYPE_ETHERNET, NETDEV_TYPE_IEEE802154, etc."]
pub const netopt_t_NETOPT_DEVICE_TYPE: netopt_t = 40;
#[doc = " @brief   (uint16_t) channel page as defined by IEEE 802.15.4"]
pub const netopt_t_NETOPT_CHANNEL_PAGE: netopt_t = 41;
#[doc = " @brief   (int8_t) CCA threshold for the radio transceiver"]
#[doc = ""]
#[doc = " This is the value, in dBm, that the radio transceiver uses to decide"]
#[doc = " whether the channel is clear or not (CCA). If the current signal strength"]
#[doc = " (RSSI/ED) is stronger than this CCA threshold value, the transceiver"]
#[doc = " usually considers that the radio medium is busy. Otherwise, i.e. if"]
#[doc = " RSSI/ED value is less than the CCA threshold value, the radio medium is"]
#[doc = " supposed to be free (the possibly received weak signal is considered to"]
#[doc = " be background, meaningless noise)."]
#[doc = ""]
#[doc = " Most transceivers allow to set this CCA threshold value. Some research"]
#[doc = " work has proven that dynamically adapting it to network environment can"]
#[doc = " improve QoS, especially in WSN."]
pub const netopt_t_NETOPT_CCA_THRESHOLD: netopt_t = 42;
#[doc = " @brief   (uint8_t) CCA mode for the radio transceiver"]
#[doc = ""]
#[doc = " Get/set the CCA mode corresponding to the respective PHY standard."]
#[doc = " - IEEE 802.15.4: @ref netdev_ieee802154_cca_mode_t"]
pub const netopt_t_NETOPT_CCA_MODE: netopt_t = 43;
#[doc = " @brief   (@ref netstats_t*) get statistics about sent and received packets and data of the"]
#[doc = "          device or protocol"]
#[doc = ""]
#[doc = " Expects a pointer to a @ref netstats_t struct that will be pointed to"]
#[doc = " the corresponding @ref netstats_t of the module."]
pub const netopt_t_NETOPT_STATS: netopt_t = 44;
#[doc = " @brief   (@ref netopt_enable_t) link layer encryption."]
pub const netopt_t_NETOPT_ENCRYPTION: netopt_t = 45;
#[doc = " @brief   (byte array) set encryption key"]
#[doc = ""]
#[doc = " The required byte array size is dependent on encryption algorithm and device."]
pub const netopt_t_NETOPT_ENCRYPTION_KEY: netopt_t = 46;
#[doc = " @brief   (@ref netopt_rf_testmode_t) Test mode for the radio, e.g. for CE or FCC"]
#[doc = "          certification"]
#[doc = ""]
#[doc = " Get/set the test mode as type @ref netopt_rf_testmode_t or as uint8_t if"]
#[doc = " the radio supports other vendor specific test modes."]
#[doc = ""]
#[doc = " @note Setting this option should always return -ENOTSUP, unless it was"]
#[doc = " explicitly allowed at build time, therefore it should be secured with an"]
#[doc = " additional macro in the device driver."]
#[doc = ""]
#[doc = " @attention For development and certification purposes only! These test"]
#[doc = " modes can disturb normal radio communications and exceed the limits"]
#[doc = " established by the regulatory authority."]
#[doc = ""]
pub const netopt_t_NETOPT_RF_TESTMODE: netopt_t = 47;
#[doc = " @brief   (@ref l2filter_t) add an address to a link layer filter list"]
#[doc = ""]
#[doc = " Getting this option from a device will return a pointer of type"]
#[doc = " @ref l2filter_t to the first entry of a filter list."]
#[doc = " When setting this option a pointer to an link layer address as well as"]
#[doc = " the length of the address are expected as parameters."]
pub const netopt_t_NETOPT_L2FILTER: netopt_t = 48;
#[doc = " @brief   (@ref l2filter_t) remove an address from a link layer filter list"]
#[doc = ""]
#[doc = " Getting this value always returns -ENOTSUP."]
#[doc = " When setting this option a pointer to an link layer address as well as"]
#[doc = " the length of the address are expected as parameters. Setting this"]
#[doc = " option will lead to the given address being removed from the filer list."]
pub const netopt_t_NETOPT_L2FILTER_RM: netopt_t = 49;
#[doc = " @brief   (int8_t) Energy level during the last performed CCA or RX frame"]
#[doc = ""]
#[doc = " Get the last ED level available as an int8_t. The source of the"]
#[doc = " measurement is unspecified and may come from the latest CCA"]
#[doc = " measurement (CCA mode 1), or from the last received frame."]
pub const netopt_t_NETOPT_LAST_ED_LEVEL: netopt_t = 50;
#[doc = " @brief   (uint16_t) preamble length"]
pub const netopt_t_NETOPT_PREAMBLE_LENGTH: netopt_t = 51;
#[doc = " @brief   (@ref netopt_enable_t) frame integrity check (e.g CRC)"]
pub const netopt_t_NETOPT_INTEGRITY_CHECK: netopt_t = 52;
#[doc = " @brief   (uint32_t) channel center frequency"]
#[doc = ""]
#[doc = " For example, with LoRa, this corresponds to the center frequency of"]
#[doc = " each channel (867300000, etc) for a given frequency band"]
#[doc = " (868, 915, etc)."]
pub const netopt_t_NETOPT_CHANNEL_FREQUENCY: netopt_t = 53;
#[doc = " @brief   (@ref netopt_enable_t) channel hopping"]
pub const netopt_t_NETOPT_CHANNEL_HOP: netopt_t = 54;
#[doc = " @brief   (uint8_t) channel hopping period"]
pub const netopt_t_NETOPT_CHANNEL_HOP_PERIOD: netopt_t = 55;
#[doc = " @brief   (@ref netopt_enable_t) single frame reception"]
#[doc = ""]
#[doc = " If enabled, RX is turned off upon reception of a frame"]
pub const netopt_t_NETOPT_SINGLE_RECEIVE: netopt_t = 56;
#[doc = " @brief   (uint32_t) reception timeout of a frame"]
#[doc = ""]
#[doc = " @todo in what time unit?"]
pub const netopt_t_NETOPT_RX_TIMEOUT: netopt_t = 57;
#[doc = " @brief   (uint32_t) transmission timeout of a frame"]
#[doc = ""]
#[doc = " @todo in what time unit?"]
pub const netopt_t_NETOPT_TX_TIMEOUT: netopt_t = 58;
#[doc = " @brief   (uint8_t) radio modulation bandwidth"]
pub const netopt_t_NETOPT_BANDWIDTH: netopt_t = 59;
#[doc = " @brief   (uint8_t) radio spreading factor"]
pub const netopt_t_NETOPT_SPREADING_FACTOR: netopt_t = 60;
#[doc = " @brief   (uint8_t) radio coding rate"]
pub const netopt_t_NETOPT_CODING_RATE: netopt_t = 61;
#[doc = " @brief   (@ref netopt_enable_t) fixed header mode"]
pub const netopt_t_NETOPT_FIXED_HEADER: netopt_t = 62;
#[doc = " @brief   (@ref netopt_enable_t) IQ inverted"]
pub const netopt_t_NETOPT_IQ_INVERT: netopt_t = 63;
#[doc = " @brief   (@ref netopt_enable_t) 6Lo support"]
#[doc = ""]
#[doc = " @see [RFC 4944](https://tools.ietf.org/html/rfc4944)"]
pub const netopt_t_NETOPT_6LO: netopt_t = 64;
#[doc = " @brief   (@ref netopt_enable_t) header compression"]
#[doc = ""]
#[doc = " @see [RFC 6282](https://tools.ietf.org/html/rfc6282)"]
pub const netopt_t_NETOPT_6LO_IPHC: netopt_t = 65;
#[doc = " @brief   (uint8_t) retry amount from missing ACKs of the last transmission"]
#[doc = ""]
#[doc = " This retrieves the number of retries needed for the last transmission."]
#[doc = " Only retransmissions due to missing ACK frames are considered, retries"]
#[doc = " due to CCA failures are not counted."]
pub const netopt_t_NETOPT_TX_RETRIES_NEEDED: netopt_t = 66;
#[doc = " @brief   (netdev_ble_ctx_t) set BLE radio context (channel, CRC, AA)"]
#[doc = ""]
#[doc = " @warning As @ref drivers_netdev_ble is still experimental, use with care!"]
pub const netopt_t_NETOPT_BLE_CTX: netopt_t = 67;
#[doc = " @brief   (@ref netopt_enable_t) enable hardware checksumming"]
#[doc = ""]
#[doc = " If enabled, enable hardware checksumming of incoming frames."]
pub const netopt_t_NETOPT_CHECKSUM: netopt_t = 68;
#[doc = " @brief   (@ref netopt_enable_t) enable busy mode"]
#[doc = ""]
#[doc = " When set, the PHY will enter busy mode, in which it will not accept"]
#[doc = " incoming frames until unset."]
pub const netopt_t_NETOPT_PHY_BUSY: netopt_t = 69;
#[doc = " @brief   (uint8_t*) LoRaWAN application EUI (8 bytes length)"]
pub const netopt_t_NETOPT_LORAWAN_APPEUI: netopt_t = 70;
#[doc = " @brief   (uint8_t*) LoRaWAN application key (16 bytes length)"]
pub const netopt_t_NETOPT_LORAWAN_APPKEY: netopt_t = 71;
#[doc = " @brief   (uint8_t*) LoRaWAN network session key (16 bytes length)"]
pub const netopt_t_NETOPT_LORAWAN_NWKSKEY: netopt_t = 72;
#[doc = " @brief   (uint8_t*) LoRaWAN application session key (16 bytes length)"]
pub const netopt_t_NETOPT_LORAWAN_APPSKEY: netopt_t = 73;
#[doc = " @brief   (uint8_t) LoRaWAN device class (A, B, C)"]
#[doc = " - LoRaWAN: @ref loramac_class_t"]
pub const netopt_t_NETOPT_LORAWAN_DEVICE_CLASS: netopt_t = 74;
#[doc = " @brief   (uint8_t) LoRaWAN datarate"]
#[doc = " - LoRaWAN: @ref loramac_dr_idx_t"]
pub const netopt_t_NETOPT_LORAWAN_DR: netopt_t = 75;
#[doc = " @brief   (@ref netopt_enable_t) LoRaWAN adaptive datarate"]
pub const netopt_t_NETOPT_LORAWAN_ADR: netopt_t = 76;
#[doc = " @brief   (@ref netopt_enable_t) LoRaWAN public network"]
pub const netopt_t_NETOPT_LORAWAN_PUBLIC_NETWORK: netopt_t = 77;
#[doc = " @brief   (uint8_t) LoRaWAN TX application port"]
#[doc = " - LoRaWAN: between 1 and 223 (included)"]
#[doc = ""]
#[doc = " @deprecated  This option is deprecated and will be removed in the"]
#[doc = "              2022.01 Release."]
#[doc = "              The port is encoded now as a one byte"]
#[doc = "              destination address in a @ref net_gnrc_netif_hdr snip"]
#[doc = "              prepended in the packet."]
#[doc = "              The user must take care of prepending the required snip"]
#[doc = "              during transmission. On reception, the"]
#[doc = "              snip is prepended automatically by the stack and shall be"]
#[doc = "              consumed by the user."]
#[doc = "              During the deprecation period it is required to"]
#[doc = "              compile with @ref"]
#[doc = "              CONFIG_GNRC_NETIF_LORAWAN_NETIF_HDR"]
#[doc = ""]
pub const netopt_t_NETOPT_LORAWAN_TX_PORT: netopt_t = 78;
#[doc = " @brief   (loramac_dr_idx_t) LoRaWAN datarate for second RX window"]
#[doc = " - LoRaWAN: @ref loramac_dr_idx_t"]
pub const netopt_t_NETOPT_LORAWAN_RX2_DR: netopt_t = 79;
#[doc = " @brief   (uint32_t) LoRaWAN frequency used for second RX window"]
pub const netopt_t_NETOPT_LORAWAN_RX2_FREQ: netopt_t = 80;
#[doc = " @brief   (uint32_t) LoRaWAN maximum system overall timing error (ms)"]
pub const netopt_t_NETOPT_LORAWAN_MAX_RX_ERROR: netopt_t = 81;
#[doc = " @brief   (uint8_t) LoRaWAN maximum system overall timing error (symbols)"]
pub const netopt_t_NETOPT_LORAWAN_MIN_RX_SYMBOL: netopt_t = 82;
#[doc = " @brief   (uint8_t) 802.15.4 PHY mode"]
pub const netopt_t_NETOPT_IEEE802154_PHY: netopt_t = 83;
#[doc = " @brief   (uint8_t) legacy O-QPSK proprietary mode"]
#[doc = "          Allows to select higher data rates than standard 250 kbit/s"]
#[doc = "          Not compatible across vendors, only use with radios of the same type."]
pub const netopt_t_NETOPT_OQPSK_RATE: netopt_t = 84;
#[doc = " @brief   (uint8_t) MR-O-QPSK Chip Rate (kchip/s)"]
pub const netopt_t_NETOPT_MR_OQPSK_CHIPS: netopt_t = 85;
#[doc = " @brief   (uint8_t) MR-O-QPSK Rate Mode"]
pub const netopt_t_NETOPT_MR_OQPSK_RATE: netopt_t = 86;
#[doc = " @brief   (uint8_t) MR-OFDM PHY Option (Values: 1-4)"]
pub const netopt_t_NETOPT_MR_OFDM_OPTION: netopt_t = 87;
#[doc = " @brief   (uint8_t) MR-OFDM PHY Modulation and Coding Scheme (Values: 0-6)"]
pub const netopt_t_NETOPT_MR_OFDM_MCS: netopt_t = 88;
#[doc = " @brief   (uint8_t) MR-FSK PHY Modulation Index (x 64)"]
pub const netopt_t_NETOPT_MR_FSK_MODULATION_INDEX: netopt_t = 89;
#[doc = " @brief   (uint8_t) MR-FSK Modulation Order"]
pub const netopt_t_NETOPT_MR_FSK_MODULATION_ORDER: netopt_t = 90;
#[doc = " @brief   (uint8_t) MR-FSK PHY Symbol Rate (kHz)"]
pub const netopt_t_NETOPT_MR_FSK_SRATE: netopt_t = 91;
#[doc = " @brief   (uint8_t) MR-FSK PHY Forward Error Correction"]
pub const netopt_t_NETOPT_MR_FSK_FEC: netopt_t = 92;
#[doc = " @brief   (uint8_t) PHY Channel Spacing (kHz)"]
pub const netopt_t_NETOPT_CHANNEL_SPACING: netopt_t = 93;
#[doc = " @brief   (uint8_t*) phy layer syncword"]
pub const netopt_t_NETOPT_SYNCWORD: netopt_t = 94;
#[doc = " @brief  (uint32_t) Get a random value from the device"]
#[doc = ""]
#[doc = " Nothing happens when set"]
pub const netopt_t_NETOPT_RANDOM: netopt_t = 95;
#[doc = " @brief (uint16_t) Get or set the number of PHY symbols before assuming there's no data"]
pub const netopt_t_NETOPT_RX_SYMBOL_TIMEOUT: netopt_t = 96;
#[doc = " @brief (@ref netopt_enable_t) Enable or disable OTAA activation (LoRaWAN)"]
pub const netopt_t_NETOPT_OTAA: netopt_t = 97;
#[doc = " @brief (uint8_t) Get the demodulation margin of the last Link Check request."]
pub const netopt_t_NETOPT_DEMOD_MARGIN: netopt_t = 98;
#[doc = " @brief (uint8_t) Get the number of gateways of the last Link Check request."]
pub const netopt_t_NETOPT_NUM_GATEWAYS: netopt_t = 99;
#[doc = " @brief (@ref netopt_enable_t) Perform a Link Check request (LoRaWAN)"]
#[doc = ""]
#[doc = " When set, the next transmission will request a Link Check and will"]
#[doc = " be received on the next downlink"]
pub const netopt_t_NETOPT_LINK_CHECK: netopt_t = 100;
#[doc = " @brief (int16_t) Received Signal Strength Indicator (RSSI)"]
#[doc = ""]
#[doc = " The RSSI is an indicator for the received field strength in wireless"]
#[doc = " channels. It is often represented as the ratio of received power to"]
#[doc = " a given unit, for example milliwatts. With a device-dependent scaling"]
#[doc = " factor, the RSSI value can be expressed as power level in the unit"]
#[doc = " dBm or ASU (Arbitrary Strength Unit)."]
pub const netopt_t_NETOPT_RSSI: netopt_t = 101;
#[doc = " @brief (uint16_t) Set the battery monitor voltage (in mV)."]
#[doc = ""]
#[doc = " When set, a @ref SYS_BUS_POWER_EVENT_LOW_VOLTAGE event is generated"]
#[doc = " on the SYS_BUS_POWER bus if the supply voltage falls below the set value."]
#[doc = ""]
#[doc = " Set to 0 to disable battery monitoring."]
pub const netopt_t_NETOPT_BATMON: netopt_t = 102;
#[doc = " @brief   (array of byte array) get link layer multicast groups as array"]
#[doc = "          of byte arrays (length of each byte array corresponds to the"]
#[doc = "          length of @ref NETOPT_ADDRESS) or join a link layer multicast"]
#[doc = "          group as byte array on an interface"]
#[doc = ""]
#[doc = " When getting the option you can pass an array of byte arrays of any"]
#[doc = " length greater than 0 to the getter. The array will be filled up to to"]
#[doc = " its maximum and the remaining addresses on the interface will be ignored"]
pub const netopt_t_NETOPT_L2_GROUP: netopt_t = 103;
#[doc = " @brief   (array of byte arrays) Leave an link layer multicast group"]
pub const netopt_t_NETOPT_L2_GROUP_LEAVE: netopt_t = 104;
#[doc = " @brief   maximum number of options defined here."]
#[doc = ""]
#[doc = " @note    Interfaces are not meant to respond to this option"]
pub const netopt_t_NETOPT_NUMOF: netopt_t = 105;
#[doc = " @brief   Global list of configuration options available throughout the"]
#[doc = "          network stack, e.g. by netdev and netapi"]
#[doc = ""]
#[doc = " The data type specified in parentheses for each individual option is the"]
#[doc = " data type to use for the argument when getting/setting the value of the option."]
#[doc = ""]
#[doc = " All arguments longer than 1 byte (e.g. uint16_t) are given in host byte order"]
#[doc = " unless anything else is specified below."]
pub type netopt_t = ::core::ffi::c_uint;
#[doc = "< disable a given option"]
pub const netopt_enable_t_NETOPT_DISABLE: netopt_enable_t = 0;
#[doc = "< enable a given option"]
pub const netopt_enable_t_NETOPT_ENABLE: netopt_enable_t = 1;
#[doc = " @brief   Binary parameter for enabling and disabling options"]
pub type netopt_enable_t = ::core::ffi::c_uint;
#[doc = "< powered off"]
pub const netopt_state_t_NETOPT_STATE_OFF: netopt_state_t = 0;
#[doc = "< sleep mode"]
pub const netopt_state_t_NETOPT_STATE_SLEEP: netopt_state_t = 1;
#[doc = "< idle mode,"]
#[doc = "   the device listens to receive packets"]
pub const netopt_state_t_NETOPT_STATE_IDLE: netopt_state_t = 2;
#[doc = "< receive mode,"]
#[doc = "   the device currently receives a packet"]
pub const netopt_state_t_NETOPT_STATE_RX: netopt_state_t = 3;
#[doc = "< transmit mode,"]
#[doc = "   set: triggers transmission of a preloaded packet"]
#[doc = "   (see @ref NETOPT_PRELOADING*). The resulting"]
#[doc = "   state of the network device is @ref NETOPT_STATE_IDLE"]
#[doc = "   get: the network device is in the process of"]
#[doc = "   transmitting a packet"]
pub const netopt_state_t_NETOPT_STATE_TX: netopt_state_t = 4;
#[doc = "< triggers a hardware reset. The resulting"]
#[doc = "   state of the network device is @ref NETOPT_STATE_IDLE"]
pub const netopt_state_t_NETOPT_STATE_RESET: netopt_state_t = 5;
#[doc = "< standby mode. The devices is awake but"]
#[doc = "   not listening to packets."]
pub const netopt_state_t_NETOPT_STATE_STANDBY: netopt_state_t = 6;
#[doc = " @brief   Option parameter to be used with @ref NETOPT_STATE to set or get"]
#[doc = "          the state of a network device or protocol implementation"]
pub type netopt_state_t = ::core::ffi::c_uint;
#[doc = "< idle mode, radio off"]
pub const netopt_rf_testmode_t_NETOPT_RF_TESTMODE_IDLE: netopt_rf_testmode_t = 0;
#[doc = "< continuous rx mode"]
pub const netopt_rf_testmode_t_NETOPT_RF_TESTMODE_CRX: netopt_rf_testmode_t = 1;
#[doc = "< carrier wave continuous tx mode"]
pub const netopt_rf_testmode_t_NETOPT_RF_TESTMODE_CTX_CW: netopt_rf_testmode_t = 2;
#[doc = "< PRBS9 continuous tx mode"]
pub const netopt_rf_testmode_t_NETOPT_RF_TESTMODE_CTX_PRBS9: netopt_rf_testmode_t = 3;
#[doc = " @brief   Option parameter to be used with @ref NETOPT_RF_TESTMODE"]
pub type netopt_rf_testmode_t = ::core::ffi::c_uint;
extern "C" {
	#[doc = " @brief   Get a string ptr corresponding to opt, for debugging"]
	#[doc = ""]
	#[doc = " @param[in] opt   The option to get a string representation for"]
	#[doc = ""]
	#[doc = " @return          ptr to string representation for given option or \"unknown\""]
	pub fn netopt2str(opt: netopt_t) -> *const ::core::ffi::c_char;
}
#[doc = " @brief   TX synchronization data for passing up error data or"]
#[doc = "          auxiliary data"]
pub const gnrc_nettype_t_GNRC_NETTYPE_TX_SYNC: gnrc_nettype_t = -3;
#[doc = " @brief   Protocol is as defined in @ref gnrc_netif_hdr_t. Not usable with"]
#[doc = "          @ref net_gnrc_netreg"]
pub const gnrc_nettype_t_GNRC_NETTYPE_NETIF: gnrc_nettype_t = -1;
#[doc = "< Protocol is undefined"]
pub const gnrc_nettype_t_GNRC_NETTYPE_UNDEF: gnrc_nettype_t = 0;
#[doc = "< maximum number of available protocols"]
pub const gnrc_nettype_t_GNRC_NETTYPE_NUMOF: gnrc_nettype_t = 1;
#[doc = " @brief   Definition of protocol types in the network stack."]
#[doc = ""]
#[doc = " @note    Expand at will."]
pub type gnrc_nettype_t = ::core::ffi::c_int;
#[doc = " @brief   Type to represent parts (either headers or payload) of a packet,"]
#[doc = "          called snips."]
#[doc = " @details The idea behind the packet snips is that they either can represent"]
#[doc = "          protocol-specific headers or payload. A packet can be comprised of"]
#[doc = "          multiple pktsnip_t elements."]
#[doc = ""]
#[doc = "          Example:"]
#[doc = ""]
#[doc = "                                                                  buffer"]
#[doc = "              +---------------------------+                      +------+"]
#[doc = "              | size = 14                 | data +-------------->|      |"]
#[doc = "              | type = NETTYPE_ETHERNET   |------+               +------+"]
#[doc = "              +---------------------------+                      .      ."]
#[doc = "                    | next                                       .      ."]
#[doc = "                    v                                            +------+"]
#[doc = "              +---------------------------+         +----------->|      |"]
#[doc = "              | size = 40                 | data    |            |      |"]
#[doc = "              | type = NETTYPE_IPV6       |---------+            +------+"]
#[doc = "              +---------------------------+                      .      ."]
#[doc = "                    | next                                       .      ."]
#[doc = "                    v                                            +------+"]
#[doc = "              +---------------------------+            +-------->|      |"]
#[doc = "              | size = 8                  | data       |         +------+"]
#[doc = "              | type = NETTYPE_UDP        |------------+         .      ."]
#[doc = "              +---------------------------+                      .      ."]
#[doc = "                    | next                                       +------+"]
#[doc = "                    v                                     +----->|      |"]
#[doc = "              +---------------------------+               |      |      |"]
#[doc = "              | size = 59                 | data          |      .      ."]
#[doc = "              | type = NETTYPE_UNDEF      |---------------+      .      ."]
#[doc = "              +---------------------------+                      .      ."]
#[doc = ""]
#[doc = " To keep data duplication as low as possible the order of the snips"]
#[doc = " in a packet will be reversed depending on if you send the packet or if"]
#[doc = " you received it. For sending the order is from (in the network stack) lowest"]
#[doc = " protocol snip to the highest, for receiving the order is from highest"]
#[doc = " snip to the lowest. This way, if a layer needs to duplicate the packet"]
#[doc = " a tree is created rather than a duplication of the whole package."]
#[doc = ""]
#[doc = " A very extreme example for this (we only expect one or two duplications at"]
#[doc = " maximum per package) can be seen here:"]
#[doc = ""]
#[doc = "      Sending                          Receiving"]
#[doc = "      =======                          ========="]
#[doc = ""]
#[doc = "      * Payload                        * L2 header"]
#[doc = "      ^                                ^"]
#[doc = "      |                                |"]
#[doc = "      |\\                               |\\"]
#[doc = "      | * L4 header 1                  | * L2.5 header 1"]
#[doc = "      | * L3 header 1                  | * L3 header 1"]
#[doc = "      | * netif header 1               | * L4 header 1"]
#[doc = "      * L4 header 2                    | * Payload 1"]
#[doc = "      ^                                * L3 header 2"]
#[doc = "      |                                ^"]
#[doc = "      |\\                               |"]
#[doc = "      | * L3 header 2                  |\\"]
#[doc = "      | * L2 header 2                  | * L4 header 2"]
#[doc = "      * L2 header 3                    | * Payload 2"]
#[doc = "      |\\                               * Payload 3"]
#[doc = "      | * L2 header 3"]
#[doc = "      * L2 header 4"]
#[doc = ""]
#[doc = " The first three fields (next, data, size) match iolist_t (named iol_next,"]
#[doc = " iol_base and iol_len there).  That means that any pktsnip can be casted to"]
#[doc = " iolist_t for direct passing to e.g., netdev send() functions."]
#[doc = ""]
#[doc = " @note    This type has no initializer on purpose. Please use @ref net_gnrc_pktbuf"]
#[doc = "          as factory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnrc_pktsnip {
	#[doc = "< next snip in the packet"]
	pub next: *mut gnrc_pktsnip,
	#[doc = "< pointer to the data of the snip"]
	pub data: *mut ::core::ffi::c_void,
	#[doc = "< the length of the snip in byte"]
	pub size: usize,
	#[doc = " @brief   Counter of threads currently having control over this packet."]
	#[doc = ""]
	#[doc = " @internal"]
	pub users: ::core::ffi::c_uint,
	#[doc = "< protocol of the packet snip"]
	pub type_: gnrc_nettype_t,
}
#[doc = " @brief   Type to represent parts (either headers or payload) of a packet,"]
#[doc = "          called snips."]
#[doc = " @details The idea behind the packet snips is that they either can represent"]
#[doc = "          protocol-specific headers or payload. A packet can be comprised of"]
#[doc = "          multiple pktsnip_t elements."]
#[doc = ""]
#[doc = "          Example:"]
#[doc = ""]
#[doc = "                                                                  buffer"]
#[doc = "              +---------------------------+                      +------+"]
#[doc = "              | size = 14                 | data +-------------->|      |"]
#[doc = "              | type = NETTYPE_ETHERNET   |------+               +------+"]
#[doc = "              +---------------------------+                      .      ."]
#[doc = "                    | next                                       .      ."]
#[doc = "                    v                                            +------+"]
#[doc = "              +---------------------------+         +----------->|      |"]
#[doc = "              | size = 40                 | data    |            |      |"]
#[doc = "              | type = NETTYPE_IPV6       |---------+            +------+"]
#[doc = "              +---------------------------+                      .      ."]
#[doc = "                    | next                                       .      ."]
#[doc = "                    v                                            +------+"]
#[doc = "              +---------------------------+            +-------->|      |"]
#[doc = "              | size = 8                  | data       |         +------+"]
#[doc = "              | type = NETTYPE_UDP        |------------+         .      ."]
#[doc = "              +---------------------------+                      .      ."]
#[doc = "                    | next                                       +------+"]
#[doc = "                    v                                     +----->|      |"]
#[doc = "              +---------------------------+               |      |      |"]
#[doc = "              | size = 59                 | data          |      .      ."]
#[doc = "              | type = NETTYPE_UNDEF      |---------------+      .      ."]
#[doc = "              +---------------------------+                      .      ."]
#[doc = ""]
#[doc = " To keep data duplication as low as possible the order of the snips"]
#[doc = " in a packet will be reversed depending on if you send the packet or if"]
#[doc = " you received it. For sending the order is from (in the network stack) lowest"]
#[doc = " protocol snip to the highest, for receiving the order is from highest"]
#[doc = " snip to the lowest. This way, if a layer needs to duplicate the packet"]
#[doc = " a tree is created rather than a duplication of the whole package."]
#[doc = ""]
#[doc = " A very extreme example for this (we only expect one or two duplications at"]
#[doc = " maximum per package) can be seen here:"]
#[doc = ""]
#[doc = "      Sending                          Receiving"]
#[doc = "      =======                          ========="]
#[doc = ""]
#[doc = "      * Payload                        * L2 header"]
#[doc = "      ^                                ^"]
#[doc = "      |                                |"]
#[doc = "      |\\                               |\\"]
#[doc = "      | * L4 header 1                  | * L2.5 header 1"]
#[doc = "      | * L3 header 1                  | * L3 header 1"]
#[doc = "      | * netif header 1               | * L4 header 1"]
#[doc = "      * L4 header 2                    | * Payload 1"]
#[doc = "      ^                                * L3 header 2"]
#[doc = "      |                                ^"]
#[doc = "      |\\                               |"]
#[doc = "      | * L3 header 2                  |\\"]
#[doc = "      | * L2 header 2                  | * L4 header 2"]
#[doc = "      * L2 header 3                    | * Payload 2"]
#[doc = "      |\\                               * Payload 3"]
#[doc = "      | * L2 header 3"]
#[doc = "      * L2 header 4"]
#[doc = ""]
#[doc = " The first three fields (next, data, size) match iolist_t (named iol_next,"]
#[doc = " iol_base and iol_len there).  That means that any pktsnip can be casted to"]
#[doc = " iolist_t for direct passing to e.g., netdev send() functions."]
#[doc = ""]
#[doc = " @note    This type has no initializer on purpose. Please use @ref net_gnrc_pktbuf"]
#[doc = "          as factory."]
pub type gnrc_pktsnip_t = gnrc_pktsnip;
extern "C" {
	#[doc = " @brief   Searches the packet for a packet snip of a specific type"]
	#[doc = ""]
	#[doc = " @param[in] pkt   list of packet snips"]
	#[doc = " @param[in] type  the type to search for"]
	#[doc = ""]
	#[doc = " @return  the packet snip in @p pkt with @ref gnrc_nettype_t @p type"]
	#[doc = " @return  NULL, if none of the snips in @p pkt is of @p type"]
	pub fn gnrc_pktsnip_search_type(
		pkt: *mut gnrc_pktsnip_t,
		type_: gnrc_nettype_t,
	) -> *mut gnrc_pktsnip_t;
}
#[doc = " @brief   Data structure to be send for setting (@ref GNRC_NETAPI_MSG_TYPE_SET)"]
#[doc = "          and getting (@ref GNRC_NETAPI_MSG_TYPE_GET) options"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnrc_netapi_opt_t {
	#[doc = "< the option to get/set"]
	pub opt: netopt_t,
	#[doc = "< (optional) context for that option"]
	pub context: u16,
	#[doc = "< data to set or buffer to read into"]
	pub data: *mut ::core::ffi::c_void,
	#[doc = "< size of the data / the buffer"]
	pub data_len: u16,
}
extern "C" {
	#[doc = " @brief   Shortcut function for sending @ref GNRC_NETAPI_MSG_TYPE_SND or"]
	#[doc = "          @ref GNRC_NETAPI_MSG_TYPE_RCV messages"]
	#[doc = ""]
	#[doc = " @param[in] pid       PID of the targeted network module"]
	#[doc = " @param[in] pkt       pointer into the packet buffer holding the data to send"]
	#[doc = " @param[in] type      type of the message to send. Must be either"]
	#[doc = "                      @ref GNRC_NETAPI_MSG_TYPE_SND or"]
	#[doc = "                      @ref GNRC_NETAPI_MSG_TYPE_RCV"]
	#[doc = ""]
	#[doc = " @return              1 if packet was successfully delivered"]
	#[doc = " @return              -1 on error (invalid PID or no space in queue)"]
	pub fn _gnrc_netapi_send_recv(
		pid: kernel_pid_t,
		pkt: *mut gnrc_pktsnip_t,
		type_: u16,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Shortcut function for sending @ref GNRC_NETAPI_MSG_TYPE_GET or"]
	#[doc = "          @ref GNRC_NETAPI_MSG_TYPE_SET messages and parsing the returned"]
	#[doc = "          @ref GNRC_NETAPI_MSG_TYPE_ACK message"]
	#[doc = ""]
	#[doc = " @param[in] pid       PID of the targeted network module"]
	#[doc = " @param[in] opt       option to get"]
	#[doc = " @param[in] context   (optional) context to the given option"]
	#[doc = " @param[in] data      pointer to buffer for reading the option's value"]
	#[doc = " @param[in] data_len  (maximum) number of bytes in @p data"]
	#[doc = " @param[in] type      type of the message to send. Must be either"]
	#[doc = "                      @ref GNRC_NETAPI_MSG_TYPE_GET or"]
	#[doc = "                      @ref GNRC_NETAPI_MSG_TYPE_SET"]
	#[doc = ""]
	#[doc = " @return              value returned by the @ref GNRC_NETAPI_MSG_TYPE_ACK message i.e. the actual"]
	#[doc = "                      length of the resulting data on success, a negative errno on error. The"]
	#[doc = "                      actual error value is for the implementation to decide but should be"]
	#[doc = "                      sensible to indicate what went wrong."]
	pub fn _gnrc_netapi_get_set(
		pid: kernel_pid_t,
		opt: netopt_t,
		context: u16,
		data: *mut ::core::ffi::c_void,
		data_len: usize,
		type_: u16,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Sends @p cmd to all subscribers to (@p type, @p demux_ctx)."]
	#[doc = ""]
	#[doc = " @param[in] type      protocol type of the targeted network module."]
	#[doc = " @param[in] demux_ctx demultiplexing context for @p type."]
	#[doc = " @param[in] cmd       command for all subscribers"]
	#[doc = " @param[in] pkt       pointer into the packet buffer holding the data to send"]
	#[doc = ""]
	#[doc = " @return Number of subscribers to (@p type, @p demux_ctx)."]
	pub fn gnrc_netapi_dispatch(
		type_: gnrc_nettype_t,
		demux_ctx: u32,
		cmd: u16,
		pkt: *mut gnrc_pktsnip_t,
	) -> ::core::ffi::c_int;
}
#[doc = " @brief   Entry to the @ref net_gnrc_netreg"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gnrc_netreg_entry {
	#[doc = " @brief next element in list"]
	#[doc = ""]
	#[doc = " @internal"]
	pub next: *mut gnrc_netreg_entry,
	#[doc = " @brief   The demultiplexing context for the registering thread."]
	#[doc = ""]
	#[doc = " @details This can be defined by the network protocol themselves."]
	#[doc = "          E. g. protocol numbers / next header numbers in IPv4/IPv6,"]
	#[doc = "          ports in UDP/TCP, or similar."]
	pub demux_ctx: u32,
	#[doc = "< Target for the registry entry"]
	pub target: gnrc_netreg_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gnrc_netreg_entry__bindgen_ty_1 {
	#[doc = "< The PID of the registering thread"]
	pub pid: kernel_pid_t,
}
#[doc = " @brief   Entry to the @ref net_gnrc_netreg"]
pub type gnrc_netreg_entry_t = gnrc_netreg_entry;
extern "C" {
	#[doc = " @brief   Initializes module."]
	pub fn gnrc_netreg_init();
}
extern "C" {
	#[doc = " @brief   Registers a thread to the registry."]
	#[doc = ""]
	#[doc = " @details The semantics are: Thread gnrc_netreg_entry_t::pid is interested in"]
	#[doc = "          packets of protocol @p type with context gnrc_netreg_entry_t::demux_ctx."]
	#[doc = ""]
	#[doc = " @param[in] type      Type of the protocol. Must not be < GNRC_NETTYPE_UNDEF or"]
	#[doc = "                      >= GNRC_NETTYPE_NUMOF."]
	#[doc = " @param[in] entry     An entry you want to add to the registry. This needs to"]
	#[doc = "                      be initialized before hand using the @ref"]
	#[doc = "                      net_gnrc_netreg_init_static \"static\" or @ref"]
	#[doc = "                      net_gnrc_netreg_init_dyn \"dynamic\" initialization"]
	#[doc = "                      helpers."]
	#[doc = ""]
	#[doc = " @warning Call gnrc_netreg_unregister() *before* you leave the context you"]
	#[doc = "          allocated @p entry in. Otherwise it might get overwritten."]
	#[doc = ""]
	#[doc = " @pre The calling thread must provide a [message queue](@ref msg_init_queue)"]
	#[doc = "      when using @ref GNRC_NETREG_TYPE_DEFAULT for gnrc_netreg_entry_t::type"]
	#[doc = "      of @p entry."]
	#[doc = ""]
	#[doc = " @return  0 on success"]
	#[doc = " @return  -EINVAL if @p type was < GNRC_NETTYPE_UNDEF or >= GNRC_NETTYPE_NUMOF"]
	pub fn gnrc_netreg_register(
		type_: gnrc_nettype_t,
		entry: *mut gnrc_netreg_entry_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Removes a thread from the registry."]
	#[doc = ""]
	#[doc = " @param[in] type      Type of the protocol."]
	#[doc = " @param[in] entry     An entry you want to remove from the registry."]
	pub fn gnrc_netreg_unregister(type_: gnrc_nettype_t, entry: *mut gnrc_netreg_entry_t);
}
extern "C" {
	#[doc = " @brief   Searches for entries with given parameters in the registry and"]
	#[doc = "          returns the first found."]
	#[doc = ""]
	#[doc = " @param[in] type      Type of the protocol."]
	#[doc = " @param[in] demux_ctx The demultiplexing context for the registered thread."]
	#[doc = "                      See gnrc_netreg_entry_t::demux_ctx."]
	#[doc = ""]
	#[doc = " @return  The first entry fitting the given parameters on success"]
	#[doc = " @return  NULL if no entry can be found."]
	pub fn gnrc_netreg_lookup(type_: gnrc_nettype_t, demux_ctx: u32) -> *mut gnrc_netreg_entry_t;
}
extern "C" {
	#[doc = " @brief   Returns number of entries with the same gnrc_netreg_entry_t::type and"]
	#[doc = "          gnrc_netreg_entry_t::demux_ctx."]
	#[doc = ""]
	#[doc = " @param[in] type      Type of the protocol."]
	#[doc = " @param[in] demux_ctx The demultiplexing context for the registered thread."]
	#[doc = "                      See gnrc_netreg_entry_t::demux_ctx."]
	#[doc = ""]
	#[doc = " @return  Number of entries with the same gnrc_netreg_entry_t::type and"]
	#[doc = "          gnrc_netreg_entry_t::demux_ctx as the given parameters."]
	pub fn gnrc_netreg_num(type_: gnrc_nettype_t, demux_ctx: u32) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Returns the next entry after @p entry with the same"]
	#[doc = "          gnrc_netreg_entry_t::type and gnrc_netreg_entry_t::demux_ctx as the"]
	#[doc = "          given entry."]
	#[doc = ""]
	#[doc = " @param[in] entry     A registry entry retrieved by gnrc_netreg_lookup() or"]
	#[doc = "                      gnrc_netreg_getnext(). Must not be NULL."]
	#[doc = ""]
	#[doc = " @return  The next entry after @p entry fitting the given parameters on success"]
	#[doc = " @return  NULL if no entry new entry can be found."]
	pub fn gnrc_netreg_getnext(entry: *mut gnrc_netreg_entry_t) -> *mut gnrc_netreg_entry_t;
}
extern "C" {
	#[doc = " @brief   Calculates the checksum for a header."]
	#[doc = ""]
	#[doc = " @param[in] hdr           The header the checksum should be calculated"]
	#[doc = "                          for."]
	#[doc = " @param[in] pseudo_hdr    The header the pseudo header shall be generated"]
	#[doc = "                          from. NULL if none is needed."]
	#[doc = ""]
	#[doc = " @return  0, on success."]
	#[doc = " @return  -EINVAL, if @p pseudo_hdr is NULL but a pseudo header was required."]
	#[doc = " @return  -ENOENT, if @ref net_gnrc_netreg does not know how to calculate checksum"]
	#[doc = "          for gnrc_pktsnip_t::type of @p hdr."]
	pub fn gnrc_netreg_calc_csum(
		hdr: *mut gnrc_pktsnip_t,
		pseudo_hdr: *mut gnrc_pktsnip_t,
	) -> ::core::ffi::c_int;
}
#[doc = " @name DHCPv6 unique identifier (DUID) definitions"]
#[doc = " @see [RFC 8415, section 11](https://tools.ietf.org/html/rfc8415#section-11)"]
#[doc = " @{"]
#[doc = " @brief   DUID based on link-layer address plus time"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct dhcpv6_duid_l2_t {
	#[doc = "< @ref DHCPV6_DUID_TYPE_L2"]
	pub type_: network_uint16_t,
	#[doc = "< [hardware type](@ref net_arp_hwtype))"]
	pub l2type: network_uint16_t,
}
extern "C" {
	#[doc = " @brief   Initializes the client"]
	#[doc = ""]
	#[doc = " @pre `event_queue->waiter != NULL`"]
	#[doc = ""]
	#[doc = " @param[in] event_queue   Event queue to use with the client. Needs to be"]
	#[doc = "                          initialized in the handler thread."]
	#[doc = " @param[in] netif         The network interface the client should listen on."]
	#[doc = "                          SOCK_ADDR_ANY_NETIF for any interface"]
	pub fn dhcpv6_client_init(event_queue: *mut event_queue_t, netif: u16);
}
extern "C" {
	#[doc = " @brief   Let the server start listening"]
	#[doc = ""]
	#[doc = " @pre @ref dhcpv6_client_init() was called (i.e. the internal event queue of"]
	#[doc = "      he client was set)."]
	#[doc = ""]
	#[doc = " This needs to be called *after* all desired [configuration functions]"]
	#[doc = " (@ref net_dhcpv6_client_conf) and @ref dhcpv6_client_init() were called."]
	pub fn dhcpv6_client_start();
}
extern "C" {
	#[doc = " @name    Configuration functions"]
	#[doc = " @anchor  net_dhcpv6_client_conf"]
	#[doc = " @{"]
	#[doc = " @brief   Configures the client to request prefix delegation for a network"]
	#[doc = "          interface from a server"]
	#[doc = ""]
	#[doc = " @pre Module `dhcpv6_client_ia_pd` is compiled in."]
	#[doc = " @pre `pfx_len <= 128`"]
	#[doc = ""]
	#[doc = " Without module `dhcpv6_client_ia_pd` and `NDEBUG` set this function is a NOP."]
	#[doc = " Without module `dhcpv6_client_ia_pd` and `NDEBUG` unset this function will"]
	#[doc = " abort the running code on a failed assertion."]
	#[doc = ""]
	#[doc = " @param[in] netif     The interface to request the prefix delegation for."]
	#[doc = " @param[in] pfx_len   The desired length of the prefix (note that the server"]
	#[doc = "                      might not consider this request). Must be <= 128"]
	pub fn dhcpv6_client_req_ia_pd(netif: ::core::ffi::c_uint, pfx_len: ::core::ffi::c_uint);
}
extern "C" {
	#[doc = " @brief   Configures the client to request non-temporary addresses for a network"]
	#[doc = "          interface from a server"]
	#[doc = " @note    For multi-hop WPAN meshes a DHCPv6 relay (which is not implemented in"]
	#[doc = "          RIOT yet) is required, as DHCPv6 only acts in link scope."]
	#[doc = ""]
	#[doc = " @param[in] netif     The interface to request non-temporaty addresses for."]
	#[doc = ""]
	#[doc = " @retval 0 on success"]
	#[doc = " @retval -ENOMEM when there is no lease entry available anymore"]
	#[doc = " @retval -ENOTSUP when module `dhcpv6_client_ia_na` is not being used"]
	pub fn dhcpv6_client_req_ia_na(netif: ::core::ffi::c_uint) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @name    Stack-specific functions"]
	#[doc = ""]
	#[doc = " These functions need to be provided by the network-stack implementation."]
	#[doc = " @{"]
	#[doc = " @brief   Get the link-layer address DUID for the client"]
	#[doc = ""]
	#[doc = " @param[in] netif The network interface the client is bound to. May be"]
	#[doc = "                  SOCK_ADDR_ANY_NETIF for any interface."]
	#[doc = " @param[out] duid The resulting DUID."]
	#[doc = ""]
	#[doc = " @return  length of the @p duid on success."]
	#[doc = " @return  0, on error."]
	pub fn dhcpv6_client_get_duid_l2(
		netif: ::core::ffi::c_uint,
		duid: *mut dhcpv6_duid_l2_t,
	) -> ::core::ffi::c_uint;
}
extern "C" {
	#[doc = " @brief   Configures a prefix delegation lease that is provided by the server."]
	#[doc = ""]
	#[doc = " @param[in] netif     Network interface the prefix delegation was for."]
	#[doc = " @param[in] pfx       Prefix for the prefix delegation."]
	#[doc = " @param[in] pfx_len   Length of @p pfx in bits."]
	#[doc = " @param[in] valid     Valid lifetime of the prefix delegation."]
	#[doc = " @param[in] pref      Preferred lifetime of the prefix delegation."]
	pub fn dhcpv6_client_conf_prefix(
		netif: ::core::ffi::c_uint,
		pfx: *const ipv6_addr_t,
		pfx_len: ::core::ffi::c_uint,
		valid: u32,
		pref: u32,
	);
}
extern "C" {
	#[doc = " @brief   Checks if the given network interface is configured"]
	#[doc = "          to use DHCPv6 IA_NA"]
	#[doc = ""]
	#[doc = " @param[in] netif     Network interface to check."]
	#[doc = ""]
	#[doc = " @return  true, if the network interface is set up for IA_NA."]
	pub fn dhcpv6_client_check_ia_na(netif: ::core::ffi::c_uint) -> bool;
}
extern "C" {
	#[doc = " @brief   Determines how long the prefix delegation lease is still valid."]
	#[doc = ""]
	#[doc = " @param[in] netif     Network interface the prefix delegation was for."]
	#[doc = " @param[in] pfx       Prefix of the prefix delegation"]
	#[doc = " @param[in] pfx_len   Length of @p pfx in bits."]
	#[doc = ""]
	#[doc = " @return  Remaining valid lifetime of the prefix delegation lease in seconds."]
	pub fn dhcpv6_client_prefix_valid_until(
		netif: ::core::ffi::c_uint,
		pfx: *const ipv6_addr_t,
		pfx_len: ::core::ffi::c_uint,
	) -> u32;
}
pub const DHCPV6_CLIENT_CONF_MODE_INACTIVE: _bindgen_ty_6 = 0;
pub const DHCPV6_CLIENT_CONF_MODE_STATEFUL: _bindgen_ty_6 = 1;
pub const DHCPV6_CLIENT_CONF_MODE_STATELESS: _bindgen_ty_6 = 2;
#[doc = " @brief Definition of DHCPv6 client configuration modes."]
pub type _bindgen_ty_6 = ::core::ffi::c_uint;
extern "C" {
	#[doc = " @brief   Changes the DHCPv6 client's configuration mode."]
	#[doc = ""]
	#[doc = " @param[in] configuration_mode       The new configuration mode."]
	pub fn dhcpv6_client_set_conf_mode(configuration_mode: u8);
}
extern "C" {
	#[doc = " @brief   Retrieves the DHCPv6 client's current configuration mode."]
	#[doc = ""]
	#[doc = " @return  The current configuration mode."]
	pub fn dhcpv6_client_get_conf_mode() -> u8;
}
#[doc = " @brief Data type to represent an EUI-64."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union eui64_t {
	#[doc = "< represented as 64 bit value"]
	pub uint64: network_uint64_t,
	#[doc = "< split into 8 8-bit words."]
	pub uint8: [u8; 8usize],
	#[doc = "< split into 4 16-bit words."]
	pub uint16: [network_uint16_t; 4usize],
	#[doc = "< split into 2 32-bit words."]
	pub uint32: [network_uint32_t; 2usize],
}
#[doc = "< PHY disabled, no mode selected"]
pub const ieee802154_phy_mode_t_IEEE802154_PHY_DISABLED: ieee802154_phy_mode_t = 0;
#[doc = "< Binary Phase Shift Keying"]
pub const ieee802154_phy_mode_t_IEEE802154_PHY_BPSK: ieee802154_phy_mode_t = 1;
#[doc = "< Amplitude-Shift Keying"]
pub const ieee802154_phy_mode_t_IEEE802154_PHY_ASK: ieee802154_phy_mode_t = 2;
#[doc = "< Offset Quadrature Phase-Shift Keying"]
pub const ieee802154_phy_mode_t_IEEE802154_PHY_OQPSK: ieee802154_phy_mode_t = 3;
#[doc = "< Multi-Rate Offset Quadrature Phase-Shift Keying"]
pub const ieee802154_phy_mode_t_IEEE802154_PHY_MR_OQPSK: ieee802154_phy_mode_t = 4;
#[doc = "< Multi-Rate Orthogonal Frequency-Division Multiplexing"]
pub const ieee802154_phy_mode_t_IEEE802154_PHY_MR_OFDM: ieee802154_phy_mode_t = 5;
#[doc = "< Multi-Rate Frequency Shift Keying"]
pub const ieee802154_phy_mode_t_IEEE802154_PHY_MR_FSK: ieee802154_phy_mode_t = 6;
#[doc = " @brief   802.15.4 PHY modes"]
pub type ieee802154_phy_mode_t = ::core::ffi::c_uint;
#[doc = "< no forward error correction"]
pub const IEEE802154_FEC_NONE: _bindgen_ty_7 = 0;
#[doc = "< non-recursive and non-systematic code"]
pub const IEEE802154_FEC_NRNSC: _bindgen_ty_7 = 1;
#[doc = "< recursive and systematic code"]
pub const IEEE802154_FEC_RSC: _bindgen_ty_7 = 2;
#[doc = " @brief   802.15.4 forward error correction schemes"]
pub type _bindgen_ty_7 = ::core::ffi::c_uint;
extern "C" {
	#[doc = " @brief   Broadcast address"]
	pub static ieee802154_addr_bcast: [u8; 2usize];
}
extern "C" {
	#[doc = " @brief   Initializes an IEEE 802.15.4 MAC frame header in @p buf."]
	#[doc = ""]
	#[doc = " @pre Resulting header must fit in memory allocated at @p buf."]
	#[doc = ""]
	#[doc = " @see IEEE Std 802.15.4-2011, 5.2.1 General MAC frame format."]
	#[doc = ""]
	#[doc = " If @p dst is NULL the IEEE802154_FCF_ACK_REQ will be unset to prevent"]
	#[doc = " flooding the network."]
	#[doc = ""]
	#[doc = " @param[out] buf      Target memory for frame header."]
	#[doc = " @param[in] src       Source address for frame in network byteorder."]
	#[doc = "                      May be NULL if @ref IEEE802154_FCF_SRC_ADDR_VOID is set"]
	#[doc = "                      in @p flags."]
	#[doc = " @param[in] src_len   Length of @p src. Legal values are:"]
	#[doc = "                      * 0 (will set @ref IEEE802154_FCF_SRC_ADDR_VOID in MHR)"]
	#[doc = "                      * 2 (will set @ref IEEE802154_FCF_SRC_ADDR_SHORT in MHR)"]
	#[doc = "                      * 8 (will set @ref IEEE802154_FCF_SRC_ADDR_LONG in MHR)"]
	#[doc = " @param[in] dst       Destination address for frame in network byteorder."]
	#[doc = "                      May be NULL if @ref IEEE802154_FCF_SRC_ADDR_VOID is set"]
	#[doc = "                      in @p flags."]
	#[doc = " @param[in] dst_len   Length of @p dst. Legal values are:"]
	#[doc = "                      * 0 (will set @ref IEEE802154_FCF_DST_ADDR_VOID in MHR)"]
	#[doc = "                      * 2 (will set @ref IEEE802154_FCF_DST_ADDR_SHORT in MHR)"]
	#[doc = "                      * 8 (will set @ref IEEE802154_FCF_DST_ADDR_LONG in MHR)"]
	#[doc = " @param[in] src_pan   Source PAN ID in little-endian. May be 0 if"]
	#[doc = "                      @ref IEEE802154_FCF_PAN_COMP is set in @p flags."]
	#[doc = "                      Otherwise, it will be ignored, when"]
	#[doc = "                      @ref IEEE802154_FCF_PAN_COMP is set."]
	#[doc = " @param[in] dst_pan   Destination PAN ID in little-endian."]
	#[doc = " @param[in] flags     Flags for the frame. These are interchangeable with the"]
	#[doc = "                      first byte of the IEEE 802.15.4 FCF. This means that"]
	#[doc = "                      it encompasses the type values,"]
	#[doc = "                      @ref IEEE802154_FCF_SECURITY_EN,"]
	#[doc = "                      @ref IEEE802154_FCF_FRAME_PEND, and"]
	#[doc = "                      @ref IEEE802154_FCF_ACK_REQ."]
	#[doc = " @param[in] seq       Sequence number for frame."]
	#[doc = ""]
	#[doc = " The version field in the FCF will be set implicitly to version 1."]
	#[doc = ""]
	#[doc = " @return  Size of frame header on success."]
	#[doc = " @return  0, on error (flags set to unexpected state)."]
	pub fn ieee802154_set_frame_hdr(
		buf: *mut u8,
		src: *const u8,
		src_len: usize,
		dst: *const u8,
		dst_len: usize,
		src_pan: le_uint16_t,
		dst_pan: le_uint16_t,
		flags: u8,
		seq: u8,
	) -> usize;
}
extern "C" {
	#[doc = " @brief   Get length of MAC header."]
	#[doc = ""]
	#[doc = " @todo include security header implications"]
	#[doc = ""]
	#[doc = " @param[in] mhr   MAC header."]
	#[doc = ""]
	#[doc = " @return  Length of MAC header on success."]
	#[doc = " @return  0, on error (source mode or destination mode set to reserved)."]
	pub fn ieee802154_get_frame_hdr_len(mhr: *const u8) -> usize;
}
extern "C" {
	#[doc = " @brief   Gets source address from MAC header."]
	#[doc = ""]
	#[doc = " @pre (@p src != NULL) && (@p src_pan != NULL)"]
	#[doc = ""]
	#[doc = " @param[in] mhr       MAC header."]
	#[doc = " @param[out] src      Source address in network byte order in MAC header."]
	#[doc = " @param[out] src_pan  Source PAN little-endian byte order in MAC header."]
	#[doc = ""]
	#[doc = " @return   Length of source address."]
	#[doc = " @return  -EINVAL, if @p mhr contains unexpected flags."]
	pub fn ieee802154_get_src(
		mhr: *const u8,
		src: *mut u8,
		src_pan: *mut le_uint16_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Gets destination address from MAC header."]
	#[doc = ""]
	#[doc = " @pre (@p dst != NULL) && (@p dst_pan != NULL)"]
	#[doc = ""]
	#[doc = " @param[in] mhr       MAC header."]
	#[doc = " @param[out] dst      Destination address in network byte order in MAC header."]
	#[doc = " @param[out] dst_pan  Destination PAN in little-endian byte order in MAC header."]
	#[doc = ""]
	#[doc = " @return   Length of destination address."]
	#[doc = " @return  -EINVAL, if @p mhr contains unexpected flags."]
	pub fn ieee802154_get_dst(
		mhr: *const u8,
		dst: *mut u8,
		dst_pan: *mut le_uint16_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief  Check whether a frame pass the IEEE 802.15.4 frame filter."]
	#[doc = ""]
	#[doc = " A frame passes the frame filter only if:"]
	#[doc = " - The PAN ID matches the PAN ID of the frame filter or the broadcast PAN ID"]
	#[doc = " - Either the Short or Extended Address matches the frame filter OR the"]
	#[doc = "   Short Address is the broadcast address."]
	#[doc = ""]
	#[doc = " @param[in] mhr           MAC header (PSDU)"]
	#[doc = " @param[in] pan           PAN ID of the frame filter."]
	#[doc = " @param[in] short_addr    Short Address of the frame filter."]
	#[doc = " @param[in] ext_addr      Extended Address of the frame filter."]
	#[doc = ""]
	#[doc = " @return 0            if frame passes the frame filter."]
	#[doc = " @return 1            if frame doesn't pass the frame filter."]
	pub fn ieee802154_dst_filter(
		mhr: *const u8,
		pan: u16,
		short_addr: network_uint16_t,
		ext_addr: *const eui64_t,
	) -> ::core::ffi::c_int;
}
#[doc = " @brief   Ethernet header"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ethernet_hdr_t {
	#[doc = "< destination address"]
	pub dst: [u8; 6usize],
	#[doc = "< source address"]
	pub src: [u8; 6usize],
	#[doc = "< ether type (see @ref net_ethertype)"]
	pub type_: network_uint16_t,
}
#[doc = "< no configuration"]
pub const GNRC_NETIF_AAC_NONE: _bindgen_ty_8 = 0;
#[doc = "< Use some automatic bootstrapping (e.g. SLAAC with IPv6)"]
pub const GNRC_NETIF_AAC_AUTO: _bindgen_ty_8 = 1;
#[doc = "< Use DHCP(v6)"]
pub const GNRC_NETIF_AAC_DHCP: _bindgen_ty_8 = 2;
#[doc = " @brief   Auto-address configuration modes"]
#[doc = " @anchor  net_gnrc_netif_aac"]
pub type _bindgen_ty_8 = ::core::ffi::c_uint;
#[doc = " @brief   Router solicitation message format."]
#[doc = " @extends icmpv6_hdr_t"]
#[doc = ""]
#[doc = " @see     [RFC 4861, section 4.1](https://tools.ietf.org/html/rfc4861#section-4.1)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndp_rtr_sol_t {
	#[doc = "< message type"]
	pub type_: u8,
	#[doc = "< message code"]
	pub code: u8,
	#[doc = "< checksum"]
	pub csum: network_uint16_t,
	#[doc = "< reserved field"]
	pub resv: network_uint32_t,
}
#[doc = " @brief   Router advertisement message format."]
#[doc = " @extends icmpv6_hdr_t"]
#[doc = ""]
#[doc = " @see     [RFC 4861, section 4.2](https://tools.ietf.org/html/rfc4861#section-4.2)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndp_rtr_adv_t {
	#[doc = "< message type"]
	pub type_: u8,
	#[doc = "< message code"]
	pub code: u8,
	#[doc = "< checksum"]
	pub csum: network_uint16_t,
	#[doc = "< current hop limit"]
	pub cur_hl: u8,
	#[doc = "< flags"]
	pub flags: u8,
	#[doc = "< router lifetime"]
	pub ltime: network_uint16_t,
	#[doc = "< reachable time"]
	pub reach_time: network_uint32_t,
	#[doc = "< retransmission timer"]
	pub retrans_timer: network_uint32_t,
}
#[doc = " @brief   Neighbor solicitation message format."]
#[doc = " @extends icmpv6_hdr_t"]
#[doc = ""]
#[doc = " @see     [RFC 4861, section 4.3](https://tools.ietf.org/html/rfc4861#section-4.3)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndp_nbr_sol_t {
	#[doc = "< message type"]
	pub type_: u8,
	#[doc = "< message code"]
	pub code: u8,
	#[doc = "< checksum"]
	pub csum: network_uint16_t,
	#[doc = "< reserved field"]
	pub resv: network_uint32_t,
	#[doc = "< target address"]
	pub tgt: ipv6_addr_t,
}
#[doc = " @brief   Neighbor advertisement message format."]
#[doc = " @extends icmpv6_hdr_t"]
#[doc = ""]
#[doc = " @see     [RFC 4861, section 4.4](https://tools.ietf.org/html/rfc4861#section-4.4)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndp_nbr_adv_t {
	#[doc = "< message type"]
	pub type_: u8,
	#[doc = "< message code"]
	pub code: u8,
	#[doc = "< checksum"]
	pub csum: network_uint16_t,
	#[doc = "< flags"]
	pub flags: u8,
	#[doc = "< reserved fields"]
	pub resv: [u8; 3usize],
	#[doc = "< target address"]
	pub tgt: ipv6_addr_t,
}
#[doc = " @brief   Redirect message format."]
#[doc = " @extends icmpv6_hdr_t"]
#[doc = ""]
#[doc = " @see     [RFC 4861, section 4.5](https://tools.ietf.org/html/rfc4861#section-4.5)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndp_redirect_t {
	#[doc = "< message type"]
	pub type_: u8,
	#[doc = "< message code"]
	pub code: u8,
	#[doc = "< checksum"]
	pub csum: network_uint16_t,
	#[doc = "< reserved field"]
	pub resv: network_uint32_t,
	#[doc = "< target address"]
	pub tgt: ipv6_addr_t,
	#[doc = "< destination address"]
	pub dst: ipv6_addr_t,
}
#[doc = " @brief   General NDP option format"]
#[doc = " @see     [RFC 4861, section 4.6](https://tools.ietf.org/html/rfc4861#section-4.6)"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndp_opt_t {
	#[doc = "< option type"]
	pub type_: u8,
	#[doc = "< length in units of 8 octets"]
	pub len: u8,
}
#[doc = " @brief   Prefix information option format"]
#[doc = " @extends ndp_opt_t"]
#[doc = ""]
#[doc = " @see     [RFC 4861, section 4.6.2](https://tools.ietf.org/html/rfc4861#section-4.6.2)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndp_opt_pi_t {
	#[doc = "< option type"]
	pub type_: u8,
	#[doc = "< length in units of 8 octets"]
	pub len: u8,
	#[doc = "< prefix length"]
	pub prefix_len: u8,
	#[doc = "< flags"]
	pub flags: u8,
	#[doc = "< valid lifetime"]
	pub valid_ltime: network_uint32_t,
	#[doc = "< preferred lifetime"]
	pub pref_ltime: network_uint32_t,
	#[doc = "< reserved field"]
	pub resv: network_uint32_t,
	#[doc = "< prefix"]
	pub prefix: ipv6_addr_t,
}
#[doc = " @brief   Route information option format"]
#[doc = " @extends ndp_opt_t"]
#[doc = ""]
#[doc = " @see     [RFC 4191, section 2.3](https://tools.ietf.org/html/rfc4191#section-2.3)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndp_opt_ri_t {
	#[doc = "< option type"]
	pub type_: u8,
	#[doc = "< length in units of 8 octets"]
	pub len: u8,
	#[doc = "< prefix length"]
	pub prefix_len: u8,
	#[doc = "< flags"]
	pub flags: u8,
	#[doc = "< route lifetime"]
	pub route_ltime: network_uint32_t,
	#[doc = "< prefix"]
	pub prefix: ipv6_addr_t,
}
#[doc = " @brief   Redirected header option format"]
#[doc = " @extends ndp_opt_t"]
#[doc = ""]
#[doc = " @see     [RFC 4861, section 4.6.3](https://tools.ietf.org/html/rfc4861#section-4.6.3)"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ndp_opt_rh_t {
	#[doc = "< option type"]
	pub type_: u8,
	#[doc = "< length in units of 8 octets"]
	pub len: u8,
	#[doc = "< reserved field"]
	pub resv: [u8; 6usize],
}
#[doc = " @brief   MTU option format"]
#[doc = " @extends ndp_opt_t"]
#[doc = ""]
#[doc = " @see     [RFC 4861, section 4.6.4](https://tools.ietf.org/html/rfc4861#section-4.6.4)"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndp_opt_mtu_t {
	#[doc = "< option type"]
	pub type_: u8,
	#[doc = "< length in units of 8 octets"]
	pub len: u8,
	#[doc = "< reserved field"]
	pub resv: network_uint16_t,
	#[doc = "< MTU"]
	pub mtu: network_uint32_t,
}
#[doc = " @brief   Recursive DNS server option format without payload"]
#[doc = " @extends ndp_opt_t"]
#[doc = ""]
#[doc = " @see     [RFC 8106, section 5.1](https://tools.ietf.org/html/rfc8106#section-5.1)"]
#[doc = " @see     ndp_opt_rdnss_impl_t"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ndp_opt_rdnss_t {
	#[doc = "< option type"]
	pub type_: u8,
	#[doc = "< length in units of 8 octets"]
	pub len: u8,
	#[doc = "< reserved field"]
	pub resv: network_uint16_t,
	#[doc = "< lifetime in seconds"]
	pub ltime: network_uint32_t,
}
#[doc = " @brief   Recursive DNS server option format with payload"]
#[doc = " @extends ndp_opt_rdnss_t"]
#[doc = " @details Auxiliary struct that contains a zero-length array as convenience"]
#[doc = "          pointer to the addresses. Only for use in C, invalid in ISO-C++."]
#[doc = ""]
#[doc = " @see     [RFC 8106, section 5.1](https://tools.ietf.org/html/rfc8106#section-5.1)"]
#[repr(C, packed)]
pub struct ndp_opt_rdnss_impl_t {
	#[doc = "< option type"]
	pub type_: u8,
	#[doc = "< length in units of 8 octets"]
	pub len: u8,
	#[doc = "< reserved field"]
	pub resv: network_uint16_t,
	#[doc = "< lifetime in seconds"]
	pub ltime: network_uint32_t,
	#[doc = "< addresses of IPv6 recursive DNS servers"]
	pub addrs: __IncompleteArrayField<ipv6_addr_t>,
}
extern "C" {
	#[doc = " @brief   Converts a given hardware address to an EUI-64."]
	#[doc = ""]
	#[doc = " @attention When the link-layer of the interface has link-layer addresses, and"]
	#[doc = "            `NDEBUG` is not defined, the node fails with an assertion instead"]
	#[doc = "            returning `-ENOTSUP`."]
	#[doc = ""]
	#[doc = " @param[in] dev_type  The network device type of the device @p addr came from"]
	#[doc = "                      (either because it is the configured address of the"]
	#[doc = "                      device or from a packet that came over it)."]
	#[doc = " @param[in] addr      A hardware address."]
	#[doc = " @param[in] addr_len  Number of bytes in @p addr."]
	#[doc = " @param[out] eui64    The EUI-64 based on gnrc_netif_t::device_type"]
	#[doc = ""]
	#[doc = " @return  `sizeof(eui64_t)` on success."]
	#[doc = " @return  `-ENOTSUP`, when @p dev_type does not support EUI-64 conversion."]
	#[doc = " @return  `-EINVAL`, when @p addr_len is invalid for the @p dev_type."]
	pub fn l2util_eui64_from_addr(
		dev_type: ::core::ffi::c_int,
		addr: *const u8,
		addr_len: usize,
		eui64: *mut eui64_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Converts a given hardware address to an IPv6 IID."]
	#[doc = ""]
	#[doc = " @attention When the link-layer of the interface has link-layer addresses, and"]
	#[doc = "            `NDEBUG` is not defined, the node fails with an assertion instead"]
	#[doc = "            returning `-ENOTSUP`."]
	#[doc = ""]
	#[doc = " @param[in] dev_type  The network device type of the device @p addr came from"]
	#[doc = "                      (either because it is the configured address of the"]
	#[doc = "                      device or from a packet that came over it)."]
	#[doc = " @param[in] addr      A hardware address."]
	#[doc = " @param[in] addr_len  Number of bytes in @p addr."]
	#[doc = " @param[out] iid      The IID based on gnrc_netif_t::device_type"]
	#[doc = ""]
	#[doc = " @return  `sizeof(eui64_t)` on success."]
	#[doc = " @return  `-ENOTSUP`, when @p dev_type does not support IID conversion."]
	#[doc = " @return  `-EINVAL`, when @p addr_len is invalid for the @p dev_type."]
	pub fn l2util_ipv6_iid_from_addr(
		dev_type: ::core::ffi::c_int,
		addr: *const u8,
		addr_len: usize,
		iid: *mut eui64_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Converts an IPv6 IID to a hardware address"]
	#[doc = ""]
	#[doc = " @pre @p iid was based on a hardware address"]
	#[doc = " @pre The number of bytes available at @p addr is less or equal to"]
	#[doc = "      @ref L2UTIL_ADDR_MAX_LEN."]
	#[doc = ""]
	#[doc = " @attention   When `NDEBUG` is not defined, the node fails with an assertion"]
	#[doc = "              instead of returning `-ENOTSUP`"]
	#[doc = ""]
	#[doc = " @param[in] dev_type  The network device type of the device the @p iid came"]
	#[doc = "                      from (either because it is based on the configured"]
	#[doc = "                      address of the device or from a packet that came over"]
	#[doc = "                      it)."]
	#[doc = " @param[in] iid       An IID based on @p dev_type."]
	#[doc = " @param[out] addr     The hardware address. It is assumed that @p iid was"]
	#[doc = "                      based on a hardware address and that the available"]
	#[doc = "                      number of bytes in @p addr are greater or equal to"]
	#[doc = "                      @ref L2UTIL_ADDR_MAX_LEN."]
	#[doc = ""]
	#[doc = " @return  Length of resulting @p addr on success."]
	#[doc = " @return  `-ENOTSUP`, when @p dev_type does not support reverse IID"]
	#[doc = "          conversion."]
	pub fn l2util_ipv6_iid_to_addr(
		dev_type: ::core::ffi::c_int,
		iid: *const eui64_t,
		addr: *mut u8,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Derives the length of the link-layer address in an NDP link-layer"]
	#[doc = "          address option from that option's length field and the given device"]
	#[doc = "          type."]
	#[doc = ""]
	#[doc = " @note    If an RFC exists that specifies how IPv6 operates over a link-layer,"]
	#[doc = "          this function usually implements the section \"Unicast Address"]
	#[doc = "          Mapping\"."]
	#[doc = ""]
	#[doc = " @see [RFC 4861, section 4.6.1](https://tools.ietf.org/html/rfc4861#section-4.6.1)"]
	#[doc = ""]
	#[doc = " @attention   When `NDEBUG` is not defined, the node fails with an assertion"]
	#[doc = "              instead of returning `-ENOTSUP`"]
	#[doc = ""]
	#[doc = " @param[in] dev_type  The network device type of the device the @p opt came"]
	#[doc = "                      over in an NDP message."]
	#[doc = " @param[in] opt       An NDP source/target link-layer address option."]
	#[doc = ""]
	#[doc = " @return  Length of the link-layer address in @p opt on success"]
	#[doc = " @return  `-ENOTSUP`, when implementation does not know how to derive the"]
	#[doc = "          length of the link-layer address from @p opt's length field based"]
	#[doc = "          on @p dev_type."]
	#[doc = " @return  `-EINVAL` if `opt->len` was an invalid value for the given"]
	#[doc = "          @p dev_type."]
	pub fn l2util_ndp_addr_len_from_l2ao(
		dev_type: ::core::ffi::c_int,
		opt: *const ndp_opt_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Converts an IPv6 multicast address to a multicast address"]
	#[doc = "          of the respective link layer."]
	#[doc = ""]
	#[doc = " @pre There is enough allocated space in @p l2_group for an address for a"]
	#[doc = "      device of type @p dev_type (e.g. 6 bytes for an ethernet address)."]
	#[doc = ""]
	#[doc = " @param[in] dev_type      The network device type of the device @p l2_addr"]
	#[doc = "                          should be generated for."]
	#[doc = " @param[in] ipv6_group    An IPv6 multicast address."]
	#[doc = " @param[out] l2_group     A link layer multicast address"]
	#[doc = ""]
	#[doc = " @return  Length of @p l2_group in bytes"]
	#[doc = " @return  `-ENOTSUP` if link layer does not support multicast."]
	pub fn l2util_ipv6_group_to_l2_group(
		dev_type: ::core::ffi::c_int,
		ipv6_group: *const ipv6_addr_t,
		l2_group: *mut u8,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Converts a hardware address to a human readable string."]
	#[doc = ""]
	#[doc = " @details The format will be like `xx:xx:xx:xx` where `xx` are the bytes"]
	#[doc = "          of @p addr in hexadecimal representation."]
	#[doc = ""]
	#[doc = " @pre `(out != NULL) && ((addr != NULL) || (addr_len == 0))`"]
	#[doc = " @pre @p out **MUST** have allocated at least 3 * @p addr_len bytes."]
	#[doc = ""]
	#[doc = " @param[in] addr      A hardware address."]
	#[doc = " @param[in] addr_len  Length of @p addr."]
	#[doc = " @param[out] out      A string to store the output in. Must at least have"]
	#[doc = "                      3 * @p addr_len bytes allocated."]
	#[doc = ""]
	#[doc = " @return  @p out."]
	pub fn l2util_addr_to_str(
		addr: *const u8,
		addr_len: usize,
		out: *mut ::core::ffi::c_char,
	) -> *mut ::core::ffi::c_char;
}
extern "C" {
	#[doc = " @brief   Parses a string of colon-separated hexadecimals to a hardware"]
	#[doc = "          address."]
	#[doc = ""]
	#[doc = " @details The input format must be like `xx:xx:xx:xx` where `xx` will be the"]
	#[doc = "          bytes of @p addr in hexadecimal representation."]
	#[doc = ""]
	#[doc = " @pre `(out != NULL)`"]
	#[doc = " @pre @p out **MUST** have allocated at least"]
	#[doc = "      @ref GNRC_NETIF_L2ADDR_MAXLEN bytes."]
	#[doc = ""]
	#[doc = " @param[in] str       A string of colon-separated hexadecimals."]
	#[doc = " @param[out] out      The resulting hardware address. Must at least have"]
	#[doc = "                      @ref GNRC_NETIF_L2ADDR_MAXLEN bytes allocated."]
	#[doc = ""]
	#[doc = " @return  Actual length of @p out on success."]
	#[doc = " @return  0, on failure."]
	pub fn l2util_addr_from_str(str_: *const ::core::ffi::c_char, out: *mut u8) -> usize;
}
pub const NETDEV_TYPE_UNKNOWN: _bindgen_ty_9 = 0;
pub const NETDEV_TYPE_TEST: _bindgen_ty_9 = 1;
pub const NETDEV_TYPE_RAW: _bindgen_ty_9 = 2;
pub const NETDEV_TYPE_ETHERNET: _bindgen_ty_9 = 3;
pub const NETDEV_TYPE_IEEE802154: _bindgen_ty_9 = 4;
pub const NETDEV_TYPE_BLE: _bindgen_ty_9 = 5;
pub const NETDEV_TYPE_CC110X: _bindgen_ty_9 = 6;
pub const NETDEV_TYPE_LORA: _bindgen_ty_9 = 7;
pub const NETDEV_TYPE_NRFMIN: _bindgen_ty_9 = 8;
pub const NETDEV_TYPE_NRF24L01P_NG: _bindgen_ty_9 = 9;
pub const NETDEV_TYPE_SLIP: _bindgen_ty_9 = 10;
pub const NETDEV_TYPE_ESP_NOW: _bindgen_ty_9 = 11;
#[doc = " @name        Network device types"]
#[doc = " @anchor      net_netdev_type"]
#[doc = " @attention   When implementing a new type that is able to carry IPv6, have"]
#[doc = "              a look if you need to update @ref net_l2util as well."]
#[doc = " @{"]
pub type _bindgen_ty_9 = ::core::ffi::c_uint;
#[doc = "< driver needs it's ISR handled"]
pub const netdev_event_t_NETDEV_EVENT_ISR: netdev_event_t = 0;
#[doc = "< started to receive a frame"]
pub const netdev_event_t_NETDEV_EVENT_RX_STARTED: netdev_event_t = 1;
#[doc = "< finished receiving a frame"]
pub const netdev_event_t_NETDEV_EVENT_RX_COMPLETE: netdev_event_t = 2;
#[doc = "< started to transfer a frame"]
pub const netdev_event_t_NETDEV_EVENT_TX_STARTED: netdev_event_t = 3;
#[doc = "< transfer frame complete"]
pub const netdev_event_t_NETDEV_EVENT_TX_COMPLETE: netdev_event_t = 4;
#[doc = " @brief   transfer frame complete and data pending flag"]
#[doc = ""]
#[doc = " @deprecated  Issue an NETDEV_EVENT_TX_COMPLETE event instead and pass"]
#[doc = "              the data pending info in netdev_driver_t::confirm_send"]
#[doc = "              via the `info` parameter"]
pub const netdev_event_t_NETDEV_EVENT_TX_COMPLETE_DATA_PENDING: netdev_event_t = 5;
#[doc = " @brief   ACK requested but not received"]
#[doc = ""]
#[doc = " @deprecated  Issue an NETDEV_EVENT_TX_COMPLETE event instead and return"]
#[doc = "              `-ECOMM` in netdev_driver_t::confirm_send. Via the `info`"]
#[doc = "              parameter additional details about the error can be passed"]
pub const netdev_event_t_NETDEV_EVENT_TX_NOACK: netdev_event_t = 6;
#[doc = " @brief   couldn't transfer frame"]
#[doc = ""]
#[doc = " @deprecated  Issue an NETDEV_EVENT_TX_COMPLETE event instead and return"]
#[doc = "              `-EBUSY` in netdev_driver_t::confirm_send."]
pub const netdev_event_t_NETDEV_EVENT_TX_MEDIUM_BUSY: netdev_event_t = 7;
#[doc = "< link established"]
pub const netdev_event_t_NETDEV_EVENT_LINK_UP: netdev_event_t = 8;
#[doc = "< link gone"]
pub const netdev_event_t_NETDEV_EVENT_LINK_DOWN: netdev_event_t = 9;
#[doc = "< timeout when sending"]
pub const netdev_event_t_NETDEV_EVENT_TX_TIMEOUT: netdev_event_t = 10;
#[doc = "< timeout when receiving"]
pub const netdev_event_t_NETDEV_EVENT_RX_TIMEOUT: netdev_event_t = 11;
#[doc = "< wrong CRC"]
pub const netdev_event_t_NETDEV_EVENT_CRC_ERROR: netdev_event_t = 12;
#[doc = "< channel changed"]
pub const netdev_event_t_NETDEV_EVENT_FHSS_CHANGE_CHANNEL: netdev_event_t = 13;
#[doc = "< channel activity detection done"]
pub const netdev_event_t_NETDEV_EVENT_CAD_DONE: netdev_event_t = 14;
#[doc = " @brief   Possible event types that are send from the device driver to the"]
#[doc = "          upper layer"]
pub type netdev_event_t = ::core::ffi::c_uint;
#[doc = " @brief   Received frame status information for most radios"]
#[doc = ""]
#[doc = " May be different for certain radios."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_radio_rx_info {
	#[doc = "< RSSI of a received frame in dBm"]
	pub rssi: i16,
	#[doc = "< LQI of a received frame"]
	pub lqi: u8,
}
#[doc = " @brief Structure to hold driver state"]
#[doc = ""]
#[doc = " Supposed to be extended by driver implementations."]
#[doc = " The extended structure should contain all variable driver state."]
#[doc = ""]
#[doc = " Contains a field @p context which is not used by the drivers, but supposed to"]
#[doc = " be used by upper layers to store reference information."]
pub type netdev_t = netdev;
#[doc = " @brief   Event callback for signaling event to upper layers"]
#[doc = ""]
#[doc = " @param[in] dev           pointer to the device descriptor"]
#[doc = " @param[in] event         type of the event"]
pub type netdev_event_cb_t =
	::core::option::Option<unsafe extern "C" fn(dev: *mut netdev_t, event: netdev_event_t)>;
#[doc = "< Will match any device type"]
pub const netdev_type_t_NETDEV_ANY: netdev_type_t = 0;
pub const netdev_type_t_NETDEV_AT86RF215: netdev_type_t = 1;
pub const netdev_type_t_NETDEV_AT86RF2XX: netdev_type_t = 2;
pub const netdev_type_t_NETDEV_CC2538: netdev_type_t = 3;
pub const netdev_type_t_NETDEV_DOSE: netdev_type_t = 4;
pub const netdev_type_t_NETDEV_ENC28J60: netdev_type_t = 5;
pub const netdev_type_t_NETDEV_KW41ZRF: netdev_type_t = 6;
pub const netdev_type_t_NETDEV_MRF24J40: netdev_type_t = 7;
pub const netdev_type_t_NETDEV_NRF802154: netdev_type_t = 8;
pub const netdev_type_t_NETDEV_STM32_ETH: netdev_type_t = 9;
pub const netdev_type_t_NETDEV_CC110X: netdev_type_t = 10;
pub const netdev_type_t_NETDEV_SX127X: netdev_type_t = 11;
pub const netdev_type_t_NETDEV_SAM0_ETH: netdev_type_t = 12;
pub const netdev_type_t_NETDEV_ESP_NOW: netdev_type_t = 13;
pub const netdev_type_t_NETDEV_NRF24L01P_NG: netdev_type_t = 14;
pub const netdev_type_t_NETDEV_SOCKET_ZEP: netdev_type_t = 15;
pub const netdev_type_t_NETDEV_SX126X: netdev_type_t = 16;
pub const netdev_type_t_NETDEV_CC2420: netdev_type_t = 17;
pub const netdev_type_t_NETDEV_ETHOS: netdev_type_t = 18;
pub const netdev_type_t_NETDEV_SLIPDEV: netdev_type_t = 19;
pub const netdev_type_t_NETDEV_TAP: netdev_type_t = 20;
#[doc = " @brief   Driver types for netdev."]
#[doc = ""]
#[doc = " @warning New entries must be added at the bottom of the list"]
#[doc = "          because the values need to remain constant to"]
#[doc = "          generate stable L2 addresses."]
#[doc = " @{"]
pub type netdev_type_t = ::core::ffi::c_uint;
#[doc = " @brief Structure to hold driver state"]
#[doc = ""]
#[doc = " Supposed to be extended by driver implementations."]
#[doc = " The extended structure should contain all variable driver state."]
#[doc = ""]
#[doc = " Contains a field @p context which is not used by the drivers, but supposed to"]
#[doc = " be used by upper layers to store reference information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev {
	#[doc = "< ptr to that driver's interface."]
	pub driver: *const netdev_driver,
	#[doc = "< callback for device events"]
	pub event_callback: netdev_event_cb_t,
	#[doc = "< ptr to network stack context"]
	pub context: *mut ::core::ffi::c_void,
}
extern "C" {
	#[doc = " @brief   Signal that the @ref netdev_register function registered the device."]
	#[doc = ""]
	#[doc = "          This function is called right after @ref netdev_register registered"]
	#[doc = "          the device."]
	#[doc = ""]
	#[doc = " @note    This function is called only if the CFLAG @ref"]
	#[doc = "          CONFIG_NETDEV_REGISTER_SIGNAL is set."]
	#[doc = ""]
	#[doc = " @param[in] dev           pointer to the device descriptor"]
	#[doc = " @param[in] type          the driver used for the netdev"]
	#[doc = " @param[in] index         the index in the config struct"]
	pub fn netdev_register_signal(dev: *mut netdev, type_: netdev_type_t, index: u8);
}
#[doc = " @brief Structure to hold driver interface -> function mapping"]
#[doc = ""]
#[doc = " The send/receive functions expect/return a full ethernet"]
#[doc = " frame (dst mac, src mac, ethertype, payload, no checksum)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdev_driver {
	#[doc = " @brief   Start transmission of the given frame and return directly"]
	#[doc = ""]
	#[doc = " @pre     `(dev != NULL) && (iolist != NULL)`"]
	#[doc = ""]
	#[doc = " @param[in]   dev     Network device descriptor. Must not be NULL."]
	#[doc = " @param[in]   iolist  IO vector list to send. Elements of this list may"]
	#[doc = "                      have iolist_t::iol_size == 0 and (in this case only)"]
	#[doc = "                      iolist_t::iol_data == 0."]
	#[doc = ""]
	#[doc = " @retval  -EBUSY      Driver is temporarily unable to send, e.g. because"]
	#[doc = "                      an incoming frame on a half-duplex medium is"]
	#[doc = "                      received"]
	#[doc = " @retval  -ENETDOWN   Device is powered down"]
	#[doc = " @retval  <0          Other error"]
	#[doc = " @retval  0           Transmission successfully started"]
	#[doc = " @retval  >0          Number of bytes transmitted (deprecated!)"]
	#[doc = ""]
	#[doc = " This function will cause the driver to start the transmission in an"]
	#[doc = " async fashion. The driver will \"own\" the `iolist` until a subsequent"]
	#[doc = " call to @ref netdev_driver_t::confirm_send returns something different"]
	#[doc = " than `-EAGAIN`. The driver must signal completion using the"]
	#[doc = " NETDEV_EVENT_TX_COMPLETE event, regardless of success or failure."]
	#[doc = ""]
	#[doc = " Old drivers might not be ported to the new API and have"]
	#[doc = " netdev_driver_t::confirm_send set to `NULL`. In that case the driver"]
	#[doc = " will return the number of bytes transmitted on success (instead of `0`)"]
	#[doc = " and will likely block until completion."]
	pub send: ::core::option::Option<
		unsafe extern "C" fn(dev: *mut netdev_t, iolist: *const iolist_t) -> ::core::ffi::c_int,
	>,
	#[doc = " @brief   Fetch the status of a transmission and perform any potential"]
	#[doc = "          cleanup"]
	#[doc = ""]
	#[doc = " @param[in]   dev     Network device descriptor. Must not be NULL."]
	#[doc = " @param[out]  info    Device class specific type to fetch transmission"]
	#[doc = "                      info. May be `NULL` if not needed by upper layer."]
	#[doc = "                      May be ignored by driver."]
	#[doc = ""]
	#[doc = " @return  Number of bytes transmitted. (The size of the transmitted"]
	#[doc = "          frame including all overhead, such as frame check sequence,"]
	#[doc = "          bit stuffing, escaping, headers, trailers, preambles, start of"]
	#[doc = "          frame delimiters, etc. May be an estimate for performance"]
	#[doc = "          reasons.)"]
	#[doc = " @retval  -EAGAIN     Transmission still ongoing. (Call later again!)"]
	#[doc = " @retval  -ECOMM      Any kind of transmission error, such as collision"]
	#[doc = "                      detected, layer 2 ACK timeout, etc."]
	#[doc = "                      Use @p info for more details"]
	#[doc = " @retval  -EBUSY      Medium is busy. (E.g. Auto-CCA failed / timed out)"]
	#[doc = " @retval  <0          Other error. (Please use a negative errno code.)"]
	#[doc = ""]
	#[doc = " @warning After netdev_driver_t::send was called and returned zero, this"]
	#[doc = "          function must be called until it returns anything other than"]
	#[doc = "          `-EAGAIN`."]
	#[doc = " @note    The driver will signal completion using the"]
	#[doc = "          NETDEV_EVENT_TX_COMPLETE event. This function must not return"]
	#[doc = "          `-EAGAIN` after that event was received."]
	pub confirm_send: ::core::option::Option<
		unsafe extern "C" fn(
			dev: *mut netdev_t,
			info: *mut ::core::ffi::c_void,
		) -> ::core::ffi::c_int,
	>,
	#[doc = " @brief   Drop a received frame, **OR** get the length of a received"]
	#[doc = "          frame, **OR** get a received frame."]
	#[doc = ""]
	#[doc = " @pre     `(dev != NULL)`"]
	#[doc = ""]
	#[doc = " Supposed to be called from"]
	#[doc = " @ref netdev_t::event_callback \"netdev->event_callback()\""]
	#[doc = ""]
	#[doc = " If @p buf == NULL and @p len == 0, returns the frame size -- or an upper"]
	#[doc = " bound estimation of the size -- without dropping the frame."]
	#[doc = " If @p buf == NULL and @p len > 0, drops the frame and returns the frame"]
	#[doc = " size."]
	#[doc = ""]
	#[doc = " If called with @p buf != NULL and @p len is smaller than the received"]
	#[doc = " frame:"]
	#[doc = "  - The received frame is dropped"]
	#[doc = "  - The content in @p buf becomes invalid. (The driver may use the memory"]
	#[doc = "    to implement the dropping - or may not change it.)"]
	#[doc = "  - `-ENOBUFS` is returned"]
	#[doc = ""]
	#[doc = " @param[in]   dev     network device descriptor. Must not be NULL."]
	#[doc = " @param[out]  buf     buffer to write into or NULL to return the frame"]
	#[doc = "                      size."]
	#[doc = " @param[in]   len     maximum number of bytes to read. If @p buf is NULL"]
	#[doc = "                      the currently buffered frame is dropped when"]
	#[doc = "                      @p len > 0. Must not be 0 when @p buf != NULL."]
	#[doc = " @param[out]  info    status information for the received frame. Might"]
	#[doc = "                      be of different type for different netdev devices."]
	#[doc = "                      May be NULL if not needed or applicable."]
	#[doc = ""]
	#[doc = " @retval  -ENOBUFS    if supplied buffer is too small"]
	#[doc = " @return  number of bytes read if buf != NULL"]
	#[doc = " @return  frame size (or upper bound estimation) if buf == NULL"]
	pub recv: ::core::option::Option<
		unsafe extern "C" fn(
			dev: *mut netdev_t,
			buf: *mut ::core::ffi::c_void,
			len: usize,
			info: *mut ::core::ffi::c_void,
		) -> ::core::ffi::c_int,
	>,
	#[doc = " @brief   the driver's initialization function"]
	#[doc = ""]
	#[doc = " @pre     `(dev != NULL)`"]
	#[doc = ""]
	#[doc = " @param[in]   dev     network device descriptor. Must not be NULL."]
	#[doc = ""]
	#[doc = " @retval  <0      on error"]
	#[doc = " @retval  0       on success"]
	pub init:
		::core::option::Option<unsafe extern "C" fn(dev: *mut netdev_t) -> ::core::ffi::c_int>,
	#[doc = " @brief   a driver's user-space ISR handler"]
	#[doc = ""]
	#[doc = " @pre     `(dev != NULL)`"]
	#[doc = ""]
	#[doc = " This function will be called from a network stack's loop when being"]
	#[doc = " notified by netdev_isr."]
	#[doc = ""]
	#[doc = " It is supposed to call"]
	#[doc = " @ref netdev_t::event_callback \"netdev->event_callback()\" for each"]
	#[doc = " occurring event."]
	#[doc = ""]
	#[doc = " See receive frame flow description for details."]
	#[doc = ""]
	#[doc = " @param[in]   dev     network device descriptor. Must not be NULL."]
	pub isr: ::core::option::Option<unsafe extern "C" fn(dev: *mut netdev_t)>,
	#[doc = " @brief   Get an option value from a given network device"]
	#[doc = ""]
	#[doc = " @pre     `(dev != NULL)`"]
	#[doc = " @pre     for scalar types of @ref netopt_t @p max_len must be of exactly"]
	#[doc = "          that length (see [netopt documentation](@ref net_netopt) for"]
	#[doc = "          type)"]
	#[doc = " @pre     for array types of @ref netopt_t @p max_len must greater or"]
	#[doc = "          equal the required length (see"]
	#[doc = "          [netopt documentation](@ref net_netopt) for type)"]
	#[doc = " @pre     @p value must have the natural alignment of its type (see"]
	#[doc = "          [netopt documentation](@ref net_netopt) for type)"]
	#[doc = ""]
	#[doc = " @param[in]   dev     network device descriptor"]
	#[doc = " @param[in]   opt     option type"]
	#[doc = " @param[out]  value   pointer to store the option's value in"]
	#[doc = " @param[in]   max_len maximal amount of byte that fit into @p value"]
	#[doc = ""]
	#[doc = " @return  number of bytes written to @p value"]
	#[doc = " @retval  -ENOTSUP    if @p opt is not provided by the device"]
	pub get: ::core::option::Option<
		unsafe extern "C" fn(
			dev: *mut netdev_t,
			opt: netopt_t,
			value: *mut ::core::ffi::c_void,
			max_len: usize,
		) -> ::core::ffi::c_int,
	>,
	#[doc = " @brief   Set an option value for a given network device"]
	#[doc = ""]
	#[doc = " @pre     `(dev != NULL)`"]
	#[doc = " @pre     for scalar types of @ref netopt_t @p value_len must be of"]
	#[doc = "          exactly that length (see [netopt documentation](@ref net_netopt)"]
	#[doc = "          for type)"]
	#[doc = " @pre     for array types of @ref netopt_t @p value_len must lesser or"]
	#[doc = "          equal the required length (see"]
	#[doc = "          [netopt documentation](@ref net_netopt) for type)"]
	#[doc = " @pre     @p value must have the natural alignment of its type (see"]
	#[doc = "          [netopt documentation](@ref net_netopt) for type)"]
	#[doc = ""]
	#[doc = " @param[in]   dev         network device descriptor"]
	#[doc = " @param[in]   opt         option type"]
	#[doc = " @param[in]   value       value to set"]
	#[doc = " @param[in]   value_len   the length of @p value"]
	#[doc = ""]
	#[doc = " @return  number of bytes written to @p value"]
	#[doc = " @retval  -ENOTSUP    if @p opt is not configurable for the device"]
	#[doc = " @retval  -EINVAL     if @p value is an invalid value with regards to"]
	#[doc = "                      @p opt"]
	pub set: ::core::option::Option<
		unsafe extern "C" fn(
			dev: *mut netdev_t,
			opt: netopt_t,
			value: *const ::core::ffi::c_void,
			value_len: usize,
		) -> ::core::ffi::c_int,
	>,
}
#[doc = " @brief Structure to hold driver interface -> function mapping"]
#[doc = ""]
#[doc = " The send/receive functions expect/return a full ethernet"]
#[doc = " frame (dst mac, src mac, ethertype, payload, no checksum)."]
pub type netdev_driver_t = netdev_driver;
#[doc = " @brief Network interface descriptor."]
#[doc = ""]
#[doc = " @note All network interfaces should inherit from this structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif_t {
	#[doc = "< Pointer to the next interface"]
	pub node: list_node_t,
}
extern "C" {
	#[doc = " @brief   Iterator for the interfaces"]
	#[doc = ""]
	#[doc = " Returns interface after @p last. To start use `last == NULL`."]
	#[doc = ""]
	#[doc = " @param[in] last  The previous interface. Use `NULL` to start"]
	#[doc = "                  iteration."]
	#[doc = ""]
	#[doc = " @return next network interface."]
	#[doc = " @return NULL, if there is no interface after @p last"]
	pub fn netif_iter(last: *const netif_t) -> *mut netif_t;
}
extern "C" {
	#[doc = " @brief   Gets name of an interface"]
	#[doc = ""]
	#[doc = " @pre `name != NULL`"]
	#[doc = " @pre name holds at least @ref CONFIG_NETIF_NAMELENMAX characters"]
	#[doc = ""]
	#[doc = " @note    Supposed to be implemented by the networking module. `name` must be"]
	#[doc = "          zero-terminated in the result!"]
	#[doc = ""]
	#[doc = " @param[in] netif A network interface."]
	#[doc = " @param[out] name The name of the interface. Must not be `NULL`. Must at least"]
	#[doc = "                  hold @ref CONFIG_NETIF_NAMELENMAX bytes."]
	#[doc = ""]
	#[doc = " @return  length of @p name on success"]
	pub fn netif_get_name(
		netif: *mut netif_t,
		name: *mut ::core::ffi::c_char,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Gets the numeric identifier of an interface"]
	#[doc = ""]
	#[doc = " @param[in] netif A network interface."]
	#[doc = ""]
	#[doc = " @return  The numeric identifier of an interface"]
	#[doc = " @return  -1 if @p netif is not registered"]
	pub fn netif_get_id(netif: *const netif_t) -> i16;
}
extern "C" {
	#[doc = " @brief   Gets interface by name, from a buffer"]
	#[doc = ""]
	#[doc = " @pre `name != NULL`"]
	#[doc = ""]
	#[doc = " @param[in] name          The name of an interface as an array of chars. Must not be `NULL`."]
	#[doc = " @param[in] name_len      Number of characters in @p name."]
	#[doc = ""]
	#[doc = " @return  Pointer to the interface that matches the name"]
	#[doc = " @retval  NULL if no interface is named @p name."]
	pub fn netif_get_by_name_buffer(
		name: *const ::core::ffi::c_char,
		name_len: usize,
	) -> *mut netif_t;
}
extern "C" {
	#[doc = " @brief   Gets interface by a numeric identifier."]
	#[doc = ""]
	#[doc = " @param[in] id  A numeric identifier."]
	#[doc = ""]
	#[doc = " @return  The interface on success."]
	#[doc = " @return  NULL if no interface with identifier @p id."]
	pub fn netif_get_by_id(id: i16) -> *mut netif_t;
}
extern "C" {
	#[doc = " @brief   Gets option from an interface"]
	#[doc = ""]
	#[doc = " @note    Supposed to be implemented by the networking module"]
	#[doc = ""]
	#[doc = " @param[in]   netif   A network interface."]
	#[doc = " @param[in]   opt     Option type."]
	#[doc = " @param[in]   context (Optional) context to the given option"]
	#[doc = " @param[out]  value   Pointer to store the option's value in."]
	#[doc = " @param[in]   max_len Maximal amount of byte that fit into @p value."]
	#[doc = ""]
	#[doc = " @return  Number of bytes written to @p value."]
	#[doc = " @return  `< 0` on error, 0 on success."]
	pub fn netif_get_opt(
		netif: *mut netif_t,
		opt: netopt_t,
		context: u16,
		value: *mut ::core::ffi::c_void,
		max_len: usize,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Sets option to an interface"]
	#[doc = ""]
	#[doc = " @note    Supposed to be implemented by the networking module"]
	#[doc = ""]
	#[doc = " @param[in] netif     A network interface."]
	#[doc = " @param[in] opt       Option type."]
	#[doc = " @param[in] context   (Optional) context to the given option"]
	#[doc = " @param[in] value     Pointer to store the option's value in."]
	#[doc = " @param[in] value_len The length of @p value."]
	#[doc = ""]
	#[doc = " @return Number of bytes used from @p value."]
	#[doc = " @return `< 0` on error, 0 on success."]
	pub fn netif_set_opt(
		netif: *mut netif_t,
		opt: netopt_t,
		context: u16,
		value: *mut ::core::ffi::c_void,
		value_len: usize,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Registers a network interface in the global interface list."]
	#[doc = ""]
	#[doc = " @note    This functions should be called when initializing an interface."]
	#[doc = ""]
	#[doc = " @param[in] netif     Interface to be registered"]
	#[doc = ""]
	#[doc = " @return  0 on success"]
	#[doc = " @return  -EINVAL if @p netif is NULL."]
	pub fn netif_register(netif: *mut netif_t) -> ::core::ffi::c_int;
}
pub const gnrc_netif_bus_t_GNRC_NETIF_BUS_NUMOF: gnrc_netif_bus_t = 0;
#[doc = " @brief   Per-Interface Event Message Buses"]
pub type gnrc_netif_bus_t = ::core::ffi::c_uint;
#[doc = " @brief   Address becomes valid"]
#[doc = ""]
#[doc = " The event is generated when an address on the interface becomes valid."]
#[doc = " The message payload contains a pointer to the respective"]
#[doc = " @ref ipv6_addr_t struct."]
#[doc = ""]
#[doc = " @note If the address on the interface changed between sending"]
#[doc = " the event and processing it, the pointer will point to the new address"]
#[doc = " which might *not* be valid."]
pub const gnrc_ipv6_event_t_GNRC_IPV6_EVENT_ADDR_VALID: gnrc_ipv6_event_t = 0;
#[doc = " @brief   Event types for GNRC_NETIF_BUS_IPV6 per-interface message bus"]
pub type gnrc_ipv6_event_t = ::core::ffi::c_uint;
#[doc = " @see gnrc_netif_ops_t"]
pub type gnrc_netif_ops_t = gnrc_netif_ops;
#[doc = " @brief   Representation of a network interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnrc_netif_t {
	#[doc = "< network interface descriptor"]
	pub netif: netif_t,
	#[doc = "< Operations of the network interface"]
	pub ops: *const gnrc_netif_ops_t,
	#[doc = "< Network device of the network interface"]
	pub dev: *mut netdev_t,
	#[doc = "< Mutex of the interface"]
	pub mutex: rmutex_t,
	#[doc = " @brief   Flags for the interface"]
	#[doc = ""]
	#[doc = " @see net_gnrc_netif_flags"]
	pub flags: u32,
	#[doc = " @brief   The link-layer address currently used as the source address"]
	#[doc = "          on this interface."]
	#[doc = ""]
	#[doc = " @note    Only available if @ref GNRC_NETIF_L2ADDR_MAXLEN > 0"]
	pub l2addr: [u8; 8usize],
	#[doc = " @brief   Length in bytes of gnrc_netif_t::l2addr"]
	#[doc = ""]
	#[doc = " @note    Only available if @ref GNRC_NETIF_L2ADDR_MAXLEN > 0"]
	pub l2addr_len: u8,
	#[doc = "< Current hop-limit for out-going packets"]
	pub cur_hl: u8,
	#[doc = "< Device type"]
	pub device_type: u8,
	#[doc = "< PID of the network interface's thread"]
	pub pid: kernel_pid_t,
}
#[doc = " @see gnrc_netif_ops_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnrc_netif_ops {
	#[doc = " @brief   Initializes and registers network interface."]
	#[doc = ""]
	#[doc = " @pre `netif != NULL`"]
	#[doc = ""]
	#[doc = " @param[in] netif The network interface."]
	#[doc = ""]
	#[doc = " This function should init the device driver or MAC underlying MAC layer."]
	#[doc = " This is called right before the interface's thread starts receiving"]
	#[doc = " messages. It is not necessary to lock the interface's mutex"]
	#[doc = " gnrc_netif_t::mutex, since it is already locked. Set to @ref"]
	#[doc = " gnrc_netif_default_init() if you do not need any special initialization."]
	#[doc = " If you do need special initialization, it is recommended to call @ref"]
	#[doc = " gnrc_netif_default_init() at the start of the custom initialization"]
	#[doc = " function set here. This function MUST call @ref netif_register if the"]
	#[doc = " initialization is successful."]
	#[doc = ""]
	#[doc = " @return 0 if the initialization of the device or MAC layer was"]
	#[doc = " successful"]
	#[doc = " @return negative errno on error."]
	pub init: ::core::option::Option<
		unsafe extern "C" fn(netif: *mut gnrc_netif_t) -> ::core::ffi::c_int,
	>,
	#[doc = " @brief   Send a @ref net_gnrc_pkt \"packet\" over the network interface"]
	#[doc = ""]
	#[doc = " @pre `netif != NULL && pkt != NULL`"]
	#[doc = ""]
	#[doc = " @note The function re-formats the content of @p pkt to a format expected"]
	#[doc = "       by the netdev_driver_t::send() method of gnrc_netif_t::dev and"]
	#[doc = "       releases the packet before returning (so no additional release"]
	#[doc = "       should be required after calling this method)."]
	#[doc = ""]
	#[doc = " @param[in] netif The network interface."]
	#[doc = " @param[in] pkt   A packet to send."]
	#[doc = ""]
	#[doc = " @return  The number of bytes actually sent on success"]
	#[doc = " @return  -EBADMSG, if the @ref net_gnrc_netif_hdr in @p pkt is missing"]
	#[doc = "          or is in an unexpected format."]
	#[doc = " @return  -ENOTSUP, if sending @p pkt in the given format isn't supported"]
	#[doc = "          (e.g. empty payload with Ethernet)."]
	#[doc = " @return  Any negative error code reported by gnrc_netif_t::dev."]
	pub send: ::core::option::Option<
		unsafe extern "C" fn(
			netif: *mut gnrc_netif_t,
			pkt: *mut gnrc_pktsnip_t,
		) -> ::core::ffi::c_int,
	>,
	#[doc = " @brief   Receives a @ref net_gnrc_pkt \"packet\" from the network interface"]
	#[doc = ""]
	#[doc = " @pre `netif != NULL`"]
	#[doc = ""]
	#[doc = " @note The function takes the bytes received via netdev_driver_t::recv()"]
	#[doc = "       from gnrc_netif_t::dev and re-formats it to a"]
	#[doc = "       @ref net_gnrc_pkt \"packet\" containing a @ref net_gnrc_netif_hdr"]
	#[doc = "       and a payload header in receive order."]
	#[doc = ""]
	#[doc = " @param[in] netif The network interface."]
	#[doc = ""]
	#[doc = " @return  The packet received. Contains the payload (with the type marked"]
	#[doc = "          accordingly) and a @ref net_gnrc_netif_hdr in receive order."]
	#[doc = " @return  NULL, if @ref net_gnrc_pktbuf was full."]
	pub recv: ::core::option::Option<
		unsafe extern "C" fn(netif: *mut gnrc_netif_t) -> *mut gnrc_pktsnip_t,
	>,
	#[doc = " @brief   Gets an option from the network interface"]
	#[doc = ""]
	#[doc = " Use gnrc_netif_get_from_netdev() to just get options from"]
	#[doc = " gnrc_netif_t::dev."]
	#[doc = ""]
	#[doc = " @param[in] netif     The network interface."]
	#[doc = " @param[in] opt       The option parameters."]
	#[doc = ""]
	#[doc = " @return  Number of bytes in @p data."]
	#[doc = " @return  -EOVERFLOW, if @p max_len is lesser than the required space."]
	#[doc = " @return  -ENOTSUP, if @p opt is not supported to be set."]
	#[doc = " @return  Any negative error code reported by gnrc_netif_t::dev."]
	pub get: ::core::option::Option<
		unsafe extern "C" fn(
			netif: *mut gnrc_netif_t,
			opt: *mut gnrc_netapi_opt_t,
		) -> ::core::ffi::c_int,
	>,
	#[doc = " @brief  Sets an option from the network interface"]
	#[doc = ""]
	#[doc = " Use gnrc_netif_set_from_netdev() to just set options from"]
	#[doc = " gnrc_netif_t::dev."]
	#[doc = ""]
	#[doc = " @param[in] netif     The network interface."]
	#[doc = " @param[in] opt       The option parameters."]
	#[doc = ""]
	#[doc = " @return  Number of bytes written to gnrc_netif_t::dev."]
	#[doc = " @return  -EOVERFLOW, if @p data_len is greater than the allotted space in"]
	#[doc = "          gnrc_netif_t::dev or gnrc_netif_t."]
	#[doc = " @return  -ENOTSUP, if @p opt is not supported to be set."]
	#[doc = " @return  Any negative error code reported by gnrc_netif_t::dev."]
	pub set: ::core::option::Option<
		unsafe extern "C" fn(
			netif: *mut gnrc_netif_t,
			opt: *const gnrc_netapi_opt_t,
		) -> ::core::ffi::c_int,
	>,
	#[doc = " @brief   Message handler for network interface"]
	#[doc = ""]
	#[doc = " This message handler is used, when the network interface needs to handle"]
	#[doc = " message types beyond the ones defined in @ref net_gnrc_netapi \"netapi\"."]
	#[doc = " Leave NULL if this is not the case."]
	#[doc = ""]
	#[doc = " @param[in] netif The network interface."]
	#[doc = " @param[in] msg   Message to be handled."]
	pub msg_handler:
		::core::option::Option<unsafe extern "C" fn(netif: *mut gnrc_netif_t, msg: *mut msg_t)>,
}
extern "C" {
	#[doc = " @brief   Initialize all available network interfaces."]
	#[doc = "          This function is called automatically if the auto_init_gnrc_netif"]
	#[doc = "          module is used."]
	#[doc = "          If only the gnrc_netif_init module is used instead, you can call"]
	#[doc = "          this function to manually set up the network interfaces at a later"]
	#[doc = "          time."]
	pub fn gnrc_netif_init_devs();
}
extern "C" {
	#[doc = " @brief   Creates a network interface"]
	#[doc = ""]
	#[doc = " @param[out] netif    The interface. May not be `NULL`."]
	#[doc = " @param[in] stack     The stack for the network interface's thread."]
	#[doc = " @param[in] stacksize Size of @p stack."]
	#[doc = " @param[in] priority  Priority for the network interface's thread."]
	#[doc = " @param[in] name      Name for the network interface. May be NULL."]
	#[doc = " @param[in] dev       Device for the interface."]
	#[doc = " @param[in] ops       Operations for the network interface."]
	#[doc = ""]
	#[doc = " @note If @ref DEVELHELP is defined netif_params_t::name is used as the"]
	#[doc = "       name of the network interface's thread."]
	#[doc = ""]
	#[doc = " @return  0 on success"]
	#[doc = " @return  negative number on error"]
	pub fn gnrc_netif_create(
		netif: *mut gnrc_netif_t,
		stack: *mut ::core::ffi::c_char,
		stacksize: ::core::ffi::c_int,
		priority: ::core::ffi::c_char,
		name: *const ::core::ffi::c_char,
		dev: *mut netdev_t,
		ops: *const gnrc_netif_ops_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Get number of network interfaces actually allocated"]
	#[doc = ""]
	#[doc = " @return  Number of network interfaces actually allocated"]
	pub fn gnrc_netif_numof() -> ::core::ffi::c_uint;
}
extern "C" {
	#[doc = " @brief   Iterate over all network interfaces."]
	#[doc = ""]
	#[doc = " @param[in] prev  previous interface in iteration. NULL to start iteration."]
	#[doc = ""]
	#[doc = " @return  The next network interface after @p prev."]
	#[doc = " @return  NULL, if @p prev was the last network interface."]
	pub fn gnrc_netif_iter(prev: *const gnrc_netif_t) -> *mut gnrc_netif_t;
}
extern "C" {
	#[doc = " @brief   Get network interface by PID"]
	#[doc = ""]
	#[doc = " @param[in] pid   A PID of a network interface."]
	#[doc = ""]
	#[doc = " @return  The network interface on success."]
	#[doc = " @return  NULL, if no network interface with PID exists."]
	pub fn gnrc_netif_get_by_pid(pid: kernel_pid_t) -> *mut gnrc_netif_t;
}
extern "C" {
	#[doc = " @brief   Default operation for gnrc_netif_ops_t::init()"]
	#[doc = ""]
	#[doc = " @note    Can also be used to be called *before* a custom operation. This"]
	#[doc = "          function calls @ref netif_register internally."]
	#[doc = ""]
	#[doc = " @param[in] netif     The network interface."]
	pub fn gnrc_netif_default_init(netif: *mut gnrc_netif_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Default operation for gnrc_netif_ops_t::get()"]
	#[doc = ""]
	#[doc = " @note    Can also be used to be called *after* a custom operation."]
	#[doc = ""]
	#[doc = " @param[in] netif     The network interface."]
	#[doc = " @param[out] opt      The option parameters."]
	#[doc = ""]
	#[doc = " @return  Return value of netdev_driver_t::get() of gnrc_netif_t::dev of"]
	#[doc = "          @p netif."]
	pub fn gnrc_netif_get_from_netdev(
		netif: *mut gnrc_netif_t,
		opt: *mut gnrc_netapi_opt_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Default operation for gnrc_netif_ops_t::set()"]
	#[doc = ""]
	#[doc = " @note    Can also be used to be called *after* a custom operation."]
	#[doc = ""]
	#[doc = " @param[in] netif     The network interface."]
	#[doc = " @param[in] opt       The option parameters."]
	#[doc = ""]
	#[doc = " @return  Return value of netdev_driver_t::set() of gnrc_netif_t::dev of"]
	#[doc = "          @p netif."]
	pub fn gnrc_netif_set_from_netdev(
		netif: *mut gnrc_netif_t,
		opt: *const gnrc_netapi_opt_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief Gets an interface by the netdev type (and index)"]
	#[doc = ""]
	#[doc = " @pre The netdev has been registered with @ref netdev_register"]
	#[doc = ""]
	#[doc = " @param[in]  type         driver type of the netdev, can be @ref NETDEV_ANY"]
	#[doc = " @param[in]  index        index of the netdev, can be @ref NETDEV_INDEX_ANY"]
	#[doc = ""]
	#[doc = " @return  The network interface that has a netdev of matching type and index"]
	#[doc = "          NULL if no matching interface could be found"]
	pub fn gnrc_netif_get_by_type(type_: netdev_type_t, index: u8) -> *mut gnrc_netif_t;
}
extern "C" {
	#[doc = " @brief   Acquires exclusive access to the interface"]
	#[doc = ""]
	#[doc = " @param[in] netif the network interface"]
	#[doc = ""]
	#[doc = " @internal"]
	pub fn gnrc_netif_acquire(netif: *mut gnrc_netif_t);
}
extern "C" {
	#[doc = " @brief   Releases exclusive access to the interface"]
	#[doc = ""]
	#[doc = " @param[in] netif the network interface"]
	#[doc = ""]
	#[doc = " @internal"]
	pub fn gnrc_netif_release(netif: *mut gnrc_netif_t);
}
extern "C" {
	#[doc = " @brief   Checks if the device type associated to a @ref gnrc_netif_t"]
	#[doc = "          requires 6Lo to run"]
	#[doc = ""]
	#[doc = " @param[in] netif the network interface"]
	#[doc = ""]
	#[doc = " @return true if the device requires 6Lo"]
	#[doc = " @return false otherwise"]
	pub fn gnrc_netif_dev_is_6lo(netif: *const gnrc_netif_t) -> bool;
}
extern "C" {
	#[doc = " @name    Device type based function"]
	#[doc = ""]
	#[doc = " These functions' behavior is based around the gnrc_netif_t::device_type of"]
	#[doc = " an interface."]
	#[doc = ""]
	#[doc = " @attention   Special care needs to be taken for those functions when porting"]
	#[doc = "              a new network device type or link-layer protocol: They might"]
	#[doc = "              need adaptions for your port"]
	#[doc = " @{"]
	#[doc = " @brief   Get the default link-layer address option for the given"]
	#[doc = "          gnrc_netif_t::device_type of a network interface"]
	#[doc = ""]
	#[doc = " @param[in] netif     The network interface to get the default link-layer"]
	#[doc = "                      address option for."]
	#[doc = ""]
	#[doc = " @return  Either @ref NETOPT_ADDRESS or @ref NETOPT_ADDRESS_LONG."]
	pub fn gnrc_netif_get_l2addr_opt(netif: *const gnrc_netif_t) -> netopt_t;
}
extern "C" {
	#[doc = " @brief   Converts a given hardware address to an EUI-64."]
	#[doc = ""]
	#[doc = " @attention When the link-layer of the interface has link-layer addresses, and"]
	#[doc = "            `NDEBUG` is not defined, the node fails with an assertion instead"]
	#[doc = "            returning `-ENOTSUP`."]
	#[doc = ""]
	#[doc = " @param[in] netif     The network interface @p addr came from (either as"]
	#[doc = "                      gnrc_netif_t::l2addr or from a packet that came over"]
	#[doc = "                      it)."]
	#[doc = " @param[in] addr      A hardware address."]
	#[doc = " @param[in] addr_len  Number of bytes in @p addr."]
	#[doc = " @param[out] eui64    The EUI-64 based on gnrc_netif_t::device_type"]
	#[doc = ""]
	#[doc = " @return  `sizeof(eui64_t)` on success."]
	#[doc = " @return  `-ENOTSUP`, when gnrc_netif_t::device_type of @p netif does not"]
	#[doc = "          support IID conversion."]
	#[doc = " @return  `-EINVAL`, when @p addr_len is invalid for the"]
	#[doc = "          gnrc_netif_t::device_type of @p netif."]
	pub fn gnrc_netif_eui64_from_addr(
		netif: *const gnrc_netif_t,
		addr: *const u8,
		addr_len: usize,
		eui64: *mut eui64_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Initializes an interface as 6LN according to RFC 6775 and according"]
	#[doc = "          to its gnrc_netif_t::device_type"]
	#[doc = ""]
	#[doc = " @param[in] netif The network interface to initialize as 6LN"]
	pub fn gnrc_netif_init_6ln(netif: *mut gnrc_netif_t);
}
extern "C" {
	#[doc = " @brief   Initializes packet buffer module."]
	pub fn gnrc_pktbuf_init();
}
extern "C" {
	#[doc = " @brief   Adds a new gnrc_pktsnip_t and its packet to the packet buffer."]
	#[doc = ""]
	#[doc = " @warning **Do not** change the fields of the gnrc_pktsnip_t created by this"]
	#[doc = "          function externally. This will most likely create memory leaks or"]
	#[doc = "          not allowed memory access."]
	#[doc = ""]
	#[doc = " @pre size < CONFIG_GNRC_PKTBUF_SIZE"]
	#[doc = ""]
	#[doc = " @param[in] next      Next gnrc_pktsnip_t in the packet. Leave NULL if you"]
	#[doc = "                      want to create a new packet."]
	#[doc = " @param[in] data      Data of the new gnrc_pktsnip_t. If @p data is NULL no data"]
	#[doc = "                      will be inserted into `result`."]
	#[doc = " @param[in] size      Length of @p data. If this value is 0 the"]
	#[doc = "                      gnrc_pktsnip::data field of the newly created snip will"]
	#[doc = "                      be NULL."]
	#[doc = " @param[in] type      Protocol type of the gnrc_pktsnip_t."]
	#[doc = ""]
	#[doc = " @return  Pointer to the packet part that represents the new gnrc_pktsnip_t."]
	#[doc = " @return  NULL, if no space is left in the packet buffer."]
	pub fn gnrc_pktbuf_add(
		next: *mut gnrc_pktsnip_t,
		data: *const ::core::ffi::c_void,
		size: usize,
		type_: gnrc_nettype_t,
	) -> *mut gnrc_pktsnip_t;
}
extern "C" {
	#[doc = " @brief   Marks the first @p size bytes in a received packet with a new"]
	#[doc = "          packet snip that is appended to the packet."]
	#[doc = ""]
	#[doc = " Graphically this can be represented as follows:"]
	#[doc = ""]
	#[doc = " ~~~~~~~~~~~~~~~~~~~"]
	#[doc = " Before                                    After"]
	#[doc = " ======                                    ====="]
	#[doc = "                                                       (next)"]
	#[doc = "  pkt->data                                 result->data <== pkt->data"]
	#[doc = "  v                                         v                v"]
	#[doc = " +--------------------------------+        +----------------+---------------+"]
	#[doc = " +--------------------------------+        +----------------+---------------+"]
	#[doc = "  \\__________pkt->size___________/          \\_result->size_/ \\__pkt->size__/"]
	#[doc = " ~~~~~~~~~~~~~~~~~~~"]
	#[doc = ""]
	#[doc = " If `size == pkt->size` then the resulting snip will point to NULL in its"]
	#[doc = " gnrc_pktsnip_t::data field and its gnrc_pktsnip_t::size field will be 0."]
	#[doc = ""]
	#[doc = " @pre @p pkt != NULL && @p size != 0"]
	#[doc = ""]
	#[doc = " @param[in] pkt   A received packet."]
	#[doc = " @param[in] size  The size of the new packet snip."]
	#[doc = " @param[in] type  The type of the new packet snip."]
	#[doc = ""]
	#[doc = " @note    It's not guaranteed that `result->data` points to the same address"]
	#[doc = "          as the original `pkt->data`."]
	#[doc = ""]
	#[doc = " @return  The new packet snip in @p pkt on success."]
	#[doc = " @return  NULL, if pkt == NULL or size == 0 or size > pkt->size or pkt->data == NULL."]
	#[doc = " @return  NULL, if no space is left in the packet buffer."]
	pub fn gnrc_pktbuf_mark(
		pkt: *mut gnrc_pktsnip_t,
		size: usize,
		type_: gnrc_nettype_t,
	) -> *mut gnrc_pktsnip_t;
}
extern "C" {
	#[doc = " @brief   Reallocates gnrc_pktsnip_t::data of @p pkt in the packet buffer, without"]
	#[doc = "          changing the content."]
	#[doc = ""]
	#[doc = " @pre `pkt != NULL`"]
	#[doc = " @pre `(pkt->size > 0) <=> (pkt->data != NULL)`"]
	#[doc = " @pre gnrc_pktsnip_t::data of @p pkt is in the packet buffer if it is not NULL."]
	#[doc = ""]
	#[doc = " @details If enough memory is available behind it or @p size is smaller than"]
	#[doc = "          the original size of the packet then gnrc_pktsnip_t::data of @p pkt will"]
	#[doc = "          not be moved. Otherwise, it will be moved. If no space is available"]
	#[doc = "          nothing happens."]
	#[doc = ""]
	#[doc = " @param[in] pkt   A packet part."]
	#[doc = " @param[in] size  The size for @p pkt."]
	#[doc = ""]
	#[doc = " @return  0, on success"]
	#[doc = " @return  ENOMEM, if no space is left in the packet buffer."]
	pub fn gnrc_pktbuf_realloc_data(pkt: *mut gnrc_pktsnip_t, size: usize) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Increases gnrc_pktsnip_t::users of @p pkt atomically."]
	#[doc = ""]
	#[doc = " @param[in] pkt   A packet."]
	#[doc = " @param[in] num   Number you want to increment gnrc_pktsnip_t::users of @p pkt by."]
	pub fn gnrc_pktbuf_hold(pkt: *mut gnrc_pktsnip_t, num: ::core::ffi::c_uint);
}
extern "C" {
	#[doc = " @brief   Decreases gnrc_pktsnip_t::users of @p pkt atomically and removes it if it"]
	#[doc = "          reaches 0 and reports a possible error through an error code, if"]
	#[doc = "          @ref net_gnrc_neterr is included."]
	#[doc = ""]
	#[doc = " @pre All snips of @p pkt must be in the packet buffer."]
	#[doc = ""]
	#[doc = " @param[in] pkt   A packet."]
	#[doc = " @param[in] err   An error code."]
	pub fn gnrc_pktbuf_release_error(pkt: *mut gnrc_pktsnip_t, err: u32);
}
extern "C" {
	#[doc = " @brief   Must be called once before there is a write operation on a"]
	#[doc = "          [packet snip](@ref gnrc_pktsnip_t) in a thread."]
	#[doc = ""]
	#[doc = " @details This function duplicates a packet snip in the packet buffer (both"]
	#[doc = "          the instance of the gnrc_pktsnip_t and its data) if"]
	#[doc = "          gnrc_pktsnip_t::users of @p pkt > 1."]
	#[doc = ""]
	#[doc = " @param[in] pkt   The packet snip you want to write into."]
	#[doc = ""]
	#[doc = " @return  The (new) pointer to the packet snip."]
	#[doc = " @return  NULL, if gnrc_pktsnip_t::users of @p pkt > 1 and if there is not"]
	#[doc = "          enough space in the packet buffer."]
	pub fn gnrc_pktbuf_start_write(pkt: *mut gnrc_pktsnip_t) -> *mut gnrc_pktsnip_t;
}
extern "C" {
	#[doc = " @brief   Deletes a snip from a packet and the packet buffer."]
	#[doc = ""]
	#[doc = " @param[in] pkt   A packet."]
	#[doc = " @param[in] snip  A snip in the packet."]
	#[doc = ""]
	#[doc = " @return  The new reference to @p pkt."]
	pub fn gnrc_pktbuf_remove_snip(
		pkt: *mut gnrc_pktsnip_t,
		snip: *mut gnrc_pktsnip_t,
	) -> *mut gnrc_pktsnip_t;
}
extern "C" {
	#[doc = " @brief   Reverses snip order of a packet in a write-protected manner."]
	#[doc = ""]
	#[doc = " This can be used to change the send/receive order of a packet (see"]
	#[doc = " @ref gnrc_pktsnip_t)"]
	#[doc = ""]
	#[doc = " @note    @p pkt is released on failure."]
	#[doc = ""]
	#[doc = " @param[in] pkt   A packet. When this function fails (due to a full packet"]
	#[doc = "                  packet buffer) @p pkt will be released."]
	#[doc = ""]
	#[doc = " @return  The reversed version of @p pkt on success"]
	#[doc = " @return  NULL, when there is not enough space in the packet buffer to reverse"]
	#[doc = "          the packet in a write-protected manner. @p pkt is released in that"]
	#[doc = "          case."]
	pub fn gnrc_pktbuf_reverse_snips(pkt: *mut gnrc_pktsnip_t) -> *mut gnrc_pktsnip_t;
}
extern "C" {
	#[doc = " @brief   Merge pktsnip chain to single pktsnip."]
	#[doc = ""]
	#[doc = " Specifically it calls @ref gnrc_pktbuf_realloc_data() on @p pkt, then copies"]
	#[doc = " the data of all following packet snips into that reallocated space, and"]
	#[doc = " removes the packet snip the data was copied from afterwards."]
	#[doc = ""]
	#[doc = " ### Example"]
	#[doc = " #### Input"]
	#[doc = ""]
	#[doc = "                                                         buffer"]
	#[doc = "     +---------------------------+                      +------+"]
	#[doc = "     | size = 8                  | data       +-------->|      |"]
	#[doc = "     | type = NETTYPE_IPV6       |------------+         +------+"]
	#[doc = "     +---------------------------+                      .      ."]
	#[doc = "           | next                                       .      ."]
	#[doc = "           v                                            .      ."]
	#[doc = "     +---------------------------+                      +------+"]
	#[doc = "     | size = 40                 | data    +----------->|      |"]
	#[doc = "     | type = NETTYPE_UDP        |---------+            +------+"]
	#[doc = "     +---------------------------+                      .      ."]
	#[doc = "           | next                                       .      ."]
	#[doc = "           v"]
	#[doc = "     +---------------------------+                      +------+"]
	#[doc = "     | size = 14                 | data +-------------->|      |"]
	#[doc = "     | type = NETTYPE_UNDEF      |------+               +------+"]
	#[doc = "     +---------------------------+                      .      ."]
	#[doc = ""]
	#[doc = ""]
	#[doc = " #### Output"]
	#[doc = ""]
	#[doc = "                                                         buffer"]
	#[doc = "     +---------------------------+                      +------+"]
	#[doc = "     | size = 62                 | data       +-------->|      |"]
	#[doc = "     | type = NETTYPE_IPV6       |------------+         |      |"]
	#[doc = "     +---------------------------+                      |      |"]
	#[doc = "                                                        |      |"]
	#[doc = "                                                        |      |"]
	#[doc = "                                                        |      |"]
	#[doc = "                                                        +------+"]
	#[doc = "                                                                 .      ."]
	#[doc = ""]
	#[doc = " @warning @p pkt needs to write protected before calling this function."]
	#[doc = " @note    Packets in receive order need to call"]
	#[doc = "          @ref gnrc_pktbuf_reverse_snips() first to get the data in the"]
	#[doc = "          correct order."]
	#[doc = ""]
	#[doc = " @param[in,out] pkt   The snip to merge."]
	#[doc = ""]
	#[doc = " @return  0, on success"]
	#[doc = " @return  ENOMEM, if no space is left in the packet buffer."]
	pub fn gnrc_pktbuf_merge(pkt: *mut gnrc_pktsnip_t) -> ::core::ffi::c_int;
}
#[doc = " @brief   Generic network interface header"]
#[doc = ""]
#[doc = " The link layer addresses included in this header are put in memory directly"]
#[doc = " following this struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnrc_netif_hdr_t {
	#[doc = "< length of l2 source address in byte"]
	pub src_l2addr_len: u8,
	#[doc = "< length of l2 destination address in byte"]
	pub dst_l2addr_len: u8,
	#[doc = "< PID of network interface"]
	pub if_pid: kernel_pid_t,
	#[doc = "< flags as defined above"]
	pub flags: u8,
	#[doc = " @brief   LQI of received packet or @ref GNRC_NETIF_HDR_NO_LQI"]
	pub lqi: u8,
	#[doc = " @brief   RSSI of received packet or @ref GNRC_NETIF_HDR_NO_RSSI"]
	pub rssi: i16,
}
extern "C" {
	#[doc = " @brief   Builds a generic network interface header for sending and"]
	#[doc = "          adds it to the packet buffer."]
	#[doc = ""]
	#[doc = " @param[in] src       Source address for the header. Can be NULL if not"]
	#[doc = "                      known or required."]
	#[doc = " @param[in] src_len   Length of @p src. Can be 0 if not known or required."]
	#[doc = " @param[in] dst       Destination address for the header. Can be NULL if not"]
	#[doc = "                      known or required."]
	#[doc = " @param[in] dst_len   Length of @p dst. Can be 0 if not known or required."]
	#[doc = ""]
	#[doc = " @return  The generic network layer header on success."]
	#[doc = " @return  NULL on error."]
	pub fn gnrc_netif_hdr_build(
		src: *const u8,
		src_len: u8,
		dst: *const u8,
		dst_len: u8,
	) -> *mut gnrc_pktsnip_t;
}
extern "C" {
	#[doc = " @brief   Outputs a generic interface header to stdout."]
	#[doc = ""]
	#[doc = " @param[in] hdr   A generic interface header."]
	pub fn gnrc_netif_hdr_print(hdr: *mut gnrc_netif_hdr_t);
}
extern "C" {
	#[doc = " @brief   Fetch the netif header flags of a gnrc packet"]
	#[doc = ""]
	#[doc = " @param[in]   pkt     gnrc packet from whom to fetch"]
	#[doc = ""]
	#[doc = " @return              netif header flags of @p pkt"]
	#[doc = " @return              0, if no header is present"]
	pub fn gnrc_netif_hdr_get_flag(pkt: *mut gnrc_pktsnip_t) -> u8;
}
extern "C" {
	#[doc = " @brief   Extract the destination address out of a gnrc packet"]
	#[doc = ""]
	#[doc = " @param[in]   pkt                 gnrc packet from whom to extract"]
	#[doc = " @param[out]  pointer_to_addr     pointer to address will be stored here"]
	#[doc = ""]
	#[doc = " @return                          length of destination address"]
	#[doc = " @return                          -ENOENT, if no netif header is presented in @p pkt or if no"]
	#[doc = "                                           destination address field presented in netif header."]
	pub fn gnrc_netif_hdr_get_dstaddr(
		pkt: *mut gnrc_pktsnip_t,
		pointer_to_addr: *mut *mut u8,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Extract the source address out of a gnrc packet"]
	#[doc = ""]
	#[doc = " @param[in]   pkt                 gnrc packet from whom to extract"]
	#[doc = " @param[out]  pointer_to_addr     pointer to address will be stored here"]
	#[doc = ""]
	#[doc = " @return                          length of source address"]
	#[doc = " @return                          -ENOENT, if no netif header is presented in @p pkt or if no"]
	#[doc = "                                           source address field presented in netif header."]
	pub fn gnrc_netif_hdr_get_srcaddr(
		pkt: *mut gnrc_pktsnip_t,
		pointer_to_addr: *mut *mut u8,
	) -> ::core::ffi::c_int;
}
#[doc = " @brief   Raw IP sock type"]
#[doc = " @internal"]
pub type sock_ip_t = sock_ip;
#[doc = " @brief   Auxiliary data provided when receiving using an IP sock object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_ip_aux_rx_t {
	#[doc = "< Flags used request information"]
	pub flags: sock_aux_flags_t,
}
#[doc = " @brief   Auxiliary data provided when sending using an IP sock object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_ip_aux_tx_t {
	#[doc = "< Flags used request information"]
	pub flags: sock_aux_flags_t,
}
extern "C" {
	#[doc = " @brief   Creates a new raw IPv4/IPv6 sock object"]
	#[doc = ""]
	#[doc = " @pre `(sock != NULL)`"]
	#[doc = ""]
	#[doc = " @param[out] sock     The resulting sock object."]
	#[doc = " @param[in] local     Local end point for the sock object."]
	#[doc = "                      May be NULL. sock_ip_ep_t::netif must either be"]
	#[doc = "                      @ref SOCK_ADDR_ANY_NETIF or equal to sock_ip_ep_t::netif"]
	#[doc = "                      of @p remote if `remote != NULL`."]
	#[doc = "                      If NULL @ref sock_ip_send() may bind implicitly."]
	#[doc = " @param[in] remote    Remote end point for the sock object."]
	#[doc = "                      May be `NULL` but then the `remote` parameter of"]
	#[doc = "                      @ref sock_ip_send() may not be `NULL` or it will always"]
	#[doc = "                      error with return value -ENOTCONN."]
	#[doc = "                      sock_ip_ep_t::port may not be 0 if `remote != NULL`."]
	#[doc = "                      sock_ip_ep_t::netif must either be"]
	#[doc = "                      @ref SOCK_ADDR_ANY_NETIF or equal to sock_ip_ep_t::netif"]
	#[doc = "                      of @p local if `local != NULL`."]
	#[doc = " @param[in] proto     Protocol to use in the raw IPv4/IPv6 sock object"]
	#[doc = "                      (the `protocol` header field in IPv4 and the `next_header`"]
	#[doc = "                      field in IPv6)."]
	#[doc = " @param[in] flags     Flags for the sock object. See also"]
	#[doc = "                      [sock flags](net_sock_flags). May be 0."]
	#[doc = ""]
	#[doc = " @return  0 on success."]
	#[doc = " @return  -EADDRINUSE, if `local != NULL` and @p local is already used"]
	#[doc = "          elsewhere"]
	#[doc = " @return  -EAFNOSUPPORT, if `local != NULL` or `remote != NULL` and"]
	#[doc = "          sock_ip_ep_t::family of @p local or @p remote is not supported."]
	#[doc = " @return  -EINVAL, if sock_ip_ep_t::addr of @p remote is an invalid address."]
	#[doc = " @return  -EINVAL, if sock_ip_ep_t::netif of @p local or @p remote are not"]
	#[doc = "          valid interfaces or contradict each other"]
	#[doc = "          (i.e. `(local->netif != remote->netif) &&"]
	#[doc = "          ((local->netif != SOCK_ADDR_ANY_NETIF) ||"]
	#[doc = "          (remote->netif != SOCK_ADDR_ANY_NETIF))` if neither is `NULL`)."]
	#[doc = " @return  -ENOMEM, if not enough resources can be provided for `sock` to be"]
	#[doc = "          created."]
	#[doc = " @return  -EPROTONOSUPPORT, if `local != NULL` or `remote != NULL` and"]
	#[doc = "          proto is not supported by sock_ip_ep_t::family of @p local or @p"]
	#[doc = "          remote."]
	pub fn sock_ip_create(
		sock: *mut sock_ip_t,
		local: *const sock_ip_ep_t,
		remote: *const sock_ip_ep_t,
		proto: u8,
		flags: u16,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Closes a raw IPv4/IPv6 sock object"]
	#[doc = ""]
	#[doc = " @pre `(sock != NULL)`"]
	#[doc = ""]
	#[doc = " @param[in] sock  A raw IPv4/IPv6 sock object."]
	pub fn sock_ip_close(sock: *mut sock_ip_t);
}
extern "C" {
	#[doc = " @brief   Gets the local end point of a raw IPv4/IPv6 sock object"]
	#[doc = ""]
	#[doc = " This gets the local end point of a raw IPv4/IPv6 sock object. Note that this"]
	#[doc = " might not be the same end point you added in @ref sock_ip_create(), but an"]
	#[doc = " end point more suitable for the implementation. Examples for this might be"]
	#[doc = " that if sock_ip_ep_t::netif is given in @ref sock_ip_create(), the"]
	#[doc = " implementation might choose to return the address on this interface the"]
	#[doc = " @p sock is bound to in @p ep's sock_ip_ep_t::addr."]
	#[doc = ""]
	#[doc = " @pre `(sock != NULL) && (ep != NULL)`"]
	#[doc = ""]
	#[doc = " @param[in] sock  A raw IPv4/IPv6 sock object."]
	#[doc = " @param[out] ep   The local end point."]
	#[doc = ""]
	#[doc = " @return  0 on success."]
	#[doc = " @return  -EADDRNOTAVAIL, when @p sock has no end point bound to it."]
	pub fn sock_ip_get_local(sock: *mut sock_ip_t, ep: *mut sock_ip_ep_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Gets the remote end point of a raw IPv4/IPv6 sock object"]
	#[doc = ""]
	#[doc = " @pre `(sock != NULL) && (ep != NULL)`"]
	#[doc = ""]
	#[doc = " This gets the remote end point of a raw IPv4/IPv6 sock object. Note that this"]
	#[doc = " might not be the same end point you added in @ref sock_ip_create(), but an"]
	#[doc = " end point more suitable for the implementation. Examples for this might be"]
	#[doc = " that if sock_ip_ep_t::netif is given in @ref sock_ip_create(), the"]
	#[doc = " implementation might choose to return the address on this interface the"]
	#[doc = " @p sock is bound to in @p ep's sock_ip_ep_t::addr."]
	#[doc = ""]
	#[doc = " @param[in] sock  A raw IPv4/IPv6 sock object."]
	#[doc = " @param[out] ep   The remote end point."]
	#[doc = ""]
	#[doc = " @return  0 on success."]
	#[doc = " @return  -ENOTCONN, when @p sock has no remote end point bound to it."]
	pub fn sock_ip_get_remote(sock: *mut sock_ip_t, ep: *mut sock_ip_ep_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Receives a message over IPv4/IPv6 from remote end point"]
	#[doc = ""]
	#[doc = " @pre `(sock != NULL) && (data != NULL) && (max_len > 0)`"]
	#[doc = ""]
	#[doc = " @param[in] sock      A raw IPv4/IPv6 sock object."]
	#[doc = " @param[out] data     Pointer where the received data should be stored."]
	#[doc = " @param[in] max_len   Maximum space available at @p data."]
	#[doc = " @param[in] timeout   Timeout for receive in microseconds."]
	#[doc = "                      If 0 and no data is available, the function returns"]
	#[doc = "                      immediately."]
	#[doc = "                      May be @ref SOCK_NO_TIMEOUT for no timeout (wait until"]
	#[doc = "                      data is available)."]
	#[doc = " @param[out] remote   Remote end point of the received data."]
	#[doc = "                      May be NULL, if it is not required by the application."]
	#[doc = " @param[out] aux      Auxiliary data of the reception."]
	#[doc = "                      May be NULL, if it is not required by the application."]
	#[doc = ""]
	#[doc = " @note    Function blocks if no packet is currently waiting."]
	#[doc = ""]
	#[doc = " @return  The number of bytes received on success."]
	#[doc = " @return  0, if no received data is available, but everything is in order."]
	#[doc = " @return  -EADDRNOTAVAIL, if local of @p sock is not given."]
	#[doc = " @return  -EAGAIN, if @p timeout is `0` and no data is available."]
	#[doc = " @return  -EINVAL, if @p remote is invalid or @p sock is not properly"]
	#[doc = "          initialized (or closed while sock_ip_recv() blocks)."]
	#[doc = " @return  -ENOBUFS, if buffer space is not large enough to store received"]
	#[doc = "          data."]
	#[doc = " @return  -ENOMEM, if no memory was available to receive @p data."]
	#[doc = " @return  -EPROTO, if source address of received packet did not equal"]
	#[doc = "          the remote of @p sock."]
	#[doc = " @return  -ETIMEDOUT, if @p timeout expired."]
	pub fn sock_ip_recv_aux(
		sock: *mut sock_ip_t,
		data: *mut ::core::ffi::c_void,
		max_len: usize,
		timeout: u32,
		remote: *mut sock_ip_ep_t,
		aux: *mut sock_ip_aux_rx_t,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Provides stack-internal buffer space containing an IPv4/IPv6"]
	#[doc = "          message from remote end point"]
	#[doc = ""]
	#[doc = " @pre `(sock != NULL) && (data != NULL) && (buf_ctx != NULL)`"]
	#[doc = ""]
	#[doc = " @param[in] sock      A raw IPv4/IPv6 sock object."]
	#[doc = " @param[out] data     Pointer to a stack-internal buffer space containing the"]
	#[doc = "                      received data."]
	#[doc = " @param[in,out] buf_ctx  Stack-internal buffer context. If it points to a"]
	#[doc = "                      `NULL` pointer, the stack returns a new buffer space"]
	#[doc = "                      for a new packet. If it does not point to a `NULL`"]
	#[doc = "                      pointer, an existing context is assumed to get a next"]
	#[doc = "                      segment in a buffer."]
	#[doc = " @param[in] timeout   Timeout for receive in microseconds."]
	#[doc = "                      If 0 and no data is available, the function returns"]
	#[doc = "                      immediately."]
	#[doc = "                      May be @ref SOCK_NO_TIMEOUT for no timeout (wait until"]
	#[doc = "                      data is available)."]
	#[doc = " @param[out] remote   Remote end point of the received data."]
	#[doc = "                      May be NULL, if it is not required by the application."]
	#[doc = " @param[out] aux      Auxiliary data of the reception."]
	#[doc = "                      May be NULL, if it is not required by the application."]
	#[doc = ""]
	#[doc = " @experimental    This function is quite new, not implemented for all stacks"]
	#[doc = "                  yet, and may be subject to sudden API changes. Do not use in"]
	#[doc = "                  production if this is unacceptable."]
	#[doc = ""]
	#[doc = " @note    Function blocks if no packet is currently waiting."]
	#[doc = ""]
	#[doc = " @return  The number of bytes received on success. May not be the complete"]
	#[doc = "          payload. Continue calling with the returned `buf_ctx` to get more"]
	#[doc = "          buffers until result is 0 or an error."]
	#[doc = " @return  0, if no received data is available, but everything is in order."]
	#[doc = "          If @p buf_ctx was provided, it was released."]
	#[doc = " @return  -EADDRNOTAVAIL, if local of @p sock is not given."]
	#[doc = " @return  -EAGAIN, if @p timeout is `0` and no data is available."]
	#[doc = " @return  -EINVAL, if @p remote is invalid or @p sock is not properly"]
	#[doc = "          initialized (or closed while sock_ip_recv() blocks)."]
	#[doc = " @return  -ENOMEM, if no memory was available to receive @p data."]
	#[doc = " @return  -EPROTO, if source address of received packet did not equal"]
	#[doc = "          the remote of @p sock."]
	#[doc = " @return  -ETIMEDOUT, if @p timeout expired."]
	pub fn sock_ip_recv_buf_aux(
		sock: *mut sock_ip_t,
		data: *mut *mut ::core::ffi::c_void,
		buf_ctx: *mut *mut ::core::ffi::c_void,
		timeout: u32,
		remote: *mut sock_ip_ep_t,
		aux: *mut sock_ip_aux_rx_t,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Sends a message over IPv4/IPv6 to remote end point"]
	#[doc = ""]
	#[doc = " @pre `((sock != NULL || remote != NULL)) && (if (len != 0): (data != NULL))`"]
	#[doc = ""]
	#[doc = " @param[in] sock      A raw IPv4/IPv6 sock object. May be NULL."]
	#[doc = "                      A sensible local end point should be selected by the"]
	#[doc = "                      implementation in that case."]
	#[doc = " @param[in] data      Pointer where the received data should be stored."]
	#[doc = "                      May be `NULL` if `len == 0`."]
	#[doc = " @param[in] len       Maximum space available at @p data."]
	#[doc = " @param[in] proto     Protocol to use in the packet sent, in case"]
	#[doc = "                      `sock == NULL`. If `sock != NULL` this parameter will be"]
	#[doc = "                      ignored."]
	#[doc = " @param[in] remote    Remote end point for the sent data."]
	#[doc = "                      May be `NULL`, if @p sock has a remote end point."]
	#[doc = "                      sock_ip_ep_t::family may be AF_UNSPEC, if local"]
	#[doc = "                      end point of @p sock provides this information."]
	#[doc = " @param[out] aux      Auxiliary data for the transmission."]
	#[doc = "                      May be `NULL` if not needed by the caller."]
	#[doc = ""]
	#[doc = " @return  The number of bytes sent on success."]
	#[doc = " @return  -EAFNOSUPPORT, if `remote != NULL` and sock_ip_ep_t::family of"]
	#[doc = "          @p remote is != AF_UNSPEC and not supported."]
	#[doc = " @return  -EINVAL, if sock_ip_ep_t::addr of @p remote is an invalid address."]
	#[doc = " @return  -EINVAL, if sock_ip_ep_t::netif of @p remote is not a"]
	#[doc = "          valid interface or contradicts the local interface of @p sock."]
	#[doc = " @return  -EHOSTUNREACH, if @p remote or remote end point of @p sock is not"]
	#[doc = "          reachable."]
	#[doc = " @return  -ENOMEM, if no memory was available to send @p data."]
	#[doc = " @return  -ENOTCONN, if `remote == NULL`, but @p sock has no remote end point."]
	#[doc = " @return  -EPROTOTYPE, if `sock == NULL` and @p proto is not by"]
	#[doc = "          sock_ip_ep_t::family of @p remote."]
	pub fn sock_ip_send_aux(
		sock: *mut sock_ip_t,
		data: *const ::core::ffi::c_void,
		len: usize,
		proto: u8,
		remote: *const sock_ip_ep_t,
		aux: *mut sock_ip_aux_tx_t,
	) -> isize;
}
#[doc = " @brief   Common IP-based transport layer end point"]
pub type sock_tcp_ep_t = _sock_tl_ep;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_tcp {
	_unused: [u8; 0],
}
#[doc = " @brief   Type for a TCP sock object"]
#[doc = ""]
#[doc = " @note API implementors: `struct sock_tcp` needs to be defined by"]
#[doc = "       implementation-specific `sock_types.h`."]
pub type sock_tcp_t = sock_tcp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock_tcp_queue {
	_unused: [u8; 0],
}
#[doc = " @brief   Type for a TCP listening queue"]
#[doc = ""]
#[doc = " @note API implementors: `struct sock_tcp_queue` needs to be defined by"]
#[doc = "                          implementation-specific `sock_types.h`."]
pub type sock_tcp_queue_t = sock_tcp_queue;
extern "C" {
	#[doc = " @brief   Establishes a new TCP sock connection"]
	#[doc = ""]
	#[doc = " @pre `sock != NULL`"]
	#[doc = " @pre `(remote != NULL) && (remote->port != 0)`"]
	#[doc = ""]
	#[doc = " @param[out] sock         The resulting sock object."]
	#[doc = " @param[in] remote        Remote end point for the sock object."]
	#[doc = " @param[in] local_port    Local port for the connection. May be 0. *"]
	#[doc = "                          If `local_port == 0` the connection is bound to a"]
	#[doc = "                          random port."]
	#[doc = " @param[in] flags         Flags for the sock object. See also"]
	#[doc = "                          @ref net_sock_flags. May be 0."]
	#[doc = ""]
	#[doc = " @return  0 on success."]
	#[doc = " @return  -EADDRINUSE, if `(flags & SOCK_FLAGS_REUSE_EP) == 0` and"]
	#[doc = "          @p local_port is already used elsewhere"]
	#[doc = " @return  -EAFNOSUPPORT, if sock_tcp_ep_t::family of @p remote is not"]
	#[doc = "          supported."]
	#[doc = " @return  -ECONNREFUSED, if no-one is listening on the @p remote end point."]
	#[doc = " @return  -EINVAL, if sock_tcp_ep_t::addr of @p remote is an invalid address."]
	#[doc = " @return  -EINVAL, if sock_tcp_ep_t::netif of @p remote is not a valid"]
	#[doc = "          interface."]
	#[doc = " @return  -ENETUNREACH, if network defined by @p remote is not reachable."]
	#[doc = " @return  -ENOMEM, if system was not able to allocate sufficient memory to"]
	#[doc = "          establish connection."]
	#[doc = " @return  -EPERM, if connections to @p remote are not permitted on the system"]
	#[doc = "          (e.g. by firewall rules)."]
	#[doc = " @return  -ETIMEDOUT, if the connection attempt to @p remote timed out."]
	pub fn sock_tcp_connect(
		sock: *mut sock_tcp_t,
		remote: *const sock_tcp_ep_t,
		local_port: u16,
		flags: u16,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Listen for an incoming connection request on @p local end point"]
	#[doc = ""]
	#[doc = " @pre `queue != NULL`"]
	#[doc = " @pre `(local != NULL) && (local->port != 0)`"]
	#[doc = " @pre `(queue_array != NULL) && (queue_len != 0)`"]
	#[doc = ""]
	#[doc = " @param[in] queue         The resulting listening queue."]
	#[doc = " @param[in] local         Local end point to listen on."]
	#[doc = " @param[in] queue_array   Array of sock objects."]
	#[doc = " @param[in] queue_len     Length of @p queue_array."]
	#[doc = " @param[in] flags         Flags for the listening queue. See also"]
	#[doc = "                          @ref net_sock_flags. May be 0."]
	#[doc = ""]
	#[doc = " @return  0 on success."]
	#[doc = " @return  -EADDRINUSE, if `(flags & SOCK_FLAGS_REUSE_EP) == 0` and"]
	#[doc = "          @p local is already used elsewhere"]
	#[doc = " @return  -EAFNOSUPPORT, if sock_tcp_ep_t::family of @p local is not"]
	#[doc = "          supported."]
	#[doc = " @return  -EINVAL, if sock_tcp_ep_t::netif of @p local is not a valid"]
	#[doc = "          interface."]
	#[doc = " @return  -ENOMEM, if no memory was available to listen on @p queue."]
	pub fn sock_tcp_listen(
		queue: *mut sock_tcp_queue_t,
		local: *const sock_tcp_ep_t,
		queue_array: *mut sock_tcp_t,
		queue_len: ::core::ffi::c_uint,
		flags: u16,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Disconnects a TCP connection"]
	#[doc = ""]
	#[doc = " @pre `sock != NULL` If we want to timeout this wait period we could"]
	#[doc = " alternatively set the `timeout` parameter of @ref sock_tcp_accept() to a"]
	#[doc = " value != @ref SOCK_NO_TIMEOUT."]
	#[doc = ""]
	#[doc = " @param[in] sock  A TCP sock object."]
	pub fn sock_tcp_disconnect(sock: *mut sock_tcp_t);
}
extern "C" {
	#[doc = " @brief   Stops listening on TCP listening queue"]
	#[doc = ""]
	#[doc = " @pre `queue != NULL`"]
	#[doc = ""]
	#[doc = " @param[in] queue A TCP listening queue."]
	pub fn sock_tcp_stop_listen(queue: *mut sock_tcp_queue_t);
}
extern "C" {
	#[doc = " @brief   Gets the local end point of a TCP sock object"]
	#[doc = ""]
	#[doc = " @pre `(sock != NULL) && (ep != NULL)`"]
	#[doc = ""]
	#[doc = " @param[in] sock  A TCP sock object."]
	#[doc = " @param[out] ep   The local end point."]
	#[doc = ""]
	#[doc = " @return  0 on success."]
	#[doc = " @return  -EADDRNOTAVAIL, when @p sock has no local end point."]
	pub fn sock_tcp_get_local(sock: *mut sock_tcp_t, ep: *mut sock_tcp_ep_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Gets the remote end point of a TCP sock object"]
	#[doc = ""]
	#[doc = " @pre `(sock != NULL) && (ep != NULL)`"]
	#[doc = ""]
	#[doc = " @param[in] sock  A TCP sock object."]
	#[doc = " @param[out] ep   The remote end point."]
	#[doc = ""]
	#[doc = " @return  0 on success."]
	#[doc = " @return  -ENOTCONN, when @p sock is not connected to a remote end point."]
	pub fn sock_tcp_get_remote(sock: *mut sock_tcp_t, ep: *mut sock_tcp_ep_t)
		-> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Gets the local end point of a TCP sock queue object"]
	#[doc = ""]
	#[doc = " @pre `(sock != NULL) && (ep != NULL)`"]
	#[doc = ""]
	#[doc = " @param[in] queue A TCP sock queue object."]
	#[doc = " @param[out] ep   The local end point."]
	#[doc = ""]
	#[doc = " @return  0 on success."]
	#[doc = " @return  -EADDRNOTAVAIL, when @p queue has no local end point."]
	pub fn sock_tcp_queue_get_local(
		queue: *mut sock_tcp_queue_t,
		ep: *mut sock_tcp_ep_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Receives and handles TCP connection requests from other peers"]
	#[doc = ""]
	#[doc = " @pre `(queue != NULL) && (sock != NULL)`"]
	#[doc = ""]
	#[doc = " @param[in] queue     A TCP listening queue."]
	#[doc = " @param[out] sock     A new TCP sock object for the established sock object."]
	#[doc = " @param[in] timeout   Timeout for accept in microseconds."]
	#[doc = "                      If 0 and no data is available, the function returns"]
	#[doc = "                      immediately."]
	#[doc = "                      May be @ref SOCK_NO_TIMEOUT for no timeout (wait until"]
	#[doc = "                      data is available)."]
	#[doc = ""]
	#[doc = " @return  0 on success."]
	#[doc = " @return  -EAGAIN, if @p timeout is `0` and no data is available."]
	#[doc = " @return  -ECONNABORTED, if the connection to @p sock has been aborted while"]
	#[doc = "          in this function"]
	#[doc = " @return  -EINVAL, if @p queue was not initialized using"]
	#[doc = "          @ref sock_tcp_listen()."]
	#[doc = " @return  -ENOMEM, if system was not able to allocate sufficient memory to"]
	#[doc = "          establish connection."]
	#[doc = " @return  -EPERM, if connections on local end point of @p queue are not"]
	#[doc = "          permitted on this system (e.g. by firewall rules)."]
	#[doc = " @return  -ETIMEDOUT, if the operation timed out internally."]
	pub fn sock_tcp_accept(
		queue: *mut sock_tcp_queue_t,
		sock: *mut *mut sock_tcp_t,
		timeout: u32,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Reads data from an established TCP stream"]
	#[doc = ""]
	#[doc = " @pre `(sock != NULL) && (data != NULL) && (max_len > 0)`"]
	#[doc = ""]
	#[doc = " @param[in] sock      A TCP sock object."]
	#[doc = " @param[out] data     Pointer where the read data should be stored."]
	#[doc = " @param[in] max_len   Maximum space available at @p data."]
	#[doc = "                      If read data exceeds @p max_len the data is"]
	#[doc = "                      truncated and the remaining data can be retrieved"]
	#[doc = "                      later on."]
	#[doc = " @param[in] timeout   Timeout for receive in microseconds."]
	#[doc = "                      If 0 and no data is available, the function returns"]
	#[doc = "                      immediately."]
	#[doc = "                      May be @ref SOCK_NO_TIMEOUT for no timeout (wait until"]
	#[doc = "                      data is available)."]
	#[doc = ""]
	#[doc = " @note    Function may block."]
	#[doc = ""]
	#[doc = " @return  The number of bytes read on success."]
	#[doc = " @return  0, if no read data is available or the connection was orderly closed"]
	#[doc = "          by the remote host."]
	#[doc = " @return  -EAGAIN, if @p timeout is `0` and no data is available."]
	#[doc = " @return  -ECONNABORTED, if the connection is aborted while waiting for the"]
	#[doc = "          next data."]
	#[doc = " @return  -ECONNRESET, if the connection was forcibly closed by remote end"]
	#[doc = "          point of @p sock."]
	#[doc = " @return  -ENOTCONN, when @p sock is not connected to a remote end point."]
	#[doc = " @return  -ETIMEDOUT, if @p timeout expired."]
	pub fn sock_tcp_read(
		sock: *mut sock_tcp_t,
		data: *mut ::core::ffi::c_void,
		max_len: usize,
		timeout: u32,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Writes data to an established TCP stream"]
	#[doc = ""]
	#[doc = " @pre `(sock != NULL)`"]
	#[doc = " @pre `if (len != NULL): (data != NULL)`"]
	#[doc = ""]
	#[doc = " @param[in] sock  A TCP sock object."]
	#[doc = " @param[in] data  Pointer to the data to be written to the stream."]
	#[doc = " @param[in] len   Maximum space available at @p data."]
	#[doc = ""]
	#[doc = " @note    Function may block."]
	#[doc = ""]
	#[doc = " @return  The number of bytes written on success."]
	#[doc = " @return  -ECONNABORTED, if the connection is aborted while waiting for the"]
	#[doc = "          next data."]
	#[doc = " @return  -ECONNRESET, if the connection was forcibly closed by remote end"]
	#[doc = "          point of @p sock."]
	#[doc = " @return  -ENOMEM, if no memory was available to written @p data."]
	#[doc = " @return  -ENOTCONN, if @p sock is not connected to a remote end point."]
	pub fn sock_tcp_write(
		sock: *mut sock_tcp_t,
		data: *const ::core::ffi::c_void,
		len: usize,
	) -> isize;
}
#[doc = " @brief   sock @ref net_gnrc_netreg info"]
#[doc = " @internal"]
pub type gnrc_sock_reg_t = gnrc_sock_reg;
#[doc = " @brief   sock @ref net_gnrc_netreg info"]
#[doc = " @internal"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gnrc_sock_reg {
	#[doc = "< @ref net_gnrc_netreg entry for mbox"]
	pub entry: gnrc_netreg_entry_t,
	#[doc = "< @ref core_mbox target for the sock"]
	pub mbox: mbox_t,
	#[doc = "< queue for gnrc_sock_reg_t::mbox"]
	pub mbox_queue: [msg_t; 8usize],
}
#[doc = " @brief   Raw IP sock type"]
#[doc = " @internal"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sock_ip {
	#[doc = "< netreg info"]
	pub reg: gnrc_sock_reg_t,
	#[doc = "< local end-point"]
	pub local: sock_ip_ep_t,
	#[doc = "< remote end-point"]
	pub remote: sock_ip_ep_t,
	#[doc = "< option flags"]
	pub flags: u16,
}
#[doc = " @brief   UDP sock type"]
#[doc = " @internal"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sock_udp {
	#[doc = "< netreg info"]
	pub reg: gnrc_sock_reg_t,
	#[doc = "< local end-point"]
	pub local: sock_udp_ep_t,
	#[doc = "< remote end-point"]
	pub remote: sock_udp_ep_t,
	#[doc = "< option flags"]
	pub flags: u16,
}
pub const coap_blksize_t_COAP_BLOCKSIZE_16: coap_blksize_t = 0;
pub const coap_blksize_t_COAP_BLOCKSIZE_32: coap_blksize_t = 1;
pub const coap_blksize_t_COAP_BLOCKSIZE_64: coap_blksize_t = 2;
pub const coap_blksize_t_COAP_BLOCKSIZE_128: coap_blksize_t = 3;
pub const coap_blksize_t_COAP_BLOCKSIZE_256: coap_blksize_t = 4;
pub const coap_blksize_t_COAP_BLOCKSIZE_512: coap_blksize_t = 5;
pub const coap_blksize_t_COAP_BLOCKSIZE_1024: coap_blksize_t = 6;
#[doc = " @brief Coap block-wise-transfer size SZX"]
pub type coap_blksize_t = ::core::ffi::c_uint;
#[doc = " @brief  struct iovec anonymous declaration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
	#[doc = "< Pointer to data."]
	pub iov_base: *mut ::core::ffi::c_void,
	#[doc = "< Length of data."]
	pub iov_len: usize,
}
pub type uword_t = u32;
pub type sword_t = i32;
#[doc = " @}"]
pub type sa_family_t = ::core::ffi::c_ushort;
#[doc = " @brief   Used to define the socket address."]
#[doc = ""]
#[doc = " @details This structure is is forced to be aligned as `uint32_t`, as e.g."]
#[doc = "          the IPv4 address is stored as `uint32_t`"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
	#[doc = "< Address family"]
	pub sa_family: sa_family_t,
	#[doc = "< Socket address (variable length data)"]
	pub sa_data: [::core::ffi::c_char; 26usize],
}
#[doc = " @brief   Implementation based socket address table."]
#[doc = " @extends struct sockaddr"]
#[doc = ""]
#[doc = " @details This structure is is forced to be aligned as `uint32_t`, as e.g."]
#[doc = "          the IPv4 address is stored as `uint32_t`"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
	#[doc = "< Address family"]
	pub ss_family: sa_family_t,
	#[doc = "< Socket address"]
	pub ss_data: [u8; 26usize],
}
extern "C" {
	#[doc = " @brief   Accept a new connection on a socket"]
	#[doc = " @details The accept() function shall extract the first connection on the"]
	#[doc = "          queue of pending connections, create a new socket with the same"]
	#[doc = "          socket type protocol and address family as the specified socket,"]
	#[doc = "          and allocate a new file descriptor for that socket."]
	#[doc = "          If the listen queue is empty of connection requests and O_NONBLOCK"]
	#[doc = "          is not set on the file descriptor for the socket, accept() shall"]
	#[doc = "          block until a connection is present. If the listen() queue is"]
	#[doc = "          empty of connection requests and O_NONBLOCK is set on the file"]
	#[doc = "          descriptor for the socket, accept() shall fail and set errno"]
	#[doc = "          to [EAGAIN] or [EWOULDBLOCK]. The accepted socket cannot itself"]
	#[doc = "          accept more connections. The original socket remains open and can"]
	#[doc = "          accept more connections."]
	#[doc = ""]
	#[doc = " @see <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html\">"]
	#[doc = "          The Open Group Base Specification Issue 7, accept"]
	#[doc = "      </a>"]
	#[doc = ""]
	#[doc = " @param[in] socket        Specifies a socket that was created with socket(),"]
	#[doc = "                          has been bound to an address with bind(),"]
	#[doc = "                          and has issued a successful call to listen()."]
	#[doc = " @param[out] address      Either a null pointer, or a pointer to a sockaddr"]
	#[doc = "                          structure where the address of the connecting socket"]
	#[doc = "                          shall be returned. If *address* is not a null"]
	#[doc = "                          pointer, the address of the peer for the accepted"]
	#[doc = "                          connection shall be stored in the sockaddr"]
	#[doc = "                          structure pointed to by *address*, and the length"]
	#[doc = "                          of this address shall be stored in the object"]
	#[doc = "                          pointed to by *address_len*. If the actual length"]
	#[doc = "                          of the address is greater than the length of the"]
	#[doc = "                          supplied sockaddr structure, the stored address"]
	#[doc = "                          shall be truncated. If the protocol permits"]
	#[doc = "                          connections by unbound clients, and the peer is not"]
	#[doc = "                          bound, then the value stored in the object pointed"]
	#[doc = "                          to by address is unspecified."]
	#[doc = " @param[out] address_len  Either a null pointer, if *address* is a null"]
	#[doc = "                          pointer, or a pointer to a socklen_t object which"]
	#[doc = "                          on input specifies the length of the supplied"]
	#[doc = "                          sockaddr structure, and on output specifies the"]
	#[doc = "                          length of the stored address."]
	#[doc = " @return  Upon successful completion, accept() shall return the non-negative"]
	#[doc = "          file descriptor of the accepted socket. Otherwise, -1 shall be"]
	#[doc = "          returned and errno set to indicate the error."]
	pub fn accept(
		socket: ::core::ffi::c_int,
		address: *mut sockaddr,
		address_len: *mut socklen_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Bind a name to a socket."]
	#[doc = " @details The bind() function shall assign a local socket address *address*"]
	#[doc = "          to a socket identified by descriptor socket that has no local"]
	#[doc = "          socket address assigned. Sockets created with the socket() function"]
	#[doc = "          are initially unnamed; they are identified only by their address"]
	#[doc = "          family."]
	#[doc = ""]
	#[doc = " @see <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html\">"]
	#[doc = "          The Open Group Base Specification Issue 7, bind"]
	#[doc = "      </a>"]
	#[doc = ""]
	#[doc = " @param socket        Specifies the file descriptor of the socket to be bound."]
	#[doc = " @param address       Points to a sockaddr structure containing the address"]
	#[doc = "                      to be bound to the socket. The length and format of the"]
	#[doc = "                      address depend on the address family of the socket."]
	#[doc = "                      If the address family of the socket is AF_UNIX and the"]
	#[doc = "                      pathname in address names a symbolic link, bind() shall"]
	#[doc = "                      fail and set errno to [EADDRINUSE]."]
	#[doc = " @param address_len   Specifies the length of the sockaddr structure pointed"]
	#[doc = "                      to by the *address* argument."]
	#[doc = " @return  Upon successful completion, bind() shall return 0; otherwise, -1"]
	#[doc = "          shall be returned and errno set to indicate the error."]
	pub fn bind(
		socket: ::core::ffi::c_int,
		address: *const sockaddr,
		address_len: socklen_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Connect a socket."]
	#[doc = " @details The connect() function shall attempt to make a connection on a"]
	#[doc = "          connection-mode socket or to set or reset the peer address of a"]
	#[doc = "          connectionless-mode socket."]
	#[doc = ""]
	#[doc = " @see <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html\">"]
	#[doc = "          The Open Group Base Specification Issue 7, connect"]
	#[doc = "      </a>"]
	#[doc = ""]
	#[doc = " @param[in] socket        Specifies the file descriptor associated with the"]
	#[doc = "                          socket."]
	#[doc = " @param[in] address       Points to a sockaddr structure containing the peer"]
	#[doc = "                          address. The length and format of the address depend"]
	#[doc = "                          on the address family of the socket."]
	#[doc = " @param[in] address_len   Specifies the length of the sockaddr structure"]
	#[doc = "                          pointed to by the address argument."]
	#[doc = " @post The socket will be implicitly bound to an addressed, if it is not already bound."]
	#[doc = "       According to"]
	#[doc = "       http://pubs.opengroup.org/onlinepubs/009695399/functions/connect.html"]
	#[doc = "       for a \"socket [that] has not already been bound to a local address,"]
	#[doc = "       connect() shall bind it to an address which, unless the socket's"]
	#[doc = "       address family is AF_UNIX, is an unused local address.\""]
	#[doc = ""]
	#[doc = " @return  Upon successful completion, connect() shall return 0; otherwise,"]
	#[doc = "          -1 shall be returned and errno set to indicate the error."]
	pub fn connect(
		socket: ::core::ffi::c_int,
		address: *const sockaddr,
		address_len: socklen_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Get the name of the peer socket."]
	#[doc = " @details The getpeername() function shall retrieve the peer address of the specified socket,"]
	#[doc = "          store this address in the sockaddr structure pointed to by the @p address argument,"]
	#[doc = "          and store the length of this address in the object pointed to by the @p address_len"]
	#[doc = "          argument."]
	#[doc = ""]
	#[doc = " @see <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html\">"]
	#[doc = "          The Open Group Base Specification Issue 7, getpeername"]
	#[doc = "      </a>"]
	#[doc = ""]
	#[doc = " @param[in] socket            Specifies the file descriptor associated with the"]
	#[doc = "                              socket."]
	#[doc = " @param[out] address          Points to a sockaddr structure containing the peer"]
	#[doc = "                              address. The length and format of the address depend"]
	#[doc = "                              on the address family of the socket."]
	#[doc = " @param[in,out] address_len   Specifies the length of the sockaddr structure on input and the"]
	#[doc = "                              length of the stored address on output. If the address is greater"]
	#[doc = "                              than the length of the supplied sockaddr structure, the stored"]
	#[doc = "                              address shal be truncated."]
	#[doc = " @return  Upon successful completion, getpeername() shall return 0; otherwise,"]
	#[doc = "          -1 shall be returned and errno set to indicate the error."]
	pub fn getpeername(
		socket: ::core::ffi::c_int,
		address: *mut sockaddr,
		address_len: *mut socklen_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Get the socket name."]
	#[doc = " @details The getsockname() function shall retrieve the locally-bound name of the specified"]
	#[doc = "          socket, store this address in the sockaddr structure pointed to by the @p address"]
	#[doc = "          argument, and store the length of this address in the object pointed to by the"]
	#[doc = "          @p address_len argument."]
	#[doc = ""]
	#[doc = " @see <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html\">"]
	#[doc = "          The Open Group Base Specification Issue 7, getsockname"]
	#[doc = "      </a>"]
	#[doc = ""]
	#[doc = " @param[in] socket            Specifies the file descriptor associated with the"]
	#[doc = "                              socket."]
	#[doc = " @param[out] address          Points to a sockaddr structure containing the peer"]
	#[doc = "                              address. The length and format of the address depend"]
	#[doc = "                              on the address family of the socket."]
	#[doc = " @param[in,out] address_len   Specifies the length of the sockaddr structure on input and the"]
	#[doc = "                              length of the stored address on output. If the address is greater"]
	#[doc = "                              than the length of the supplied sockaddr structure, the stored"]
	#[doc = "                              address shal be truncated."]
	#[doc = " @return  Upon successful completion, getsockname() shall return 0; otherwise,"]
	#[doc = "          -1 shall be returned and errno set to indicate the error."]
	pub fn getsockname(
		socket: ::core::ffi::c_int,
		address: *mut sockaddr,
		address_len: *mut socklen_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Listen for socket connections and limit the queue of incoming"]
	#[doc = "          connections."]
	#[doc = ""]
	#[doc = " @see <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html\">"]
	#[doc = "          The Open Group Base Specification Issue 7, listen"]
	#[doc = "      </a>"]
	#[doc = ""]
	#[doc = " @param[in] socket    Specifies the file descriptor associated with the socket."]
	#[doc = " @param[in] backlog   Provides a hint to the implementation which the"]
	#[doc = "                      implementation shall use to limit the number of"]
	#[doc = "                      outstanding connections in the socket's listen queue."]
	#[doc = "                      Implementations may impose a limit on backlog and"]
	#[doc = "                      silently reduce the specified value. Normally, a"]
	#[doc = "                      larger backlog argument value shall result in a larger"]
	#[doc = "                      or equal length of the listen queue. Implementations"]
	#[doc = "                      shall support values of backlog up to SOMAXCONN,"]
	#[doc = "                      defined in <sys/socket.h>."]
	#[doc = " @return  Upon successful completions, listen() shall return 0; otherwise,"]
	#[doc = "          -1 shall be returned and errno set to indicate the error."]
	pub fn listen(socket: ::core::ffi::c_int, backlog: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Receive a message from a socket."]
	#[doc = " @details The recvfrom() function shall receive a message from a"]
	#[doc = "          connection-mode or connectionless-mode socket. It is normally used"]
	#[doc = "          with connectionless-mode sockets because it permits the application"]
	#[doc = "          to retrieve the source address of received data."]
	#[doc = ""]
	#[doc = " @see <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html\">"]
	#[doc = "          The Open Group Base Specification Issue 7, recvfrom"]
	#[doc = "      </a>"]
	#[doc = ""]
	#[doc = " @param[in] socket        Specifies the socket file descriptor."]
	#[doc = " @param[out] buffer       Points to a buffer where the message should be i"]
	#[doc = "                          stored."]
	#[doc = " @param[in] length        Specifies the length in bytes of the buffer pointed"]
	#[doc = "                          to by the buffer argument."]
	#[doc = " @param[in] flags         Specifies the type of message reception. Support"]
	#[doc = "                          for values other than 0 is not implemented yet."]
	#[doc = " @param[out] address      A null pointer, or points to a sockaddr structure"]
	#[doc = "                          in which the sending address is to be stored. The"]
	#[doc = "                          length and format of the address depend on the"]
	#[doc = "                          address family of the socket."]
	#[doc = " @param[out] address_len  Either a null pointer, if address is a null pointer,"]
	#[doc = "                          or a pointer to a socklen_t object which on input"]
	#[doc = "                          specifies the length of the supplied sockaddr"]
	#[doc = "                          structure, and on output specifies the length of"]
	#[doc = "                          the stored address."]
	#[doc = ""]
	#[doc = " @return  Upon successful completion, recvfrom() shall return the length of"]
	#[doc = "          the message in bytes. If no messages are available to be received"]
	#[doc = "          and the peer has performed an orderly shutdown, recvfrom() shall"]
	#[doc = "          return 0. Otherwise, the function shall return -1 and set errno to"]
	#[doc = "          indicate the error."]
	pub fn recvfrom(
		socket: ::core::ffi::c_int,
		buffer: *mut ::core::ffi::c_void,
		length: usize,
		flags: ::core::ffi::c_int,
		address: *mut sockaddr,
		address_len: *mut socklen_t,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Send a message on a socket."]
	#[doc = " @details Shall send a message through a connection-mode or"]
	#[doc = "          connectionless-mode socket. If the socket is a connectionless-mode"]
	#[doc = "          socket, the message shall be sent to the address specified by"]
	#[doc = "          @p address if no pre-specified peer address has been set. If a"]
	#[doc = "          peer address has been pre-specified, either the message shall be"]
	#[doc = "          sent to the address specified by @p address (overriding the"]
	#[doc = "          pre-specified peer address), or the function shall return -1 and"]
	#[doc = "          set errno to EISCONN."]
	#[doc = ""]
	#[doc = " @see <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html\">"]
	#[doc = "          The Open Group Base Specification Issue 7, sendto"]
	#[doc = "      </a>"]
	#[doc = ""]
	#[doc = " @param[in] socket        Specifies the socket file descriptor."]
	#[doc = " @param[in] buffer        Points to the buffer containing the message to send."]
	#[doc = " @param[in] length        Specifies the length of the message in bytes."]
	#[doc = " @param[in] flags         Specifies the type of message reception. Support"]
	#[doc = "                          for values other than 0 is not implemented yet."]
	#[doc = " @param[in] address       Points to a sockaddr structure containing the"]
	#[doc = "                          destination address. The length and format of the"]
	#[doc = "                          address depend on the address family of the socket."]
	#[doc = " @param[in] address_len   Specifies the length of the sockaddr structure pointed"]
	#[doc = "                          to by the @p address argument."]
	#[doc = ""]
	#[doc = " @post    The socket will implicitly be bound to the unspecified address and"]
	#[doc = "          a random port, in case it is not already bound. Rationale: A client"]
	#[doc = "          should not require to explicitly call bind() to receive packets,"]
	#[doc = "          but is expected to receive replies sent to the ephemeral port that"]
	#[doc = "          was selected as a source port by the UDP implementation."]
	#[doc = ""]
	#[doc = " @todo    For @ref net_gnrc any @ref recvfrom call that is called to receive"]
	#[doc = "          an expected response to this send command, must be called from the"]
	#[doc = "          same thread. This is undesired behavior and will be fixed in"]
	#[doc = "          upcoming versions of RIOT."]
	#[doc = ""]
	#[doc = " @return  Upon successful completion, send() shall return the number of bytes"]
	#[doc = "          sent. Otherwise, -1 shall be returned and errno set to indicate the"]
	#[doc = "          error."]
	pub fn sendto(
		socket: ::core::ffi::c_int,
		buffer: *const ::core::ffi::c_void,
		length: usize,
		flags: ::core::ffi::c_int,
		address: *const sockaddr,
		address_len: socklen_t,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Create an endpoint for communication."]
	#[doc = " @details Shall create an unbound socket in a communications domain, and"]
	#[doc = "          return a file descriptor that can be used in later function calls"]
	#[doc = "          that operate on sockets."]
	#[doc = ""]
	#[doc = " @param[in] domain    Specifies the communications domain in which a socket"]
	#[doc = "                      is to be created. Valid values are prefixed with ``AF_`"]
	#[doc = "                      and defined in @ref socket.h."]
	#[doc = " @param[in] type      Specifies the type of socket to be created. Valued"]
	#[doc = "                      values are prefixed with ``SOCK_`` and defined in"]
	#[doc = "                      @ref socket.h."]
	#[doc = " @param[in] protocol  Specifies a particular protocol to be used with the"]
	#[doc = "                      socket. Specifying a protocol of 0 causes socket() to"]
	#[doc = "                      use an unspecified default protocol appropriate for"]
	#[doc = "                      the requested socket type."]
	#[doc = ""]
	#[doc = " @return  Upon successful completion, socket() shall return a non-negative"]
	#[doc = "          integer, the socket file descriptor. Otherwise, a value of -1 shall"]
	#[doc = "          be returned and errno set to indicate the error."]
	pub fn socket(
		domain: ::core::ffi::c_int,
		type_: ::core::ffi::c_int,
		protocol: ::core::ffi::c_int,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn setsockopt(
		socket: ::core::ffi::c_int,
		level: ::core::ffi::c_int,
		option_name: ::core::ffi::c_int,
		option_value: *const ::core::ffi::c_void,
		option_len: socklen_t,
	) -> ::core::ffi::c_int;
}
#[doc = " @todo IPv6 option names"]
pub type in_port_t = u16;
pub type in_addr_t = u32;
#[doc = " IPv4 address structure type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
	#[doc = "< an IPv4 address"]
	pub s_addr: in_addr_t,
}
#[doc = " @brief   IPv6 address structure type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in6_addr {
	#[doc = "< unsigned 8-bit integer array"]
	pub s6_addr: [u8; 16usize],
}
#[doc = " @brief   IPv4 socket address type."]
#[doc = " @extends struct sockaddr"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
	#[doc = "< Protocol family, always AF_INET"]
	pub sin_family: sa_family_t,
	#[doc = "< Port number"]
	pub sin_port: in_port_t,
	#[doc = "< IPv4 address"]
	pub sin_addr: in_addr,
}
#[doc = " IPv6 socket address type."]
#[doc = " @extends struct sockaddr"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in6 {
	#[doc = "< Protocol family, always AF_INET6"]
	pub sin6_family: sa_family_t,
	#[doc = "< Port number"]
	pub sin6_port: in_port_t,
	#[doc = "< IPv6 traffic class and flow information"]
	pub sin6_flowinfo: u32,
	#[doc = "< IPv6 address"]
	pub sin6_addr: in6_addr,
	#[doc = "< Set of interfaces for a scope"]
	pub sin6_scope_id: u32,
}
#[doc = " @brief   IPv6 multicast request."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipv6_mreq {
	#[doc = "< an IPv6 multicast address"]
	pub ipv6mr_multiaddr: in6_addr,
	#[doc = "< interface index, leave 0 for default"]
	pub ipv6mr_interface: ::core::ffi::c_uint,
}
extern "C" {
	#[doc = " IPv6 socket address for the wildcard address."]
	pub static in6addr_any: in6_addr;
}
extern "C" {
	#[doc = " IPv6 socket address for the loopback address."]
	pub static in6addr_loopback: in6_addr;
}
extern "C" {
	#[doc = " @brief   Converts an IP address to its string representation"]
	#[doc = ""]
	#[doc = " @pre (af == AF_INET) || (af == AF_INET6)"]
	#[doc = ""]
	#[doc = " @param[in] af    Address family of @p src. Must be @ref AF_INET or @ref AF_INET6."]
	#[doc = " @param[in] src   An IP address."]
	#[doc = " @param[out] dst  The resulting string representation."]
	#[doc = " @param[in] size  Length of @p result."]
	#[doc = ""]
	#[doc = " @return  @p dst, on success"]
	#[doc = " @return  NULL, if @p size was smaller than needed"]
	#[doc = " @return  NULL, if @p src or @p dst was NULL"]
	pub fn inet_ntop(
		af: ::core::ffi::c_int,
		src: *const ::core::ffi::c_void,
		dst: *mut ::core::ffi::c_char,
		size: socklen_t,
	) -> *const ::core::ffi::c_char;
}
extern "C" {
	#[doc = " @brief   Converts an IP address string representation to a byte-represented"]
	#[doc = "          IP address"]
	#[doc = ""]
	#[doc = " @pre (af == AF_INET) || (af == AF_INET6)"]
	#[doc = ""]
	#[doc = " @param[in] af    Address family of @p src. Must be @ref AF_INET or @ref AF_INET6."]
	#[doc = " @param[in] src   An IP address string representation"]
	#[doc = " @param[out] dst   The resulting byte representation"]
	#[doc = ""]
	#[doc = " @return  1, on success."]
	#[doc = " @return  0, if @p src was malformed or input pointers were NULL."]
	#[doc = " @return  -1, if @p af is not supported."]
	pub fn inet_pton(
		af: ::core::ffi::c_int,
		src: *const ::core::ffi::c_char,
		dst: *mut ::core::ffi::c_void,
	) -> ::core::ffi::c_int;
}
#[doc = " @brief   Raw CoAP PDU header structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct coap_hdr_t {
	#[doc = "< version, token, token length"]
	pub ver_t_tkl: u8,
	#[doc = "< CoAP code (e.g.m 205)"]
	pub code: u8,
	#[doc = "< Req/resp ID"]
	pub id: u16,
}
#[doc = " @brief   CoAP option array entry"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct coap_optpos_t {
	#[doc = "< full CoAP option number"]
	pub opt_num: u16,
	#[doc = "< offset in packet"]
	pub offset: u16,
}
#[doc = " @brief   CoAP PDU parsing context structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct coap_pkt_t {
	#[doc = "< pointer to raw packet"]
	pub hdr: *mut coap_hdr_t,
	#[doc = "< pointer to token"]
	pub token: *mut u8,
	#[doc = "< pointer to payload"]
	pub payload: *mut u8,
	#[doc = "< length of payload"]
	pub payload_len: u16,
	#[doc = "< length of options array"]
	pub options_len: u16,
	#[doc = "< option offset array"]
	pub options: [coap_optpos_t; 16usize],
	pub opt_crit: [u8; 2usize],
}
#[doc = " @brief   Resource handler type"]
#[doc = ""]
#[doc = " Functions that implement this must be prepared to be called multiple times"]
#[doc = " for the same request, as the server implementations do not perform message"]
#[doc = " deduplication. That optimization is [described in the CoAP"]
#[doc = " specification](https://tools.ietf.org/html/rfc7252#section-4.5)."]
#[doc = ""]
#[doc = " This should be trivial for requests of the GET, PUT, DELETE, FETCH and"]
#[doc = " iPATCH methods, as they are defined as idempotent methods in CoAP."]
#[doc = ""]
#[doc = " For POST, PATCH and other non-idempotent methods, this is an additional"]
#[doc = " requirement introduced by the contract of this type."]
pub type coap_handler_t = ::core::option::Option<
	unsafe extern "C" fn(
		pkt: *mut coap_pkt_t,
		buf: *mut u8,
		len: usize,
		context: *mut ::core::ffi::c_void,
	) -> isize,
>;
#[doc = " @brief   Coap blockwise request callback descriptor"]
#[doc = ""]
#[doc = " @param[in] arg      Pointer to be passed as arguments to the callback"]
#[doc = " @param[in] offset   Offset of received data"]
#[doc = " @param[in] buf      Pointer to the received data"]
#[doc = " @param[in] len      Length of the received data"]
#[doc = " @param[in] more     -1 for no option, 0 for last block, 1 for more blocks"]
#[doc = ""]
#[doc = " @returns    0       on success"]
#[doc = " @returns   -1       on error"]
pub type coap_blockwise_cb_t = ::core::option::Option<
	unsafe extern "C" fn(
		arg: *mut ::core::ffi::c_void,
		offset: usize,
		buf: *mut u8,
		len: usize,
		more: ::core::ffi::c_int,
	) -> ::core::ffi::c_int,
>;
#[doc = " @brief   Method flag type"]
#[doc = ""]
#[doc = " Must be large enough to contain all @ref nanocoap_method_flags \"CoAP method flags\""]
pub type coap_method_flags_t = u16;
#[doc = " @brief   Type for CoAP resource entry"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct coap_resource_t {
	#[doc = "< URI path of resource"]
	pub path: *const ::core::ffi::c_char,
	#[doc = "< OR'ed methods this resource allows"]
	pub methods: coap_method_flags_t,
	#[doc = "< ptr to resource handler"]
	pub handler: coap_handler_t,
	#[doc = "< ptr to user defined context data"]
	pub context: *mut ::core::ffi::c_void,
}
#[doc = " @brief   Block1 helper struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct coap_block1_t {
	#[doc = "< offset of received data"]
	pub offset: usize,
	#[doc = "< block number"]
	pub blknum: u32,
	#[doc = "< szx value"]
	pub szx: ::core::ffi::c_uint,
	#[doc = "< -1 for no option, 0 for last block,"]
	#[doc = "1 for more blocks coming"]
	pub more: ::core::ffi::c_int,
}
#[doc = " @brief Blockwise transfer helper struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct coap_block_slicer_t {
	#[doc = "< Start offset of the current block"]
	pub start: usize,
	#[doc = "< End offset of the current block"]
	pub end: usize,
	#[doc = "< Offset of the generated content"]
	pub cur: usize,
	#[doc = "< Pointer to the placed option"]
	pub opt: *mut u8,
}
extern "C" {
	#[doc = " @brief   Global CoAP resource list"]
	pub static coap_resources: [coap_resource_t; 0usize];
}
extern "C" {
	#[doc = " @brief   Number of entries in global CoAP resource list"]
	pub static coap_resources_numof: ::core::ffi::c_uint;
}
extern "C" {
	#[doc = " @brief   Get pointer to an option field by type"]
	#[doc = ""]
	#[doc = " @param[in]   pkt     packet to work on"]
	#[doc = " @param[in]   opt_num the option number to search for"]
	#[doc = ""]
	#[doc = " @returns     pointer to the option data"]
	#[doc = "              NULL if option number was not found"]
	pub fn coap_find_option(pkt: *mut coap_pkt_t, opt_num: ::core::ffi::c_uint) -> *mut u8;
}
extern "C" {
	#[doc = " @brief   Get content type from packet"]
	#[doc = ""]
	#[doc = " @param[in]   pkt     packet to work on"]
	#[doc = ""]
	#[doc = " @returns     the packet's content type value if included,"]
	#[doc = "              COAP_FORMAT_NONE otherwise"]
	pub fn coap_get_content_type(pkt: *mut coap_pkt_t) -> ::core::ffi::c_uint;
}
extern "C" {
	#[doc = " @brief   Get a uint32 option value"]
	#[doc = ""]
	#[doc = " @param[in]   pkt         packet to read from"]
	#[doc = " @param[in]   optnum      absolute option number"]
	#[doc = " @param[out]  value       the parsed option value"]
	#[doc = ""]
	#[doc = " @return      0 if the option was found and the value was parsed correctly"]
	#[doc = " @return      -ENOENT if the option was not found in @p pkt"]
	#[doc = " @return      -ENOSPC if option length is greater than 4 octets"]
	#[doc = " @return      -EBADMSG if option value is invalid"]
	pub fn coap_opt_get_uint(
		pkt: *mut coap_pkt_t,
		optnum: u16,
		value: *mut u32,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Read a full option as null terminated string into the target buffer"]
	#[doc = ""]
	#[doc = " This function is for reading and concatenating string based, multi-part CoAP"]
	#[doc = " options like COAP_OPT_URI_PATH or COAP_OPT_LOCATION_PATH. It will write all"]
	#[doc = " parts of the given option into the target buffer, separating the parts using"]
	#[doc = " the given @p separator. The resulting string is `\\0` terminated."]
	#[doc = ""]
	#[doc = " @param[in]   pkt         packet to read from"]
	#[doc = " @param[in]   optnum      absolute option number"]
	#[doc = " @param[out]  target      target buffer"]
	#[doc = " @param[in]   max_len     size of @p target"]
	#[doc = " @param[in]   separator   character used for separating the option parts"]
	#[doc = ""]
	#[doc = " @return      -ENOSPC if the complete option does not fit into @p target"]
	#[doc = " @return      nr of bytes written to @p target (including '\\0')"]
	pub fn coap_opt_get_string(
		pkt: *mut coap_pkt_t,
		optnum: u16,
		target: *mut u8,
		max_len: usize,
		separator: ::core::ffi::c_char,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Iterate over a packet's options"]
	#[doc = ""]
	#[doc = " To start iteration from the first option, set @p init_opt to true. To start"]
	#[doc = " iteration from a specific option, set @p init_opt to false, set"]
	#[doc = " @p opt->offset to the offset of the desired option from pkt->hdr, and"]
	#[doc = " @p opt->opt_num as required. See below for how @p opt->opt_num is modified."]
	#[doc = ""]
	#[doc = " With each invocation, this function returns the length of the option value"]
	#[doc = " and sets @p value to point to the start of the value. The value for"]
	#[doc = " @p opt->opt_num is increased by the delta in the option number value over"]
	#[doc = " the preceding option in the packet. So, @p opt->opt_num is accurate if"]
	#[doc = " iteration started with the first option. Otherwise, it is useful for"]
	#[doc = " identification of repeated options. Finally, @p opt->offset is set to the"]
	#[doc = " offset for any following option, to prepare for the next iteration."]
	#[doc = ""]
	#[doc = " The end of the options is indicated by a -ENOENT return value. In this case"]
	#[doc = " @p value and @p opt are unchanged from their input values."]
	#[doc = ""]
	#[doc = " @param[in]     pkt         packet to read from"]
	#[doc = " @param[in,out] opt         option attributes; read on input if @p init_opt"]
	#[doc = "                            is false"]
	#[doc = " @param[out]    value       start of the option value"]
	#[doc = " @param[in]     init_opt    true to retrieve first option; false to retrieve"]
	#[doc = "                            option at opt->offset"]
	#[doc = ""]
	#[doc = " @return        length of option value"]
	#[doc = " @return        -ENOENT if option not found"]
	pub fn coap_opt_get_next(
		pkt: *const coap_pkt_t,
		opt: *mut coap_optpos_t,
		value: *mut *mut u8,
		init_opt: bool,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Retrieve the value for an option as an opaque array of bytes"]
	#[doc = ""]
	#[doc = " Retrieves the location and length of the option value of any type. Useful for"]
	#[doc = " an opaque option, which essentially is an array of bytes. If more than one"]
	#[doc = " option for a given option number, retrieves the first option. To retrieve"]
	#[doc = " subsequent options, see coap_opt_get_next()."]
	#[doc = ""]
	#[doc = " @param[in]     pkt         packet to read from"]
	#[doc = " @param[in]     opt_num     option number to retrieve"]
	#[doc = " @param[out]    value       start of the option value"]
	#[doc = ""]
	#[doc = " @return        length of option; 0 if the option exists but is empty"]
	#[doc = " @return        -ENOENT if option not found"]
	#[doc = " @return        -EINVAL if option cannot be parsed"]
	pub fn coap_opt_get_opaque(
		pkt: *mut coap_pkt_t,
		opt_num: ::core::ffi::c_uint,
		value: *mut *mut u8,
	) -> isize;
}
extern "C" {
	#[doc = " @name    Functions -- Options for Block"]
	#[doc = ""]
	#[doc = " Read Block1 (POST/PUT request) or Block2 (GET response) options, and"]
	#[doc = " generally useful functions to write block options."]
	#[doc = " @brief Initialize a block struct from content information"]
	#[doc = ""]
	#[doc = " @param[out]   block      block struct to initialize"]
	#[doc = " @param[in]    blknum     offset from the beginning of content, in terms of"]
	#[doc = "@p blksize byte blocks"]
	#[doc = " @param[in]    blksize    size of each block; must be a power of 2 between 16"]
	#[doc = "                          and 2 raised to #CONFIG_NANOCOAP_BLOCK_SIZE_EXP_MAX"]
	#[doc = " @param[in]    more       more blocks? use 1 if yes; 0 if no or unknown"]
	pub fn coap_block_object_init(
		block: *mut coap_block1_t,
		blknum: usize,
		blksize: usize,
		more: ::core::ffi::c_int,
	);
}
extern "C" {
	#[doc = " @brief Finish a block request (block1 or block2)"]
	#[doc = ""]
	#[doc = " This function finalizes the block response header"]
	#[doc = ""]
	#[doc = " Checks whether the `more` bit should be set in the block option and"]
	#[doc = " sets/clears it if required.  Doesn't return the number of bytes, as this"]
	#[doc = " function overwrites bytes in the packet rather than adding new."]
	#[doc = ""]
	#[doc = " @param[in]     slicer      Preallocated slicer struct to use"]
	#[doc = " @param[in]     option      option number (block1 or block2)"]
	#[doc = ""]
	#[doc = " @return      true if the `more` bit is set in the block option"]
	#[doc = " @return      false if the `more` bit is not set the block option"]
	pub fn coap_block_finish(slicer: *mut coap_block_slicer_t, option: u16) -> bool;
}
extern "C" {
	#[doc = " @brief Initialize a block2 slicer struct for writing the payload"]
	#[doc = ""]
	#[doc = " This function determines the size of the response payload based on the"]
	#[doc = " size requested by the client in @p pkt."]
	#[doc = ""]
	#[doc = " @param[in]   pkt         packet to work on"]
	#[doc = " @param[out]  slicer      Preallocated slicer struct to fill"]
	pub fn coap_block2_init(pkt: *mut coap_pkt_t, slicer: *mut coap_block_slicer_t);
}
extern "C" {
	#[doc = " @brief Initialize a block slicer struct from content information"]
	#[doc = ""]
	#[doc = " @param[out]   slicer     slicer struct to initialize"]
	#[doc = " @param[in]    blknum     offset from the beginning of content, in terms of"]
	#[doc = "@p blksize byte blocks"]
	#[doc = " @param[in]    blksize    size of each block; must be a power of 2 between 16"]
	#[doc = "                          and 2 raised to #CONFIG_NANOCOAP_BLOCK_SIZE_EXP_MAX"]
	pub fn coap_block_slicer_init(slicer: *mut coap_block_slicer_t, blknum: usize, blksize: usize);
}
extern "C" {
	#[doc = " @brief Add a byte array to a block2 reply."]
	#[doc = ""]
	#[doc = " This function is used to add an array of bytes to a CoAP block2 reply. it"]
	#[doc = " checks which parts of the string should be added to the reply and ignores"]
	#[doc = " parts that are outside the current block2 request."]
	#[doc = ""]
	#[doc = " @param[in]   slicer      slicer to use"]
	#[doc = " @param[in]   bufpos      pointer to the current payload buffer position"]
	#[doc = " @param[in]   c           byte array to copy"]
	#[doc = " @param[in]   len         length of the byte array"]
	#[doc = ""]
	#[doc = " @returns     Number of bytes written to @p bufpos"]
	pub fn coap_blockwise_put_bytes(
		slicer: *mut coap_block_slicer_t,
		bufpos: *mut u8,
		c: *const u8,
		len: usize,
	) -> usize;
}
extern "C" {
	#[doc = " @brief Add a single character to a block2 reply."]
	#[doc = ""]
	#[doc = " This function is used to add single characters to a CoAP block2 reply. It"]
	#[doc = " checks whether the character should be added to the buffer and ignores it"]
	#[doc = " when the character is outside the current block2 request."]
	#[doc = ""]
	#[doc = " @param[in]   slicer      slicer to use"]
	#[doc = " @param[in]   bufpos      pointer to the current payload buffer position"]
	#[doc = " @param[in]   c           character to write"]
	#[doc = ""]
	#[doc = " @returns     Number of bytes written to @p bufpos"]
	pub fn coap_blockwise_put_char(
		slicer: *mut coap_block_slicer_t,
		bufpos: *mut u8,
		c: ::core::ffi::c_char,
	) -> usize;
}
extern "C" {
	#[doc = " @brief    Block option getter"]
	#[doc = ""]
	#[doc = " This function gets a CoAP packet's block option and parses it into a helper"]
	#[doc = " structure."]
	#[doc = ""]
	#[doc = " If no block option is present in @p pkt, the values in @p block will be"]
	#[doc = " initialized with zero. That implies both block->offset and block->more are"]
	#[doc = " also valid in that case, as packet with offset==0 and more==0 means it contains"]
	#[doc = " all the payload for the corresponding request."]
	#[doc = ""]
	#[doc = " @param[in]   pkt     pkt to work on"]
	#[doc = " @param[out]  block   ptr to preallocated coap_block1_t structure"]
	#[doc = " @param[in]   option  block1 or block2"]
	#[doc = ""]
	#[doc = " @returns     0 if block option not present"]
	#[doc = " @returns     1 if structure has been filled"]
	pub fn coap_get_block(
		pkt: *mut coap_pkt_t,
		block: *mut coap_block1_t,
		option: u16,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief    Generic block option getter"]
	#[doc = ""]
	#[doc = " @param[in]   pkt     pkt to work on"]
	#[doc = " @param[in]   option  actual block option number to get"]
	#[doc = " @param[out]  blknum  block number"]
	#[doc = " @param[out]  szx     SZX value"]
	#[doc = ""]
	#[doc = " @returns     -1 if option not found"]
	#[doc = " @returns     0 if more flag is not set"]
	#[doc = " @returns     1 if more flag is set"]
	pub fn coap_get_blockopt(
		pkt: *mut coap_pkt_t,
		option: u16,
		blknum: *mut u32,
		szx: *mut ::core::ffi::c_uint,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief    Check whether any of the packet's options that are critical"]
	#[doc = ""]
	#[doc = " (i.e must be understood by the receiver, indicated by a 1 in the option number's least"]
	#[doc = " significant bit) were not accessed since the packet was parsed."]
	#[doc = ""]
	#[doc = " Call this in a server on requests after all their option processing has happened,"]
	#[doc = " and stop processing the request if it returns true, returning a 4.02 Bad Option response."]
	#[doc = ""]
	#[doc = " Call this in a client when receiving a response before acting on it;"]
	#[doc = " consider the response unprocessable if it returns true."]
	#[doc = ""]
	#[doc = " @param[in]   pkt     pkt to work on"]
	#[doc = ""]
	#[doc = " @returns true if any of the options marked as critical at parse time have not been accessed."]
	#[doc = " @returns false if there are no critical options, or all have been accessed."]
	pub fn coap_has_unprocessed_critical_options(pkt: *const coap_pkt_t) -> bool;
}
extern "C" {
	#[doc = " @name    Functions -- Options Write Packet API"]
	#[doc = ""]
	#[doc = " Use a coap_pkt_t struct to manage writing Options to the PDU."]
	#[doc = ""]
	#[doc = " The caller must monitor space remaining in the buffer; however, the API"]
	#[doc = " *will not* write past the end of the buffer, and returns -ENOSPC when it is"]
	#[doc = " full."]
	#[doc = " @brief   Add block option in descriptive use from a slicer object"]
	#[doc = ""]
	#[doc = " When calling this function to initialize a packet with a block option, the"]
	#[doc = " more flag must be set to prevent the creation of an option with a length too"]
	#[doc = " small to contain the size bit."]
	#[doc = ""]
	#[doc = " @post pkt.payload advanced to first byte after option"]
	#[doc = " @post pkt.payload_len reduced by option length"]
	#[doc = ""]
	#[doc = " @param[in,out] pkt         pkt referencing target buffer"]
	#[doc = " @param[in]     slicer      coap blockwise slicer helper struct"]
	#[doc = " @param[in]     more        more flag (1 or 0)"]
	#[doc = " @param[in]     option      option number (block1 or block2)"]
	#[doc = ""]
	#[doc = " @return        number of bytes written to buffer"]
	#[doc = " @return        <0 on error"]
	#[doc = " @return        -ENOSPC if no available options or insufficient buffer space"]
	pub fn coap_opt_add_block(
		pkt: *mut coap_pkt_t,
		slicer: *mut coap_block_slicer_t,
		more: bool,
		option: u16,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Encode the given uint option into pkt"]
	#[doc = ""]
	#[doc = " @post pkt.payload advanced to first byte after option"]
	#[doc = " @post pkt.payload_len reduced by option length"]
	#[doc = ""]
	#[doc = " @param[in,out] pkt         pkt referencing target buffer"]
	#[doc = " @param[in]     optnum      option number to use"]
	#[doc = " @param[in]     value       uint to encode"]
	#[doc = ""]
	#[doc = " @return        number of bytes written to buffer"]
	#[doc = " @return        <0 on error"]
	#[doc = " @return        -ENOSPC if no available options or insufficient buffer space"]
	pub fn coap_opt_add_uint(pkt: *mut coap_pkt_t, optnum: u16, value: u32) -> isize;
}
extern "C" {
	#[doc = " @brief   Encode the given buffer as an opaque data option into pkt"]
	#[doc = ""]
	#[doc = " @post pkt.payload advanced to first byte after option(s)"]
	#[doc = " @post pkt.payload_len reduced by option(s) length"]
	#[doc = ""]
	#[doc = " @param[in,out] pkt         pkt referencing target buffer"]
	#[doc = " @param[in]     optnum      option number to use"]
	#[doc = " @param[in]     val         pointer to the value to be set"]
	#[doc = " @param[in]     val_len     length of val"]
	#[doc = ""]
	#[doc = " @return        number of bytes written to buffer"]
	#[doc = " @return        <0 on error"]
	#[doc = " @return        -ENOSPC if no available options"]
	pub fn coap_opt_add_opaque(
		pkt: *mut coap_pkt_t,
		optnum: u16,
		val: *const u8,
		val_len: usize,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Adds a single Uri-Query option in the form 'key=value' into pkt"]
	#[doc = ""]
	#[doc = ""]
	#[doc = " @param[in,out] pkt         Packet being built"]
	#[doc = " @param[in]     key         Key to add to the query string"]
	#[doc = " @param[in]     key_len     Length of @p key"]
	#[doc = " @param[in]     val         Value to assign to @p key (may be NULL)"]
	#[doc = " @param[in]     val_len     Length of @p val. 0 if @p val is NULL"]
	#[doc = ""]
	#[doc = " @pre     ((pkt != NULL) && (key != NULL) && (key_len > 0)"]
	#[doc = "              && ((val_len == 0) || ((val != NULL) && (val_len > 0))))"]
	#[doc = ""]
	#[doc = " @return        number of bytes written to pkt buffer"]
	#[doc = " @return        <0 on error"]
	#[doc = " @return        -ENOSPC if no available options or pkt full"]
	pub fn coap_opt_add_uri_query2(
		pkt: *mut coap_pkt_t,
		key: *const ::core::ffi::c_char,
		key_len: usize,
		val: *const ::core::ffi::c_char,
		val_len: usize,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Adds a single Proxy-URI option into @p pkt"]
	#[doc = ""]
	#[doc = " @note @p uri must be a NULL-terminated absolute URI"]
	#[doc = ""]
	#[doc = " @param[in,out] pkt         Packet being built"]
	#[doc = " @param[in]     uri         absolute proxy URI"]
	#[doc = ""]
	#[doc = " @pre     ((pkt != NULL) && (uri != NULL))"]
	#[doc = ""]
	#[doc = " @return        number of bytes written to pkt buffer"]
	#[doc = " @return        <0 on error"]
	#[doc = " @return        -ENOSPC if no available options or pkt full"]
	pub fn coap_opt_add_proxy_uri(pkt: *mut coap_pkt_t, uri: *const ::core::ffi::c_char) -> isize;
}
extern "C" {
	#[doc = " @brief   Encode the given array of characters as option(s) into pkt"]
	#[doc = ""]
	#[doc = " Use separator to split array of characters into multiple options."]
	#[doc = ""]
	#[doc = " @post pkt.payload advanced to first byte after option(s)"]
	#[doc = " @post pkt.payload_len reduced by option(s) length"]
	#[doc = ""]
	#[doc = " @param[in,out] pkt         pkt referencing target buffer"]
	#[doc = " @param[in]     optnum      option number to use"]
	#[doc = " @param[in]     chars       array of characters to encode as option"]
	#[doc = " @param[in]     chars_len   length of @p chars"]
	#[doc = " @param[in]     separator   character used in @p string to separate parts"]
	#[doc = ""]
	#[doc = " @return        number of bytes written to buffer"]
	#[doc = " @return        <0 on error"]
	#[doc = " @return        -ENOSPC if no available options or insufficient buffer space"]
	pub fn coap_opt_add_chars(
		pkt: *mut coap_pkt_t,
		optnum: u16,
		chars: *const ::core::ffi::c_char,
		chars_len: usize,
		separator: ::core::ffi::c_char,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Finalizes options as required and prepares for payload"]
	#[doc = ""]
	#[doc = " @post pkt.payload advanced to first available byte after options"]
	#[doc = " @post pkt.payload_len is maximum bytes available for payload"]
	#[doc = ""]
	#[doc = " @param[in,out] pkt         pkt to update"]
	#[doc = " @param[in]     flags       see COAP_OPT_FINISH... macros"]
	#[doc = ""]
	#[doc = " @return        total number of bytes written to buffer"]
	#[doc = " @return        -ENOSPC if no buffer space for payload marker"]
	pub fn coap_opt_finish(pkt: *mut coap_pkt_t, flags: u16) -> isize;
}
extern "C" {
	#[doc = " @name    Functions -- Options Write Buffer API"]
	#[doc = ""]
	#[doc = " Write PDU Options directly to the array of bytes for a message."]
	#[doc = ""]
	#[doc = " The caller must provide the last option number written as well as the buffer"]
	#[doc = " position. The caller is primarily responsible for tracking and managing the"]
	#[doc = " space remaining in the buffer."]
	#[doc = " @brief   Insert block option into buffer"]
	#[doc = ""]
	#[doc = " When calling this function to initialize a packet with a block option, the"]
	#[doc = " more flag must be set to prevent the creation of an option with a length too"]
	#[doc = " small to contain the size bit."]
	#[doc = ""]
	#[doc = " @param[out]  buf         buffer to write to"]
	#[doc = " @param[in]   lastonum    number of previous option, must be < @p option"]
	#[doc = " @param[in]   slicer      coap blockwise slicer helper struct"]
	#[doc = " @param[in]   more        more flag (1 or 0)"]
	#[doc = " @param[in]   option      option number (block1 or block2)"]
	#[doc = ""]
	#[doc = " @returns     amount of bytes written to @p buf"]
	pub fn coap_opt_put_block(
		buf: *mut u8,
		lastonum: u16,
		slicer: *mut coap_block_slicer_t,
		more: bool,
		option: u16,
	) -> usize;
}
extern "C" {
	#[doc = " @brief   Encode the given uint option into buffer"]
	#[doc = ""]
	#[doc = " @param[out]  buf         buffer to write to"]
	#[doc = " @param[in]   lastonum    number of previous option (for delta calculation),"]
	#[doc = "                          or 0 for first option"]
	#[doc = " @param[in]   onum        number of option"]
	#[doc = " @param[in]   value       value to encode"]
	#[doc = ""]
	#[doc = " @returns     amount of bytes written to @p buf"]
	pub fn coap_opt_put_uint(buf: *mut u8, lastonum: u16, onum: u16, value: u32) -> usize;
}
extern "C" {
	#[doc = " @brief   Encode the given string as multi-part option into buffer"]
	#[doc = ""]
	#[doc = " @param[out]  buf         buffer to write to"]
	#[doc = " @param[in]   lastonum    number of previous option (for delta calculation),"]
	#[doc = "                          or 0 if first option"]
	#[doc = " @param[in]   optnum      option number to use"]
	#[doc = " @param[in]   string      string to encode as option"]
	#[doc = " @param[in]   len         length of the string"]
	#[doc = " @param[in]   separator   character used in @p string to separate parts"]
	#[doc = ""]
	#[doc = " @return      number of bytes written to @p buf"]
	pub fn coap_opt_put_string_with_len(
		buf: *mut u8,
		lastonum: u16,
		optnum: u16,
		string: *const ::core::ffi::c_char,
		len: usize,
		separator: ::core::ffi::c_char,
	) -> usize;
}
extern "C" {
	#[doc = " @brief   Convenience function for inserting URI_PATH and URI_QUERY into buffer"]
	#[doc = "          This function will automatically split path and query parameters."]
	#[doc = ""]
	#[doc = " @param[out]  buf         buffer to write to"]
	#[doc = " @param[in,out] lastonum  number of previous option (for delta calculation),"]
	#[doc = "                          or 0 if first option"]
	#[doc = " @param[in]   uri         ptr into a source URI, to the first character after"]
	#[doc = "                          the authority component"]
	#[doc = ""]
	#[doc = " @returns     amount of bytes written to @p buf"]
	#[doc = ""]
	#[doc = " This function may produce two different options (Uri-Path and Uri-Query)."]
	#[doc = " Users that need to insert Content-Format, Max-Age or the currently"]
	#[doc = " unassigned option 13 need to split their URI themselves and call the"]
	#[doc = " respective helper functions."]
	pub fn coap_opt_put_uri_pathquery(
		buf: *mut u8,
		lastonum: *mut u16,
		uri: *const ::core::ffi::c_char,
	) -> usize;
}
extern "C" {
	#[doc = " @brief   Insert block1 option into buffer (from coap_block1_t)"]
	#[doc = ""]
	#[doc = " This function is wrapper around @ref coap_put_option_block1(),"]
	#[doc = " taking its arguments from a coap_block1_t struct."]
	#[doc = ""]
	#[doc = " It will write option Nr. 27 (COAP_OPT_BLOCK1)."]
	#[doc = ""]
	#[doc = " It is safe to be called when @p block1 was generated for a non-blockwise"]
	#[doc = " request."]
	#[doc = ""]
	#[doc = " @param[in]   pkt_pos     buffer to write to"]
	#[doc = " @param[in]   block1      ptr to block1 struct (created by coap_get_block1())"]
	#[doc = " @param[in]   lastonum    last option number (must be < 27)"]
	#[doc = ""]
	#[doc = " @returns     amount of bytes written to @p pkt_pos"]
	pub fn coap_put_block1_ok(pkt_pos: *mut u8, block1: *mut coap_block1_t, lastonum: u16)
		-> usize;
}
extern "C" {
	#[doc = " @brief   Insert a CoAP option into buffer"]
	#[doc = ""]
	#[doc = " This function writes a CoAP option with nr. @p onum to @p buf."]
	#[doc = " It handles calculating the option delta (from @p lastonum), encoding the"]
	#[doc = " length from @p olen and copying the option data from @p odata."]
	#[doc = ""]
	#[doc = " @param[out]  buf         buffer to write to"]
	#[doc = " @param[in]   lastonum    number of previous option (for delta calculation),"]
	#[doc = "                          or 0 for first option"]
	#[doc = " @param[in]   onum        number of option"]
	#[doc = " @param[in]   odata       ptr to raw option data (or NULL)"]
	#[doc = " @param[in]   olen        length of @p odata (if any)"]
	#[doc = ""]
	#[doc = " @returns     amount of bytes written to @p buf"]
	pub fn coap_put_option(
		buf: *mut u8,
		lastonum: u16,
		onum: u16,
		odata: *const u8,
		olen: usize,
	) -> usize;
}
extern "C" {
	#[doc = " @name    Functions -- Messaging"]
	#[doc = ""]
	#[doc = " Functions to support sending and receiving messages."]
	#[doc = " @brief   Build reply to CoAP block2 request"]
	#[doc = ""]
	#[doc = " This function can be used to create a reply to a CoAP block2 request"]
	#[doc = " packet. In addition to @ref coap_build_reply, this function checks the"]
	#[doc = " block2 option and returns an error message to the client if necessary."]
	#[doc = ""]
	#[doc = " @param[in]   pkt         packet to reply to"]
	#[doc = " @param[in]   code        reply code (e.g., COAP_CODE_204)"]
	#[doc = " @param[out]  rbuf        buffer to write reply to"]
	#[doc = " @param[in]   rlen        size of @p rbuf"]
	#[doc = " @param[in]   payload_len length of payload"]
	#[doc = " @param[in]   slicer      slicer to use"]
	#[doc = ""]
	#[doc = " @returns     size of reply packet on success"]
	#[doc = " @returns     <0 on error"]
	pub fn coap_block2_build_reply(
		pkt: *mut coap_pkt_t,
		code: ::core::ffi::c_uint,
		rbuf: *mut u8,
		rlen: ::core::ffi::c_uint,
		payload_len: ::core::ffi::c_uint,
		slicer: *mut coap_block_slicer_t,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Builds a CoAP header"]
	#[doc = ""]
	#[doc = " Caller *must* ensure @p hdr can hold the header and the full token!"]
	#[doc = ""]
	#[doc = " @param[out]   hdr        hdr to fill"]
	#[doc = " @param[in]    type       CoAP packet type (e.g., COAP_TYPE_CON, ...)"]
	#[doc = " @param[in]    token      token"]
	#[doc = " @param[in]    token_len  length of @p token"]
	#[doc = " @param[in]    code       CoAP code (e.g., COAP_CODE_204, ...)"]
	#[doc = " @param[in]    id         CoAP request id"]
	#[doc = ""]
	#[doc = " @returns      length of resulting header"]
	pub fn coap_build_hdr(
		hdr: *mut coap_hdr_t,
		type_: ::core::ffi::c_uint,
		token: *mut u8,
		token_len: usize,
		code: ::core::ffi::c_uint,
		id: u16,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Build reply to CoAP request"]
	#[doc = ""]
	#[doc = " This function can be used to create a reply to any CoAP request packet.  It"]
	#[doc = " will create the reply packet header based on parameters from the request"]
	#[doc = " (e.g., id, token)."]
	#[doc = ""]
	#[doc = " Passing a non-zero @p payload_len will ensure the payload fits into the"]
	#[doc = " buffer along with the header. For this validation, payload_len must include"]
	#[doc = " any options, the payload marker, as well as the payload proper."]
	#[doc = ""]
	#[doc = " @param[in]   pkt         packet to reply to"]
	#[doc = " @param[in]   code        reply code (e.g., COAP_CODE_204)"]
	#[doc = " @param[out]  rbuf        buffer to write reply to"]
	#[doc = " @param[in]   rlen        size of @p rbuf"]
	#[doc = " @param[in]   payload_len length of payload"]
	#[doc = ""]
	#[doc = " @returns     size of reply packet on success"]
	#[doc = " @returns     <0 on error"]
	#[doc = " @returns     -ENOSPC if @p rbuf too small"]
	pub fn coap_build_reply(
		pkt: *mut coap_pkt_t,
		code: ::core::ffi::c_uint,
		rbuf: *mut u8,
		rlen: ::core::ffi::c_uint,
		payload_len: ::core::ffi::c_uint,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Handle incoming CoAP request"]
	#[doc = ""]
	#[doc = " This function will find the correct handler, call it and write the reply"]
	#[doc = " into @p resp_buf."]
	#[doc = ""]
	#[doc = " @param[in]   pkt             pointer to (parsed) CoAP packet"]
	#[doc = " @param[out]  resp_buf        buffer for response"]
	#[doc = " @param[in]   resp_buf_len    size of response buffer"]
	#[doc = ""]
	#[doc = " @returns     size of reply packet on success"]
	#[doc = " @returns     <0 on error"]
	pub fn coap_handle_req(
		pkt: *mut coap_pkt_t,
		resp_buf: *mut u8,
		resp_buf_len: ::core::ffi::c_uint,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Pass a coap request to a matching handler"]
	#[doc = ""]
	#[doc = " This function will try to find a matching handler in @p resources and call"]
	#[doc = " the handler."]
	#[doc = ""]
	#[doc = " @param[in]   pkt             pointer to (parsed) CoAP packet"]
	#[doc = " @param[out]  resp_buf        buffer for response"]
	#[doc = " @param[in]   resp_buf_len    size of response buffer"]
	#[doc = " @param[in]   resources       Array of coap endpoint resources"]
	#[doc = " @param[in]   resources_numof length of the coap endpoint resources"]
	#[doc = ""]
	#[doc = " @returns     size of the reply packet on success"]
	#[doc = " @returns     <0 on error"]
	pub fn coap_tree_handler(
		pkt: *mut coap_pkt_t,
		resp_buf: *mut u8,
		resp_buf_len: ::core::ffi::c_uint,
		resources: *const coap_resource_t,
		resources_numof: usize,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Parse a CoAP PDU"]
	#[doc = ""]
	#[doc = " This function parses a raw CoAP PDU from @p buf with size @p len and fills"]
	#[doc = " the structure pointed to by @p pkt."]
	#[doc = " @p pkt must point to a preallocated coap_pkt_t structure."]
	#[doc = ""]
	#[doc = " @param[out]  pkt     structure to parse into"]
	#[doc = " @param[in]   buf     pointer to raw packet data"]
	#[doc = " @param[in]   len     length of packet at @p buf"]
	#[doc = ""]
	#[doc = " @returns     0 on success"]
	#[doc = " @returns     <0 on error"]
	pub fn coap_parse(pkt: *mut coap_pkt_t, buf: *mut u8, len: usize) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Initialize a packet struct, to build a message buffer"]
	#[doc = ""]
	#[doc = " @pre  buf              CoAP header already initialized"]
	#[doc = " @post pkt.flags        all zeroed"]
	#[doc = " @post pkt.payload      points to first byte after header"]
	#[doc = " @post pkt.payload_len  set to maximum space available for options + payload"]
	#[doc = ""]
	#[doc = " @param[out]   pkt        pkt to initialize"]
	#[doc = " @param[in]    buf        buffer to write for pkt, with CoAP header already"]
	#[doc = "                          initialized"]
	#[doc = " @param[in]    len        length of buf"]
	#[doc = " @param[in]    header_len length of header in buf, including token"]
	pub fn coap_pkt_init(pkt: *mut coap_pkt_t, buf: *mut u8, len: usize, header_len: usize);
}
extern "C" {
	#[doc = " @brief   Add payload data to the CoAP request."]
	#[doc = ""]
	#[doc = " @pre     @ref coap_opt_finish must have been called before with"]
	#[doc = "               the @ref COAP_OPT_FINISH_PAYLOAD option."]
	#[doc = ""]
	#[doc = " The function copies @p data into the payload buffer of @p pkt and"]
	#[doc = " advances the payload pointer."]
	#[doc = ""]
	#[doc = " This is just a convenience function, you can also directly write"]
	#[doc = " to `pkt->payload` if you have a function that outputs payload to"]
	#[doc = " a buffer."]
	#[doc = " In this case you should instead call @ref coap_payload_advance_bytes."]
	#[doc = ""]
	#[doc = " @param[out]   pkt        pkt to add payload to"]
	#[doc = " @param[in]    data       payload data"]
	#[doc = " @param[in]    len        length of payload"]
	#[doc = ""]
	#[doc = " @returns      number of payload bytes added on success"]
	#[doc = " @returns      < 0 on error"]
	pub fn coap_payload_put_bytes(
		pkt: *mut coap_pkt_t,
		data: *const ::core::ffi::c_void,
		len: usize,
	) -> isize;
}
extern "C" {
	#[doc = " @brief Add a single character to the payload data of the CoAP request"]
	#[doc = ""]
	#[doc = " This function is used to add single characters to a CoAP payload data. It"]
	#[doc = " checks whether the character can be added to the buffer and ignores if the"]
	#[doc = " payload area is already exhausted."]
	#[doc = ""]
	#[doc = " @param[out]   pkt        pkt to add payload to"]
	#[doc = " @param[in]    c          character to write"]
	#[doc = ""]
	#[doc = " @returns      number of payload bytes added on success (always one)"]
	#[doc = " @returns      < 0 on error"]
	pub fn coap_payload_put_char(pkt: *mut coap_pkt_t, c: ::core::ffi::c_char) -> isize;
}
extern "C" {
	#[doc = " @brief   Create CoAP reply (convenience function)"]
	#[doc = ""]
	#[doc = " This is a simple wrapper that allows for building CoAP replies for simple"]
	#[doc = " use-cases."]
	#[doc = ""]
	#[doc = " The reply will be written to @p buf. If @p payload and @p payload_len are"]
	#[doc = " non-zero, the payload will be copied into the resulting reply packet."]
	#[doc = ""]
	#[doc = " @param[in]   pkt         packet to reply to"]
	#[doc = " @param[in]   code        reply code (e.g., COAP_CODE_204)"]
	#[doc = " @param[out]  buf         buffer to write reply to"]
	#[doc = " @param[in]   len         size of @p buf"]
	#[doc = " @param[in]   ct          content type of payload"]
	#[doc = " @param[in]   payload     ptr to payload"]
	#[doc = " @param[in]   payload_len length of payload"]
	#[doc = ""]
	#[doc = " @returns     size of reply packet on success"]
	#[doc = " @returns     <0 on error"]
	#[doc = " @returns     -ENOSPC if @p buf too small"]
	pub fn coap_reply_simple(
		pkt: *mut coap_pkt_t,
		code: ::core::ffi::c_uint,
		buf: *mut u8,
		len: usize,
		ct: ::core::ffi::c_uint,
		payload: *const u8,
		payload_len: u8,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Reference to the default .well-known/core handler defined by the"]
	#[doc = "          application"]
	pub fn coap_well_known_core_default_handler(
		pkt: *mut coap_pkt_t,
		buf: *mut u8,
		len: usize,
		context: *mut ::core::ffi::c_void,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Checks if a CoAP resource path matches a given URI"]
	#[doc = ""]
	#[doc = " Builds on strcmp() with rules specific to URI path matching"]
	#[doc = ""]
	#[doc = " @note This function is not intended for application use."]
	#[doc = " @internal"]
	#[doc = ""]
	#[doc = " @param[in] resource CoAP resource to check"]
	#[doc = " @param[in] uri Null-terminated string URI to compare"]
	#[doc = ""]
	#[doc = " @return 0  if the resource path matches the URI"]
	#[doc = " @return <0 if the resource path sorts before the URI"]
	#[doc = " @return >0 if the resource path sorts after the URI"]
	pub fn coap_match_path(resource: *const coap_resource_t, uri: *mut u8) -> ::core::ffi::c_int;
}
#[doc = " @brief A timex timestamp"]
#[doc = ""]
#[doc = " @note  If a timestamp is not normalized, the number of microseconds might be"]
#[doc = "        > 1000000"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timex_t {
	#[doc = "< number of seconds"]
	pub seconds: u32,
	#[doc = "< number of microseconds"]
	pub microseconds: u32,
}
extern "C" {
	#[doc = " @brief Adds two timestamps"]
	#[doc = ""]
	#[doc = " @param[in] a     First summand"]
	#[doc = " @param[in] b     Second summand"]
	#[doc = ""]
	#[doc = " @return The sum of the two timestamps"]
	pub fn timex_add(a: timex_t, b: timex_t) -> timex_t;
}
extern "C" {
	#[doc = " @brief Subtracts two timestamps"]
	#[doc = ""]
	#[doc = " @param[in] a     The minuend"]
	#[doc = " @param[in] b     The subtrahend"]
	#[doc = ""]
	#[doc = " @return The difference a - b"]
	pub fn timex_sub(a: timex_t, b: timex_t) -> timex_t;
}
extern "C" {
	#[doc = " @brief Initializes a timex timestamp"]
	#[doc = ""]
	#[doc = " @param[in] seconds       Number of seconds to set"]
	#[doc = " @param[in] microseconds  Number of microseconds to set"]
	#[doc = ""]
	#[doc = " @return The initialized timex timestamp"]
	pub fn timex_set(seconds: u32, microseconds: u32) -> timex_t;
}
extern "C" {
	#[doc = " @brief Compares two timex timestamps"]
	#[doc = ""]
	#[doc = " @param[in] a The first timestamp to compare to"]
	#[doc = " @param[in] b The second timestamp to compare with"]
	#[doc = ""]
	#[doc = " @return -1 when a is smaller"]
	#[doc = " @return 0 if equal"]
	#[doc = " @return 1 if a is bigger"]
	pub fn timex_cmp(a: timex_t, b: timex_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief Converts a timex timestamp to a string"]
	#[doc = ""]
	#[doc = " @pre memory at timestamp >= TIMEX_MAX_STR_LEN"]
	#[doc = ""]
	#[doc = " @param[in]  t            The timestamp to convert"]
	#[doc = " @param[out] timestamp    The output char buffer for the converted timestamp"]
	#[doc = ""]
	#[doc = " @note The timestamp will be normalized"]
	#[doc = ""]
	#[doc = " @return A pointer to the string representation of the timestamp"]
	pub fn timex_to_str(
		t: timex_t,
		timestamp: *mut ::core::ffi::c_char,
	) -> *const ::core::ffi::c_char;
}
#[doc = " @brief   Context information required to write a resource link"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct coap_link_encoder_ctx_t {
	#[doc = "< link format"]
	pub content_format: ::core::ffi::c_uint,
	#[doc = "< position of link within listener"]
	pub link_pos: usize,
	#[doc = "< encoder switches; see @ref"]
	#[doc = "COAP_LINK_FLAG_ constants"]
	pub flags: u16,
}
#[doc = " @brief   Handler function to write a resource link"]
#[doc = ""]
#[doc = " @param[in] resource      Resource for link"]
#[doc = " @param[out] buf          Buffer on which to write; may be null"]
#[doc = " @param[in] maxlen        Remaining length for @p buf"]
#[doc = " @param[in] context       Contextual information on what/how to write"]
#[doc = ""]
#[doc = " @return  count of bytes written to @p buf (or writable if @p buf is null)"]
#[doc = " @return  -1 on error"]
pub type gcoap_link_encoder_t = ::core::option::Option<
	unsafe extern "C" fn(
		resource: *const coap_resource_t,
		buf: *mut ::core::ffi::c_char,
		maxlen: usize,
		context: *mut coap_link_encoder_ctx_t,
	) -> isize,
>;
#[doc = " @brief   A modular collection of resources for a server"]
pub type gcoap_listener_t = gcoap_listener;
#[doc = " @brief   Handler function for the request matcher strategy"]
#[doc = ""]
#[doc = " @param[in]  listener     Listener context"]
#[doc = " @param[out] resource     Matching resource"]
#[doc = " @param[in]  pdu          Pointer to the PDU"]
#[doc = ""]
#[doc = " @return  GCOAP_RESOURCE_FOUND      on resource match"]
#[doc = " @return  GCOAP_RESOURCE_NO_PATH    on no path found in @p resource"]
#[doc = "                                    that matches @p pdu"]
#[doc = " @return  GCOAP_RESOURCE_ERROR      on processing failure of the request"]
pub type gcoap_request_matcher_t = ::core::option::Option<
	unsafe extern "C" fn(
		listener: *mut gcoap_listener_t,
		resource: *mut *const coap_resource_t,
		pdu: *mut coap_pkt_t,
	) -> ::core::ffi::c_int,
>;
#[doc = "< undefined"]
pub const gcoap_socket_type_t_GCOAP_SOCKET_TYPE_UNDEF: gcoap_socket_type_t = 0;
#[doc = "< Unencrypted UDP transport"]
pub const gcoap_socket_type_t_GCOAP_SOCKET_TYPE_UDP: gcoap_socket_type_t = 1;
#[doc = "< DTLS-over-UDP transport"]
pub const gcoap_socket_type_t_GCOAP_SOCKET_TYPE_DTLS: gcoap_socket_type_t = 2;
#[doc = " @brief   CoAP socket types"]
#[doc = ""]
#[doc = " May be used as flags for @ref gcoap_listener_t, but must be used numerically"]
#[doc = " with @ref gcoap_req_send_tl()."]
pub type gcoap_socket_type_t = ::core::ffi::c_uint;
#[doc = " @brief   CoAP socket to handle multiple transport types"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gcoap_socket_t {
	#[doc = "< Type of stored socket"]
	pub type_: gcoap_socket_type_t,
	#[doc = "< Stored socket"]
	pub socket: gcoap_socket_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gcoap_socket_t__bindgen_ty_1 {
	pub udp: *mut sock_udp_t,
}
#[doc = " @brief   A modular collection of resources for a server"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gcoap_listener {
	#[doc = "< First element in the array of"]
	#[doc = "   resources; must order alphabetically"]
	pub resources: *const coap_resource_t,
	#[doc = "< Length of array"]
	pub resources_len: usize,
	#[doc = " @brief   Transport type for the listener"]
	#[doc = ""]
	#[doc = " Any transport supported by the implementation can be set as a flag."]
	#[doc = " If @ref GCOAP_SOCKET_TYPE_UNDEF is set, the listener listens on all"]
	#[doc = " supported transports. If non of the transports beyond UDP are compiled in"]
	#[doc = " (i.e. no usage of modules `gcoap_dtls`, ...) this will be ignored and"]
	#[doc = " @ref GCOAP_SOCKET_TYPE_UDP assumed."]
	pub tl_type: gcoap_socket_type_t,
	#[doc = "< Writes a link for a resource"]
	pub link_encoder: gcoap_link_encoder_t,
	#[doc = "< Next listener in list"]
	pub next: *mut gcoap_listener,
	#[doc = " @brief  Function that picks a suitable request handler from a"]
	#[doc = " request."]
	#[doc = ""]
	#[doc = " @note Leaving this NULL selects the default strategy that picks"]
	#[doc = " handlers by matching their Uri-Path to resource paths (as per"]
	#[doc = " the documentation of the @ref resources and @ref resources_len"]
	#[doc = " fields). Alternative handlers may cast the @ref resources and"]
	#[doc = " @ref resources_len fields to fit their needs."]
	pub request_matcher: gcoap_request_matcher_t,
}
#[doc = " @brief   Memo to handle a response for a request"]
pub type gcoap_request_memo_t = gcoap_request_memo;
#[doc = " @brief   Handler function for a server response, including the state for the"]
#[doc = "          originating request"]
#[doc = ""]
#[doc = " If request timed out, the packet header is for the request."]
pub type gcoap_resp_handler_t = ::core::option::Option<
	unsafe extern "C" fn(
		memo: *const gcoap_request_memo_t,
		pdu: *mut coap_pkt_t,
		remote: *const sock_udp_ep_t,
	),
>;
#[doc = " @brief  Extends request memo for resending a confirmable request."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gcoap_resend_t {
	#[doc = "< Buffer containing the PDU"]
	pub pdu_buf: *mut u8,
	#[doc = "< Length of pdu_buf"]
	pub pdu_len: usize,
}
#[doc = " @brief   Memo to handle a response for a request"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gcoap_request_memo {
	#[doc = "< State of this memo, a GCOAP_MEMO..."]
	pub state: ::core::ffi::c_uint,
	#[doc = "< Remaining resends, 0 if none;"]
	#[doc = "GCOAP_SEND_LIMIT_NON if non-confirmable"]
	pub send_limit: ::core::ffi::c_int,
	#[doc = "< Request message data; if confirmable,"]
	#[doc = "supports resending message"]
	pub msg: gcoap_request_memo__bindgen_ty_1,
	#[doc = "< Remote endpoint"]
	pub remote_ep: sock_udp_ep_t,
	#[doc = "< Callback for the response"]
	pub resp_handler: gcoap_resp_handler_t,
	#[doc = "< ptr to user defined context data"]
	pub context: *mut ::core::ffi::c_void,
	#[doc = "< Limits wait for response"]
	pub resp_evt_tmout: event_timeout_t,
	#[doc = "< Callback for response timeout"]
	pub resp_tmout_cb: event_callback_t,
	#[doc = "< Transport type to remote endpoint"]
	pub socket: gcoap_socket_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gcoap_request_memo__bindgen_ty_1 {
	pub hdr_buf: [u8; 12usize],
	#[doc = "< Endpoint and PDU buffer, for resend"]
	pub data: gcoap_resend_t,
}
#[doc = " @brief   Memo for Observe registration and notifications"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gcoap_observe_memo_t {
	#[doc = "< Client endpoint; unused if null"]
	pub observer: *mut sock_udp_ep_t,
	#[doc = "< Entity being observed"]
	pub resource: *const coap_resource_t,
	#[doc = "< Client token for notifications"]
	pub token: [u8; 8usize],
	#[doc = "< Actual length of token attribute"]
	pub token_len: ::core::ffi::c_uint,
	#[doc = "< Transport type to observer"]
	pub socket: gcoap_socket_t,
}
extern "C" {
	#[doc = " @brief   Initializes the gcoap thread and device"]
	#[doc = ""]
	#[doc = " Must call once before first use."]
	#[doc = ""]
	#[doc = " @return  PID of the gcoap thread on success."]
	#[doc = " @return  -EEXIST, if thread already has been created."]
	#[doc = " @return  -EINVAL, if the IP port already is in use."]
	pub fn gcoap_init() -> kernel_pid_t;
}
extern "C" {
	#[doc = " @brief   Starts listening for resource paths"]
	#[doc = ""]
	#[doc = " @pre @p listener is a valid pointer to a single listener (that is,"]
	#[doc = "      `listener->next == NULL`)"]
	#[doc = ""]
	#[doc = " @note If you are tempted to register a pre-linked chain of listeners,"]
	#[doc = "       consider placing all their resources in the resources array of a"]
	#[doc = "       single listener instead. In the few cases where this does not work"]
	#[doc = "       (that is, when the resources need a different `link_encoder` or other"]
	#[doc = "       fields of the listener struct), they can just be registered"]
	#[doc = "       individually."]
	#[doc = ""]
	#[doc = " @param[in] listener  Listener containing the resources."]
	pub fn gcoap_register_listener(listener: *mut gcoap_listener_t);
}
extern "C" {
	#[doc = " @brief   Initializes a CoAP request PDU on a buffer."]
	#[doc = ""]
	#[doc = " If @p code is COAP_CODE_EMPTY, prepares a complete \"CoAP ping\" 4 byte empty"]
	#[doc = " message request, ready to send."]
	#[doc = ""]
	#[doc = " @param[out] pdu      Request metadata"]
	#[doc = " @param[out] buf      Buffer containing the PDU"]
	#[doc = " @param[in] len       Length of the buffer"]
	#[doc = " @param[in] code      Request code, one of COAP_METHOD_XXX or COAP_CODE_EMPTY"]
	#[doc = "                      to ping"]
	#[doc = " @param[in] path      Resource path, may be NULL. @p path_len will be ignored"]
	#[doc = "                      in that case."]
	#[doc = " @param[in] path_len  Length of @p path."]
	#[doc = ""]
	#[doc = " @pre @p path must start with `/` if not NULL"]
	#[doc = ""]
	#[doc = " @return  0 on success"]
	#[doc = " @return  < 0 on error"]
	pub fn gcoap_req_init_path_buffer(
		pdu: *mut coap_pkt_t,
		buf: *mut u8,
		len: usize,
		code: ::core::ffi::c_uint,
		path: *const ::core::ffi::c_char,
		path_len: usize,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Sends a buffer containing a CoAP request to the provided endpoint"]
	#[doc = ""]
	#[doc = " @deprecated Will be an alias for @ref gcoap_req_send after the 2022.01"]
	#[doc = "             release. Will be removed after the 2022.04 release."]
	#[doc = ""]
	#[doc = " @param[in] buf           Buffer containing the PDU"]
	#[doc = " @param[in] len           Length of the buffer"]
	#[doc = " @param[in] remote        Destination for the packet"]
	#[doc = " @param[in] resp_handler  Callback when response received, may be NULL"]
	#[doc = " @param[in] context       User defined context passed to the response handler"]
	#[doc = " @param[in] tl_type       The transport type to use for send. When"]
	#[doc = "                          @ref GCOAP_SOCKET_TYPE_UNDEF is selected, the highest"]
	#[doc = "                          available (by value) will be selected. Only single"]
	#[doc = "                          types are allowed, not a combination of them."]
	#[doc = ""]
	#[doc = " @return  length of the packet"]
	#[doc = " @return -ENOTCONN, if DTLS was used and session establishment failed"]
	#[doc = " @return -EINVAL, if @p tl_type is is not supported"]
	#[doc = " @return  0 if cannot send"]
	pub fn gcoap_req_send_tl(
		buf: *const u8,
		len: usize,
		remote: *const sock_udp_ep_t,
		resp_handler: gcoap_resp_handler_t,
		context: *mut ::core::ffi::c_void,
		tl_type: gcoap_socket_type_t,
	) -> isize;
}
extern "C" {
	#[doc = " @brief   Initializes a CoAP response packet on a buffer"]
	#[doc = ""]
	#[doc = " Initializes payload location within the buffer based on packet setup."]
	#[doc = ""]
	#[doc = " @param[out] pdu      Response metadata"]
	#[doc = " @param[in] buf       Buffer containing the PDU"]
	#[doc = " @param[in] len       Length of the buffer"]
	#[doc = " @param[in] code      Response code"]
	#[doc = ""]
	#[doc = " @return  0 on success"]
	#[doc = " @return  < 0 on error"]
	pub fn gcoap_resp_init(
		pdu: *mut coap_pkt_t,
		buf: *mut u8,
		len: usize,
		code: ::core::ffi::c_uint,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Initializes a CoAP Observe notification packet on a buffer, for the"]
	#[doc = "          observer registered for a resource"]
	#[doc = ""]
	#[doc = " First verifies that an observer has been registered for the resource."]
	#[doc = ""]
	#[doc = " @param[out] pdu      Notification metadata"]
	#[doc = " @param[out] buf      Buffer containing the PDU"]
	#[doc = " @param[in] len       Length of the buffer"]
	#[doc = " @param[in] resource  Resource for the notification"]
	#[doc = ""]
	#[doc = " @return  GCOAP_OBS_INIT_OK     on success"]
	#[doc = " @return  GCOAP_OBS_INIT_ERR    on error"]
	#[doc = " @return  GCOAP_OBS_INIT_UNUSED if no observer for resource"]
	pub fn gcoap_obs_init(
		pdu: *mut coap_pkt_t,
		buf: *mut u8,
		len: usize,
		resource: *const coap_resource_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Sends a buffer containing a CoAP Observe notification to the"]
	#[doc = "          observer registered for a resource"]
	#[doc = ""]
	#[doc = " Assumes a single observer for a resource."]
	#[doc = ""]
	#[doc = " @param[in] buf Buffer containing the PDU"]
	#[doc = " @param[in] len Length of the buffer"]
	#[doc = " @param[in] resource Resource to send"]
	#[doc = ""]
	#[doc = " @return  length of the packet"]
	#[doc = " @return  0 if cannot send"]
	pub fn gcoap_obs_send(buf: *const u8, len: usize, resource: *const coap_resource_t) -> usize;
}
extern "C" {
	#[doc = " @brief   Provides important operational statistics"]
	#[doc = ""]
	#[doc = " Useful for monitoring."]
	#[doc = ""]
	#[doc = " @return  count of unanswered requests"]
	pub fn gcoap_op_state() -> u8;
}
extern "C" {
	#[doc = " @brief   Get the resource list, currently only `CoRE Link Format`"]
	#[doc = "          (COAP_FORMAT_LINK) supported"]
	#[doc = ""]
	#[doc = " @deprecated Will be an alias for @ref gcoap_get_resource_list after the"]
	#[doc = "             2022.01 release. Will be removed after the 2022.04 release."]
	#[doc = ""]
	#[doc = " If @p buf := NULL, nothing will be written but the size of the resulting"]
	#[doc = " resource list is computed and returned."]
	#[doc = ""]
	#[doc = " @param[out] buf      output buffer to write resource list into, my be NULL"]
	#[doc = " @param[in]  maxlen   length of @p buf, ignored if @p buf is NULL"]
	#[doc = " @param[in]  cf       content format to use for the resource list, currently"]
	#[doc = "                      only COAP_FORMAT_LINK supported"]
	#[doc = " @param[in]  tl_type  Transport type to get the list for."]
	#[doc = "                      @ref GCOAP_SOCKET_TYPE_UNDEF for all transport types."]
	#[doc = "                      If non of the transports beyond UDP are compiled in"]
	#[doc = "                      (i.e. usage of modules no `gcoap_dtls`, ...) this will"]
	#[doc = "                      be ignored and @ref GCOAP_SOCKET_TYPE_UDP assumed."]
	#[doc = ""]
	#[doc = " @todo    add support for `JSON CoRE Link Format`"]
	#[doc = " @todo    add support for 'CBOR CoRE Link Format`"]
	#[doc = ""]
	#[doc = " @return  the number of bytes written to @p buf"]
	#[doc = " @return  -1 on error"]
	pub fn gcoap_get_resource_list_tl(
		buf: *mut ::core::ffi::c_void,
		maxlen: usize,
		cf: u8,
		tl_type: gcoap_socket_type_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Writes a resource in CoRE Link Format to a provided buffer."]
	#[doc = ""]
	#[doc = " This default implementation only writes the resource path."]
	#[doc = ""]
	#[doc = " @param[in]  resource  resource to write"]
	#[doc = " @param[out] buf       output buffer to write link into, may be null"]
	#[doc = " @param[in]  maxlen    length of @p buf, ignored if @p buf is NULL"]
	#[doc = " @param[in]  context   other parameters that affect how link is written"]
	#[doc = ""]
	#[doc = " @return  count of bytes written to @p buf (or writable if @p buf is null)"]
	#[doc = " @return  -1 on error"]
	pub fn gcoap_encode_link(
		resource: *const coap_resource_t,
		buf: *mut ::core::ffi::c_char,
		maxlen: usize,
		context: *mut coap_link_encoder_ctx_t,
	) -> isize;
}
#[doc = " @brief   COAP Context for handler functions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_coap_context {
	#[doc = "< COAP packet."]
	pub pdu: *mut coap_pkt_t,
	#[doc = "< Buffer bytes gets written into"]
	pub buf: *mut u8,
	#[doc = "< Length of the buffer"]
	pub len: usize,
	#[doc = "< Handler context"]
	pub ctx: *mut ::core::ffi::c_void,
}
#[doc = " @brief   COAP Context for handler functions"]
pub type wot_td_coap_context_t = wot_td_coap_context;
#[doc = " @brief   Compound struct to keep state of CoAP property affordances."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_coap_prop_affordance {
	#[doc = "< Key of the property in the TD"]
	pub key: *const ::core::ffi::c_char,
	#[doc = "< if endpoint is enabled"]
	pub is_enabled: bool,
	#[doc = "< Corresponding CoAP handler"]
	pub coap_handler: coap_handler_t,
	#[doc = "< Property affordance"]
	pub prop_affordance: *mut wot_td_prop_affordance_t,
}
#[doc = " @brief   Compound struct to keep state of CoAP property affordances."]
pub type wot_td_coap_prop_affordance_t = wot_td_coap_prop_affordance;
#[doc = " @brief   Compound struct to keep state of CoAP action affordances."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_coap_action_affordance {
	#[doc = "< key id used in the TD"]
	pub key: *const ::core::ffi::c_char,
	#[doc = "< if endpoint is enabled"]
	pub is_enabled: bool,
	#[doc = "< Corresponding COAP handler"]
	pub coap_handler: coap_handler_t,
	#[doc = "< Action affordance"]
	pub action_affordance: *mut wot_td_action_affordance_t,
}
#[doc = " @brief   Compound struct to keep state of CoAP action affordances."]
pub type wot_td_coap_action_affordance_t = wot_td_coap_action_affordance;
#[doc = " @brief   Compound struct to keep state of CoAP event affordances."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_coap_event_affordance {
	#[doc = "< key id used in the TD"]
	pub key: *const ::core::ffi::c_char,
	#[doc = "< if endpoint is enabled"]
	pub is_enabled: bool,
	#[doc = "< Corresponding CoAP handler"]
	pub coap_handler: coap_handler_t,
	#[doc = "< Event affordance"]
	pub event_affordance: *mut wot_td_event_affordance_t,
}
#[doc = " @brief   Compound struct to keep state of CoAP event affordances."]
pub type wot_td_coap_event_affordance_t = wot_td_coap_event_affordance;
#[doc = " @brief   Contains all CoAP property affordances."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_coap_prop_resources {
	#[doc = "< Property affordances"]
	pub coap_affordances: *mut wot_td_coap_prop_affordance_t,
	#[doc = "< Length of the affordances"]
	pub len: usize,
}
#[doc = " @brief   Contains all CoAP property affordances."]
pub type wot_td_coap_prop_resources_t = wot_td_coap_prop_resources;
#[doc = " @brief   Contains all CoAP action affordances."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_coap_action_resources {
	#[doc = "< Action affordances"]
	pub coap_affordances: *mut wot_td_coap_action_affordance_t,
	#[doc = "< Length of the affordances"]
	pub len: usize,
}
#[doc = " @brief   Contains all CoAP action affordances."]
pub type wot_td_coap_action_resources_t = wot_td_coap_action_resources;
#[doc = " @brief   Contains all CoAP event affordances."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_coap_event_resources {
	#[doc = "< Event affordances"]
	pub coap_affordances: *mut wot_td_coap_event_affordance_t,
	#[doc = "< Length of the affordances"]
	pub len: usize,
}
#[doc = " @brief   Contains all CoAP event affordances."]
pub type wot_td_coap_event_resources_t = wot_td_coap_event_resources;
extern "C" {
	pub fn wot_td_coap_handle_prop(
		key: *const ::core::ffi::c_char,
		context: *mut wot_td_coap_context_t,
	) -> isize;
}
extern "C" {
	pub fn wot_td_coap_handle_action(
		key: *const ::core::ffi::c_char,
		context: *mut wot_td_coap_context_t,
	) -> isize;
}
extern "C" {
	pub fn wot_td_coap_handle_event(
		key: *const ::core::ffi::c_char,
		context: *mut wot_td_coap_context_t,
	) -> isize;
}
extern "C" {
	pub fn wot_td_coap_add_prop_resources(coap_resource: *const wot_td_coap_prop_resources_t);
}
extern "C" {
	pub fn wot_td_coap_add_action_resources(coap_resource: *const wot_td_coap_action_resources_t);
}
extern "C" {
	pub fn wot_td_coap_add_event_resources(coap_resource: *const wot_td_coap_event_resources_t);
}
extern "C" {
	pub fn wot_td_coap_prop_disable(key: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_action_disable(key: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_event_disable(key: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_prop_enable(key: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_action_enable(key: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_event_enable(key: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_prop_toggle(key: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_action_toggle(key: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_event_toggle(key: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_prop_affordance_disable(
		affordance: *mut wot_td_coap_prop_affordance_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_action_affordance_disable(
		affordance: *mut wot_td_coap_action_affordance_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_event_affordance_disable(
		affordance: *mut wot_td_coap_event_affordance_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_prop_affordance_enable(
		affordance: *mut wot_td_coap_prop_affordance_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_action_affordance_enable(
		affordance: *mut wot_td_coap_action_affordance_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_event_affordance_enable(
		affordance: *mut wot_td_coap_event_affordance_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_prop_affordance_toggle(
		affordance: *mut wot_td_coap_prop_affordance_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_action_affordance_toggle(
		affordance: *mut wot_td_coap_action_affordance_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_event_affordance_toggle(
		affordance: *mut wot_td_coap_event_affordance_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	pub fn wot_td_coap_find_prop(
		key: *const ::core::ffi::c_char,
	) -> *mut wot_td_coap_prop_affordance_t;
}
extern "C" {
	pub fn wot_td_coap_find_action(
		key: *const ::core::ffi::c_char,
	) -> *mut wot_td_coap_action_affordance_t;
}
extern "C" {
	pub fn wot_td_coap_find_event(
		key: *const ::core::ffi::c_char,
	) -> *mut wot_td_coap_event_affordance_t;
}
extern "C" {
	#[doc = " @brief   Initializes the CoAP server used for exposing the TD."]
	pub fn wot_td_coap_server_init();
}
extern "C" {
	#[doc = " @brief   Initializes CoAP functionality for the Thing Description."]
	#[doc = ""]
	#[doc = " @param[in] thing The Thing Description base struct."]
	#[doc = ""]
	#[doc = " @return 0 if initialization was successful, a non-zero value otherwise."]
	pub fn wot_td_coap_config_init(thing: *mut wot_td_thing_t) -> ::core::ffi::c_int;
}
#[doc = " @brief   Slicer object used for block-wise serialization."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_ser_slicer_t {
	#[doc = "< Start index of the serialization"]
	pub start: u16,
	#[doc = "< End index of the serialization"]
	pub end: u16,
	#[doc = "< Current serialization index"]
	pub cur: u16,
}
extern "C" {
	#[doc = " @brief   Serializes a WoT Thing."]
	#[doc = ""]
	#[doc = " @param[out] receiver The receiver the serialized Thing is written to."]
	#[doc = " @param[out] thing The WoT Thing that is supposed to be serialized."]
	#[doc = " @param[out] slicer The slicer used for segmenting the payload."]
	#[doc = ""]
	#[doc = " @return 0 if serialization was successful, a non-zero value otherwise."]
	pub fn wot_td_serialize_thing(
		receiver: wot_td_serialize_receiver_t,
		thing: *mut wot_td_thing_t,
		slicer: *mut wot_td_ser_slicer_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Serializes the security schema of a WoT Thing Thing Description."]
	#[doc = ""]
	#[doc = " @param[out] receiver The receiver the serialized Thing is written to."]
	#[doc = " @param[in] thing The WoT Thing that is supposed to be serialized."]
	#[doc = " @param[in] slicer The slicer used for segmenting the payload."]
	pub fn _write_security_schema(
		receiver: wot_td_serialize_receiver_t,
		security: *mut wot_td_sec_scheme_t,
		slicer: *mut wot_td_ser_slicer_t,
	);
}
extern "C" {
	#[doc = " @brief   Serializes the name of a security scheme."]
	#[doc = ""]
	#[doc = " @param[out] receiver The receiver the serialized security scheme is written to."]
	#[doc = " @param[in] scheme_type The type of the security scheme."]
	#[doc = " @param[in] slicer The slicer used for segmenting the payload."]
	pub fn _security_scheme_string(
		receiver: wot_td_serialize_receiver_t,
		scheme_type: wot_td_sec_scheme_type_t,
		slicer: *mut wot_td_ser_slicer_t,
	);
}
extern "C" {
	#[doc = " @brief   Serializes both description and descriptions fields with regard to the default language."]
	#[doc = ""]
	#[doc = " @param[out] receiver The receiver the serialized description(s) are written to."]
	#[doc = " @param[in] desc The first element of a linked list of descriptions."]
	#[doc = " @param[in] lang The currently used default language."]
	#[doc = " @param[in] slicer The slicer used for segmenting the payload."]
	pub fn _write_description_list(
		receiver: wot_td_serialize_receiver_t,
		desc: *mut wot_td_multi_lang_t,
		lang: *mut ::core::ffi::c_char,
		slicer: *mut wot_td_ser_slicer_t,
	);
}
extern "C" {
	#[doc = " @brief   Converts an integer to its string representation."]
	#[doc = ""]
	#[doc = " @param[in] n The number that is supposed to be converted."]
	#[doc = " @param[out] s The output char array."]
	pub fn _itoa(n: ::core::ffi::c_int, s: *mut ::core::ffi::c_char);
}
extern "C" {
	#[doc = " @brief   Reverses a string."]
	#[doc = ""]
	#[doc = " @param s The string as an array of characters."]
	pub fn _reverse(s: *mut ::core::ffi::c_char);
}
extern "C" {
	#[doc = " @brief   Serializes a string of characters."]
	#[doc = ""]
	#[doc = " @param[out] receiver The receiver the characters are written to."]
	#[doc = " @param[in] string The input string."]
	#[doc = " @param[in] length The length of the input string."]
	#[doc = " @param[in] slicer The slicer used for slicing the payload."]
	pub fn _wot_io_send(
		receiver: wot_td_serialize_receiver_t,
		string: *const ::core::ffi::c_char,
		length: u32,
		slicer: *mut wot_td_ser_slicer_t,
	) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Formats a character array as a JSON string and serializes them."]
	#[doc = ""]
	#[doc = " @param[out] receiver The receiver the characters are written to."]
	#[doc = " @param[in] string The input string."]
	#[doc = " @param[in] length The length of the input string."]
	#[doc = " @param[in] slicer The slicer used for slicing the payload."]
	pub fn _wot_io_send_string(
		receiver: wot_td_serialize_receiver_t,
		string: *const ::core::ffi::c_char,
		length: u32,
		slicer: *mut wot_td_ser_slicer_t,
	);
}
extern "C" {
	#[doc = " @brief   Formats a URI as a JSON string and serializes it."]
	#[doc = ""]
	#[doc = " @param[out] receiver The receiver the characters are written to."]
	#[doc = " @param[in] uri The input URI struct."]
	#[doc = " @param[in] slicer The slicer used for slicing the payload."]
	pub fn _wot_io_send_uri(
		receiver: wot_td_serialize_receiver_t,
		uri: *mut wot_td_uri_t,
		slicer: *mut wot_td_ser_slicer_t,
	);
}
extern "C" {
	#[doc = " @brief   Formats a data as a JSON string and serializes it."]
	#[doc = ""]
	#[doc = " @param[out] receiver The receiver the characters are written to."]
	#[doc = " @param[in] date The input date struct."]
	#[doc = " @param[in] slicer The slicer used for slicing the payload."]
	pub fn _wot_io_send_date(
		receiver: wot_td_serialize_receiver_t,
		date: *mut wot_td_date_time_t,
		slicer: *mut wot_td_ser_slicer_t,
	);
}
extern "C" {
	#[doc = " @brief   Formats the key of a JSON object data as a JSON string and serializes it."]
	#[doc = ""]
	#[doc = " @param[out] receiver The receiver the characters are written to."]
	#[doc = " @param[in] date The input date struct."]
	#[doc = " @param[in] slicer The slicer used for slicing the payload."]
	pub fn _wot_io_send_obj_key(
		receiver: wot_td_serialize_receiver_t,
		string: *const ::core::ffi::c_char,
		length: u32,
		slicer: *mut wot_td_ser_slicer_t,
	);
}
extern "C" {
	#[doc = " @brief   Serializes a boolean."]
	#[doc = ""]
	#[doc = " @param[out] receiver The receiver the characters are written to."]
	#[doc = " @param[in] value The input boolean value."]
	#[doc = " @param[in] slicer The slicer used for slicing the payload."]
	pub fn _wot_io_send_bool(
		receiver: wot_td_serialize_receiver_t,
		value: bool,
		slicer: *mut wot_td_ser_slicer_t,
	);
}
extern "C" {
	pub static _json_key_at_context: [::core::ffi::c_char; 9usize];
}
extern "C" {
	pub static _wot_td_url: [::core::ffi::c_char; 34usize];
}
extern "C" {
	pub static _obj_key_at_type: [::core::ffi::c_char; 6usize];
}
extern "C" {
	pub static _json_key_titles: [::core::ffi::c_char; 7usize];
}
extern "C" {
	pub static _json_key_descriptions: [::core::ffi::c_char; 13usize];
}
extern "C" {
	pub static _json_key_in: [::core::ffi::c_char; 3usize];
}
extern "C" {
	pub static _json_key_name: [::core::ffi::c_char; 5usize];
}
extern "C" {
	pub static _json_key_qop: [::core::ffi::c_char; 4usize];
}
extern "C" {
	pub static _json_key_id: [::core::ffi::c_char; 3usize];
}
extern "C" {
	pub static _json_key_sec_def: [::core::ffi::c_char; 20usize];
}
extern "C" {
	pub static _json_key_op: [::core::ffi::c_char; 3usize];
}
extern "C" {
	pub static _json_key_href: [::core::ffi::c_char; 5usize];
}
extern "C" {
	pub static _json_key_content_type: [::core::ffi::c_char; 12usize];
}
extern "C" {
	pub static _json_key_content_coding: [::core::ffi::c_char; 14usize];
}
extern "C" {
	pub static _json_key_subprotocol: [::core::ffi::c_char; 12usize];
}
extern "C" {
	pub static _json_key_scopes: [::core::ffi::c_char; 7usize];
}
extern "C" {
	pub static _json_key_observable: [::core::ffi::c_char; 11usize];
}
extern "C" {
	pub static _json_key_required: [::core::ffi::c_char; 9usize];
}
extern "C" {
	pub static _json_key_items: [::core::ffi::c_char; 6usize];
}
extern "C" {
	pub static _json_key_min_items: [::core::ffi::c_char; 9usize];
}
extern "C" {
	pub static _json_key_max_items: [::core::ffi::c_char; 9usize];
}
extern "C" {
	pub static _json_key_minimum: [::core::ffi::c_char; 8usize];
}
extern "C" {
	pub static _json_key_maximum: [::core::ffi::c_char; 8usize];
}
extern "C" {
	pub static _json_key_const: [::core::ffi::c_char; 6usize];
}
extern "C" {
	pub static _json_key_unit: [::core::ffi::c_char; 5usize];
}
extern "C" {
	pub static _json_key_one_of: [::core::ffi::c_char; 6usize];
}
extern "C" {
	pub static _json_key_enum: [::core::ffi::c_char; 5usize];
}
extern "C" {
	pub static _json_key_read_only: [::core::ffi::c_char; 9usize];
}
extern "C" {
	pub static _json_key_write_only: [::core::ffi::c_char; 10usize];
}
extern "C" {
	pub static _json_key_format: [::core::ffi::c_char; 7usize];
}
extern "C" {
	pub static _json_key_actions: [::core::ffi::c_char; 8usize];
}
extern "C" {
	pub static _json_key_input: [::core::ffi::c_char; 6usize];
}
extern "C" {
	pub static _json_key_output: [::core::ffi::c_char; 7usize];
}
extern "C" {
	pub static _json_key_safe: [::core::ffi::c_char; 5usize];
}
extern "C" {
	pub static _json_key_idempotent: [::core::ffi::c_char; 11usize];
}
extern "C" {
	pub static _json_key_events: [::core::ffi::c_char; 7usize];
}
extern "C" {
	pub static _json_key_subscription: [::core::ffi::c_char; 13usize];
}
extern "C" {
	pub static _json_key_data: [::core::ffi::c_char; 5usize];
}
extern "C" {
	pub static _json_key_cancellation: [::core::ffi::c_char; 13usize];
}
extern "C" {
	pub static _json_links: [::core::ffi::c_char; 6usize];
}
extern "C" {
	pub static _json_key_base: [::core::ffi::c_char; 5usize];
}
extern "C" {
	pub static _json_key_rel: [::core::ffi::c_char; 4usize];
}
extern "C" {
	pub static _json_key_anchor: [::core::ffi::c_char; 7usize];
}
extern "C" {
	pub static _json_key_support: [::core::ffi::c_char; 8usize];
}
extern "C" {
	pub static _json_key_version: [::core::ffi::c_char; 8usize];
}
extern "C" {
	pub static _json_key_instance: [::core::ffi::c_char; 9usize];
}
extern "C" {
	pub static _json_key_forms: [::core::ffi::c_char; 6usize];
}
extern "C" {
	pub static _json_key_created: [::core::ffi::c_char; 8usize];
}
extern "C" {
	pub static _json_key_modified: [::core::ffi::c_char; 9usize];
}
extern "C" {
	pub static _json_key_properties: [::core::ffi::c_char; 11usize];
}
extern "C" {
	pub static _json_key_identity: [::core::ffi::c_char; 9usize];
}
extern "C" {
	pub static _json_key_authorization: [::core::ffi::c_char; 14usize];
}
#[doc = " @brief   Generic JSON object type for serialization, represented as a linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_norm_obj {
	#[doc = "< The next element of the linked list."]
	pub next: *mut wot_td_norm_obj,
	#[doc = "< The key of the current element in the linked list."]
	pub key: *const ::core::ffi::c_char,
	#[doc = "< The value of the current element in the linked list."]
	pub value: *mut ::core::ffi::c_void,
}
#[doc = " @brief   Generic JSON object type for serialization, represented as a linked list."]
pub type wot_td_norm_obj_t = wot_td_norm_obj;
#[doc = " @brief   Generic JSON array type for serialization, represented as a linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_norm_array {
	#[doc = "< The next element of the linked list."]
	pub next: *mut wot_td_norm_array,
	#[doc = "< The current element of the linked list."]
	pub value: *mut ::core::ffi::c_void,
}
#[doc = " @brief   Generic JSON array type for serialization, represented as a linked list."]
pub type wot_td_norm_array_t = wot_td_norm_array;
#[doc = " @brief   ..."]
pub type json_writer_t = ::core::option::Option<
	unsafe extern "C" fn(
		receiver: wot_td_serialize_receiver_t,
		slicer: *mut wot_td_ser_slicer_t,
		lang: *mut ::core::ffi::c_char,
		data: *mut ::core::ffi::c_void,
	),
>;
#[doc = " @brief   Parameters for serializing a JSON object in a WoT TD."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_obj_serializer_params_t {
	#[doc = "< The receiver of the serialized object."]
	pub receiver: wot_td_serialize_receiver_t,
	#[doc = "< The slicer used for slicing the payload."]
	pub slicer: *mut wot_td_ser_slicer_t,
	#[doc = "< The JSON converter function."]
	pub writer: json_writer_t,
	#[doc = "< The object data to serialize."]
	pub data: *mut wot_td_norm_obj_t,
	#[doc = "< The default language."]
	pub lang: *mut ::core::ffi::c_char,
}
#[doc = " @brief   Parameters for serializing a JSON array in a WoT TD."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wot_td_array_serializer_params_t {
	#[doc = "< The receiver of the serialized array."]
	pub receiver: wot_td_serialize_receiver_t,
	#[doc = "< The slicer used for slicing the payload."]
	pub slicer: *mut wot_td_ser_slicer_t,
	#[doc = "< The JSON converter function."]
	pub writer: json_writer_t,
	#[doc = "< The array data to serialize."]
	pub data: *mut wot_td_norm_array_t,
	#[doc = "< The default language."]
	pub lang: *mut ::core::ffi::c_char,
}
extern "C" {
	#[doc = " @brief   Serializes a WoT TD JSON object."]
	#[doc = ""]
	#[doc = " @param[in] params The parameters for the object serialization."]
	pub fn _json_write_obj(params: *mut wot_td_obj_serializer_params_t);
}
extern "C" {
	#[doc = " @brief   Serializes a WoT TD JSON array."]
	#[doc = ""]
	#[doc = " @param[in] params The parameters for the array serialization."]
	pub fn _json_write_array(params: *mut wot_td_array_serializer_params_t);
}
extern "C" {
	#[doc = " @brief   Serializes a WoT TD JSON string."]
	#[doc = ""]
	#[doc = " @param[out] receiver The receiver the serialized Thing is written to."]
	#[doc = " @param[in] slicer The slicer used for segmenting the payload."]
	#[doc = " @param[in] lang The default language used for multi-language fields."]
	#[doc = " @param[in] data The data that is to be written."]
	pub fn _string_writer(
		receiver: wot_td_serialize_receiver_t,
		slicer: *mut wot_td_ser_slicer_t,
		lang: *mut ::core::ffi::c_char,
		data: *mut ::core::ffi::c_void,
	);
}
extern "C" {
	#[doc = " @brief   Serializes a WoT TD language string."]
	#[doc = ""]
	#[doc = " @param[out] receiver The receiver the serialized Thing is written to."]
	#[doc = " @param[in] slicer The slicer used for segmenting the payload."]
	#[doc = " @param[in] lang The default language used for multi-language fields."]
	#[doc = " @param[in] data The data that is to be written."]
	pub fn _serialize_lang(
		receiver: wot_td_serialize_receiver_t,
		slicer: *mut wot_td_ser_slicer_t,
		lang: *mut ::core::ffi::c_char,
		data: *mut ::core::ffi::c_void,
	);
}
extern "C" {
	#[doc = " @brief   Serializes the key of a WoT TD security definition."]
	#[doc = ""]
	#[doc = " @param[out] receiver The receiver the serialized Thing is written to."]
	#[doc = " @param[in] slicer The slicer used for segmenting the payload."]
	#[doc = " @param[in] lang The default language used for multi-language fields."]
	#[doc = " @param[in] data The data that is to be written."]
	pub fn _serialize_sec_def_string(
		receiver: wot_td_serialize_receiver_t,
		slicer: *mut wot_td_ser_slicer_t,
		lang: *mut ::core::ffi::c_char,
		data: *mut ::core::ffi::c_void,
	);
}
extern "C" {
	#[doc = " @brief   Serializes the value of a WoT TD security definition."]
	#[doc = ""]
	#[doc = " @param[out] receiver The receiver the serialized Thing is written to."]
	#[doc = " @param[in] slicer The slicer used for segmenting the payload."]
	#[doc = " @param[in] lang The default language used for multi-language fields."]
	#[doc = " @param[in] data The data that is to be written."]
	pub fn _write_security(
		receiver: wot_td_serialize_receiver_t,
		slicer: *mut wot_td_ser_slicer_t,
		lang: *mut ::core::ffi::c_char,
		data: *mut ::core::ffi::c_void,
	);
}
extern "C" {
	#[doc = " @brief   Initializes the serialization of the Thing Description."]
	#[doc = ""]
	#[doc = " @param[in] thing The Thing Description base struct."]
	#[doc = ""]
	#[doc = " @return 0 if initialization was successful, a non-zero value otherwise."]
	pub fn wot_td_config_init(thing: *mut wot_td_thing_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Persists a Thing Description."]
	#[doc = ""]
	#[doc = " @param[in] thing The Thing Description to persist."]
	#[doc = ""]
	#[doc = " @return 0 if persisting was successful, a non-zero value otherwise."]
	pub fn wot_td_persistence_write(thing: *mut wot_td_thing_t) -> ::core::ffi::c_int;
}
extern "C" {
	#[doc = " @brief   Reads a persisted Thing Description."]
	#[doc = ""]
	#[doc = " @return The retrieved Thing Description."]
	pub fn wot_td_persistence_read() -> *mut wot_td_thing_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
	pub _address: u8,
}
